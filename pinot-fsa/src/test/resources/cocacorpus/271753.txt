
@@75677630 @4377630/ <h> Akana Platform Overview <h> Akana API Management <p> The Akana Platform provides an end-to-end API Management solution for designing , implementing , securing , managing , monitoring , and publishing APIs . It is available as a SaaS platform , on-premises , and as a hybrid deployment . Learn more about Akana API Management features here . <h> What 's new in Akana Platform 8.4 <p> Akana 8.4 assures complete visibility and management of the API process from development to production . <p> Build and manage well-crafted enterprise-class APIs with a complete view of the process . <p> Drive an efficient process that ensure only the right things get to production . <h> API Design <p> The Akana Platform provides a comprehensive API design platform . You can use a graphical tool to design your API from scratch or you can import API descriptor language of your choice . Once you have your design complete , the platform will then automatically generate all the common API descriptor documents for you . The API designer supports : <p> Graphical API design define your API with an intuitive graphical tool @ @ @ @ @ @ @ @ @ @ for execution in the Gateway and publication in the Portal <p> Import and automatic generation of common descriptor languages - allow your API developers and administrators to publish APIs using the descriptor language they prefer , and your developer community to consume APIs using the descriptor of their choice . Supports ; Swagger , RAML , WADL , WSDL . <p> Integrated lifecycle management provide just the right amount of control over the lifecycle of APIs and Apps <p> The Akana Platform includes a turnkey developer portal providing a social platform for API developers to design and document their APIs , and App developers to find and consume APIs . The Akana Platform is ideally suited to connect with different audiences : <p> Internal Using the default theme , organizations can quickly deploy a turnkey , customizable , and brandable portal catering to the needs of both API and App Developers within the organization <p> B2B Organizations can leverage the integrated role-based access control ( RBAC ) in the default theme , along with the ability to host the portal both internally and externally for different roles , to quickly @ @ @ @ @ @ @ @ @ @ to interact directly with external App developers <p> The Akana Platform is built on top of a fully featured lifecycle management system to help ensure that you are building the right APIs , that you are building them correctly , and that they are meeting the needs of your business . The lifecycle management system offers : <p> Fully managed - Customers never have to worry about performance , capacity , availability , security , upgrades , or any of the normal concerns with running their own infrastructure <p> A certified PCI DSS 3.0 Level 1 Service Provider <p> Compliant with the EU Data Protection Directive for the processing of personal data and on the free movement of such data ( also known as Directive 95/46/EC ) <p> On-premises - the Akana Platform is proven over many years as the on-premises API platform of choice for large enterprise , it 's ease of installation and upgrade is a major advantage <p> Hybrid - for customers looking for the best of both worlds we offer a true hybrid model where customers can run their own API brokers either on-premises or as @ @ @ @ @ @ @ @ @ @ cloud to manage these brokers and provide the central developer portal <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75677631 @4377631/ <p> Class RWCString offers very powerful and convenient facilities for manipulating strings that are just as efficient as the familiar standard C &lt;string.h&gt; functions . <p> Although the class is primarily intended to be used to handle single-byte character sets ( SBCS ; such as ASCII or ISO Latin-1 ) , with care it can be used to handle multibyte character sets ( MBCS ) . There are two things that must be kept in mind when working with MBCS : <p> Because characters can be more than one byte long , the number of bytes in a string can , in general , be greater than the number of characters in the string . Use function RWCString : : length() to get the number of bytes in a string , function RWCString : : mbLength() to get the number of characters . Note that the latter is much slower because it must determine the number of bytes in every character . Hence , if the string is known to be nothing but SBCS , then RWCString : : length() is much to be preferred . <p> One or @ @ @ @ @ @ @ @ @ @ Hence , MBCS can not be counted on being null terminated . In practice , it is a rare MBCS that uses embedded nulls . Nevertheless , you should be aware of this and program defensively . In any case , class RWCString can handle embedded nulls . <p> Parameters of type " const char* " must not be passed a value of zero . This is detected in the debug version of the library . <p> The class is implemented using a technique called copy on write . With this technique , the copy constructor and assignment operators still reference the old object and hence are very fast . An actual copy is made only when a " write " is performed , that is if the object is about to be changed . The net result is excellent performance , but with easy-to-understand copy semantics . <p> Class RWCString uses a single mutex to protect string reference counts . When run in a multithreaded , multiprocessor environment contention for RWCStrings single mutex can cause performance issues . <p> To address RWCString-related performance issues that may occur in a @ @ @ @ @ @ @ @ @ @ , RWCSTRINGMUTEXCOUNT . This macro let 's you adjust RWCString to use any number of mutexes . You use the macro by creating a custom configuration in Software Parts Manager that defines the macro and sets it equal to the desired number of mutexes ( -DRWCSTRINGMUTEXCOUNT=X ) . You then build your Tools.h++ library with the new configuration . <p> This feature should only be used in a multithreaded , multiprocessor environment when your code is RWCString intensive . In other circumstances , changing the number of mutexes available will negatively affect performance . <p> To help you determine the optimal number of mutexes , we provide a second macro , RWCSTRINGMUTEXCOUNTINFO , that makes available the function printStringMutexCount() . The new function prints a usage histogram for the pool of mutexes . By reviewing the histogram you can determine the best number of mutexes for your environment . To use the printStringMutexCount() function , update your custom configuration to include the macro definition **25;0;TOOLONG . You can remove the second macro definition from your library after determining the best number of mutexes . <p> A tip of the Rogue Wave @ @ @ @ @ @ @ @ @ @ <p> Conversion from the null-terminated character string cs . The created string will copy the data pointed to by cs , up to the first terminating null . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> RWCString ( const char* cs , sizet N ) ; <p> Constructs a string from the character string cs . The created string will copy the data pointed to by cs . Exactly N bytes are copied , including any embedded nulls . Hence , the buffer pointed to by cs must be at least N bytes long . <p> RWCString ( RWSizeT ic ) ; <p> Creates a string of length zero ( the null string ) . The string 's capacity ( that is , the size it can grow to without resizing ) is given by the parameter ic . We recommend creating an RWSizeT value from a numerical constant to pass into this constructor . While RWSizeT knows how to convert sizet 's to itself , conforming compilers will chose the conversion to char instead . @ @ @ @ @ @ @ @ @ @ constructor . The created string will copystr 's data . <p> RWCString ( const RWCSubString&amp; ss ) ; <p> Conversion from sub-string . The created string will copy the substring represented by ss . <p> Access to the RWCString 's data as a null terminated string . This data is owned by the RWCString and may not be deleted or changed . If the RWCString object itself changes or goes out of scope , the pointer value previously returned may ( will ! ) become invalid . While the string is null-terminated , note that its length is still given by the member function length() . That is , it may contain embedded nulls . <p> Assignment operator . Copies the null-terminated character string pointed to by cs into self . Returns a reference to self . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> RWCString&amp; operator= ( const RWCString&amp; str ) ; <p> Assignment operator . The string will copystr 's data . Returns a reference to self . <p> RWCString&amp; operator+= ( const char* @ @ @ @ @ @ @ @ @ @ to by cs to self . Returns a reference to self . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> Return the ith byte . The first variant can be used as anlvalue . The index i must be between 0 and the length of the string less one . Bounds checking is performed -- if the index is out of range then an exceptionof type RWBoundsErr will occur . <p> char&amp; operator() ( sizet i ) ; char operator() ( sizet i ) const ; <p> Return the ith byte . The first variant can be used as anlvalue . The index i must be between 0 and the length of the string less one . Bounds checking is performed if the pre-processor macro RWBOUNDSCHECK has been defined before including &lt;rw/cstring.h&gt; . In this case , if the index is out of range , then an exception of type RWBoundsErr will occur . <p> Substring operator . Returns an RWCSubString of self with length len , starting at index start . The first variant can @ @ @ @ @ @ @ @ @ @ len must be less than or equal to the string length . If the library was built using the RWDEBUG flag , and start and len are out of range , then an exception of type RWBoundsErr will occur . <p> Returns the first substring starting after index start that matches the regular expression re . If there is no such substring , then the null substring is returned . The first variant can be used as an lvalue . <p> Note that if you wish to use operator() ( const RWCRExpr&amp; ... ) you must instead use match ( constRWCRExpr&amp; ... ) described below . The reason for this is that we are presently retaining RWCRegexp but operator ( const RWCRExpr&amp; ... ) and operator ( const RWCRegexp ) are ambiguous in the case of RWCString : : operator ( " string " ) . In addition , operator ( const char * ) and operator(sizet) are ambiguous in the case of RWCString : : operator(0) . This function maybe incompatible with strings with embedded nulls . This function is incompatible with MBCS strings . <p> Append a copy @ @ @ @ @ @ @ @ @ @ self . Returns a reference to self . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> RWCString&amp; append ( const char* cs , sizet N ) ; <p> Append a copy of the character string cs to self . Exactly N bytes are copied , including any embedded nulls . Hence , the buffer pointed to by cs must be at least N bytes long . Returns a reference to self . <p> RWCString&amp; append ( char c , sizet N ) ; <p> Append N copies of the character c to self . Returns a reference to self . <p> RWCString&amp; append ( const RWCString&amp; cstr ) ; <p> Append a copy of the string cstr to self . Returns a reference to self . <p> RWCString&amp; append ( const RWCString&amp; cstr , sizet N ) ; <p> Append the first N bytes or the length of cstr ( whichever is less ) of cstr to self . Returns a reference to self . <p> sizet binaryStoreSize() const ; <p> Returns the number of bytes @ @ @ @ @ @ @ @ @ @ <p> RWFile&amp; operator&lt;&lt; ( RWFile&amp; , const RWCString&amp; ) ; <p> sizet capacity() const ; <p> Return the current capacity of self . This is the number of bytes the string can hold without resizing . <p> sizet capacity ( sizet capac ) ; <p> Hint to the implementation to change the capacity of self to capac . Returns the actual capacity . <p> Returns an int less then , greater than , or equal to zero , according to the result of calling the standard C library function : : strcoll() on self and the argument str . This supports locale-dependent collation . Provided only on platforms that provide : : strcoll() . This function is incompatible with strings with embedded nulls . <p> Returns an int less than , greater than , or equal to zero , according to the result of calling the standard C library function memcmp() on self and the argument str . Case sensitivity is according to the caseCompare argument , and may be RWCString : : exact or RWCString : : ignoreCase . If caseCompare isRWCString : : exact , then this function @ @ @ @ @ @ @ @ @ @ is incompatible with MBCS strings . This function is incompatible with const char* strings with embedded nulls . This function may be incompatible with const char* MBCS strings . <p> Pattern matching . Returns TRUE if str occurs in self . Case sensitivity is according to the caseCompare argument , and may be RWCString : : exact or RWCString : : ignoreCase . If caseCompare isRWCString : : exact , then this function works for all string types . Otherwise , this function is incompatible with MBCS strings . This function is incompatible with const char* strings with embedded nulls . This function may be incompatible with const char* MBCS strings . <p> const char* data() const ; <p> Access to the RWCString 's data as a null terminated string . This datum is owned by the RWCString and may not be deleted or changed . If the RWCString object itself changes or goes out of scope , the pointer value previously returned will become invalid . While the string is null terminated , note that its length is still given by the member function length() . That is , @ @ @ @ @ @ @ @ @ @ char c ) const ; <p> Returns the index of the first occurence of the character c in self . Returns RWNPOS if there is no such character or if there is an embedded null prior to finding c . This function is incompatible withstrings with embedded nulls . This function is incompatible with MBCS strings . <p> sizet first ( char c , sizet ) const ; <p> Returns the index of the first occurence of the character c in self . Continues to search past embedded nulls . Returns RWNPOS if there is no such character . This function is incompatible with MBCS strings . <p> sizet first ( const char* str ) const ; <p> Returns the index of the first occurence in self of any character in str . Returns RWNPOS if there is no match or if there is an embedded null prior to finding any character from str . This function is incompatible withstrings with embedded nulls . This function may be incompatible with MBCS strings . <p> sizet first ( const char* str , sizet N ) const ; <p> Returns the index @ @ @ @ @ @ @ @ @ @ str . Exactly N bytes in str are checked including any embedded nulls so str must point to a buffer containing at least N bytes . Returns RWNPOS if there is no match . <p> unsigned hash ( caseCompare = RWCString : : exact ) const ; <p> Returns a suitable hash value . If caseCompare is RWCString : : ignoreCase then this function will be incompatible with MBCS strings . <p> Pattern matching . Starting with index i , searches for the first occurrence of pat in self and returns the index of the start of the match . Returns RWNPOS if there is no such pattern . Case sensitivity is according to the caseCompare argument ; it defaults to RWCString : : exact . If caseCompare isRWCString : : exact , then this function works for all string types . Otherwise , this function is incompatible with MBCS strings . <p> Pattern matching . Starting with index i , searches for the first occurrence of the first patlen bytes from pat in self and returns the index of the start of the match . Returns RWNPOS if there @ @ @ @ @ @ @ @ @ @ the caseCompare argument . If caseCompare isRWCString : : exact , then this function works for all string types . Otherwise , this function is incompatible with MBCS strings . <p> Regular expression matching . Returns the index greater than or equal to i of the start of the first pattern that matches the regular expression re . Returns RWNPOS if there is no such pattern . This function is incompatible with MBCS strings . <p> Regular expression matching . Returns the index greater than or equal to i of the start of the first pattern that matches the regular expression re . Returns RWNPOS if there is no such pattern . The length of the matching pattern is returned in the variable pointed to by ext . This function is incompatible withstrings with embedded nulls . This function may be incompatible with MBCS strings . <p> RWCString&amp; insert ( sizet pos , const char* cs ) ; <p> Insert a copy of the null-terminated string cs into self at byte position pos , thus expanding the string . Returns a reference to self . This function is incompatible with @ @ @ @ @ @ @ @ @ @ incompatible with cs MBCS strings . <p> RWCString&amp; insert ( sizet pos , const char* cs , sizet N ) ; <p> Insert a copy of the first N bytes of cs into self at byte position pos , thus expanding the string . Exactly N bytes are copied , including any embedded nulls . Hence , the buffer pointed to by cs must be at least N bytes long . Returns a reference to self . <p> RWCString&amp; insert ( sizet pos , const RWCString&amp; str ) ; <p> Insert a copy of the string str into self at byte position pos . Returns a reference to self . <p> RWCString&amp; insert ( sizet pos , const RWCString&amp; str , sizet N ) ; <p> Insert a copy of the first N bytes or the length of str ( whichever is less ) of str into self at byte position pos . Returns a reference to self . <p> RWBoolean isAscii() const ; <p> Returns TRUE if self contains no bytes with the high bit set . <p> RWBoolean isNull() const ; <p> Returns TRUE if this is a @ @ @ @ @ @ @ @ @ @ . <p> sizet last ( char c ) const ; <p> Returns the index of the last occurrence in the string of the character c . Returns RWNPOS if there is no such character or if there is an embedded null to the right of c in self . This function is incompatible withstrings with embedded nulls . This function may be incompatible with MBCS strings . <p> sizet last ( char c , sizet N ) const ; <p> Returns the index of the last occurrence in the string of the character c . Continues to search past embedded nulls . Returns RWNPOS if there is no such character . This function is incompatible with MBCS strings . <p> sizet length() const ; <p> Return the number of bytes in self . Note that if self contains multibyte characters , then this will not be the number of characters . <p> Returns the first substring starting after index start that matches the regular expression re . If there is no such substring , then the null substring is returned . The first variant can be used as anlvalue . @ @ @ @ @ @ @ @ @ @ const RWCRegexp&amp; ... ) if you want to use extended regular expressions . <p> sizet mbLength() const ; <p> Return the number of multibyte characters in self , according to the Standard C function : : mblen() . Returns RWNPOS if a bad character is encountered . Note that , in general , mbLength() length() . Provided only on platforms that provide : : mblen() . <p> RWCString&amp; prepend ( const char* cs ) ; <p> Prepend a copy of the null-terminated character string pointed to by cs to self . Returns a reference to self . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> RWCString&amp; prepend ( const char* cs , sizet N ) ; <p> Prepend a copy of the character string cs to self . Exactly N bytes are copied , including any embedded nulls . Hence , the buffer pointed to by cs must be at least N bytes long . Returns a reference to self . <p> RWCString&amp; prepend ( char c , sizet N ) ; <p> Prepend N copies @ @ @ @ @ @ @ @ @ @ self . <p> RWCString&amp; prepend ( const RWCString&amp; str ) ; <p> Prepends a copy of the string str to self . Returns a reference to self . <p> RWCString&amp; prepend ( const RWCString&amp; cstr , sizet N ) ; <p> Prepend the first N bytes or the length of cstr ( whichever is less ) of cstr to self . Returns a reference to self . <p> istream&amp; readFile ( istream&amp; s ) ; <p> Reads characters from the input stream s , replacing the previous contents of self , until EOF is reached . Null characters are treated the same as other characters . <p> istream&amp; readLine ( istream&amp; s , RWBoolean skipWhite = TRUE ) ; <p> Reads characters from the input stream s , replacing the previous contents of self , until a newline ( or an EOF ) is encountered . The newline is removed from the input stream but is not stored . Null characters are treated the same as other characters . If the skipWhite argument is TRUE , then whitespace is skipped ( using the iostream library manipulator ws ) before saving @ @ @ @ @ @ @ @ @ @ <p> Reads characters from the input stream s , replacing the previous contents of self , until an EOF or null terminator is encountered . If the number of bytes remaining in the stream is large , you should resize the RWCString to approximately the number of bytes to be read prior to using this method . See " Implementation Details " in the User 's Guide for more information . This function is incompatible withstrings with embedded nulls . This function may be incompatible with MBCS strings . <p> istream&amp; readToDelim ( istream&amp; s , char delim= ' n ' ) ; <p> Reads characters from the input stream s , replacing the previous contents of self , until an EOF or the delimiting character delim is encountered . The delimiter is removed from the input stream but is not stored . Null characters are treated the same as other characters . If delim is ' 0 ' then this function is incompatible withstrings with embedded nulls . If delim is ' 0 ' then this function may be incompatible with MBCS strings . <p> istream&amp; readToken ( istream&amp; @ @ @ @ @ @ @ @ @ @ . Characters are then read from the input stream s , replacing previous contents of self , until trailing whitespace or an EOF is encountered . The whitespace is left on the input stream . Null characters are treated the same as other characters . Whitespace is identified by the standard C library function isspace() . This function is incompatible withMBCS strings . <p> RWCString&amp; remove ( sizet pos ) ; <p> Removes the bytes from the byte position pos , which must be no greater than length() , to the end of string . Returns a reference to self . <p> RWCString&amp; remove ( sizet pos , sizet N ) ; <p> Removes N bytes or to the end of string ( whichever comes first ) starting at the byte position pos , which must be no greater than length() . Returns a reference to self . <p> RWCString&amp; replace ( sizet pos , sizet N , const char* cs ) ; <p> Replaces N bytes or to the end of string ( whichever comes first ) starting at byte position pos , which must be no greater than @ @ @ @ @ @ @ @ @ @ . Returns a reference to self . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> RWCString&amp; replace ( sizet pos , sizet N1 , const char* cs , sizet N2 ) ; <p> Replaces N1 bytes or to the end of string ( whichever comes first ) starting at byte position pos , which must be no greater than length() , with a copy of the string cs . Exactly N2 bytes are copied , including any embedded nulls . Hence , the buffer pointed to by cs must be at least N2 bytes long . Returns a reference to self . <p> RWCString&amp; replace ( sizet pos , sizet N , const RWCString&amp; str ) ; <p> Replaces N bytes or to the end of string ( whichever comes first ) starting at byte position pos , which must be no greater than length() , with a copy of the string str . Returns a reference to self . <p> Replaces N1 bytes or to the end of string ( whichever comes first ) starting @ @ @ @ @ @ @ @ @ @ length() , with a copy of the first N2 bytes , or the length of str ( whichever is less ) , from str . Returns a reference to self . <p> Replaces substring matched by pattern with replacement string . pattern is the new extended regular expression . scope is one of one , all and controls whether all matches of pattern are replaced with replacement or just the first one match is replaced . replacement is the replacement pattern for the string . Here 's an example : <p> Returns a substring representing the first occurence of the null-terminated string pointed to by " cs " . The first variant can be used as anlvalue . Case sensitivity is according to the caseCompare argument ; it defaults to RWCString : : exact . If caseCompare is RWCString : : ignoreCase then this function is incompatible with MBCS strings . This function is incompatible with cs strings with embedded nulls . This function may be incompatible with cs MBCS strings . <p> void toLower() ; <p> Changes all upper-case letters in self to lower-case , using the standard C @ @ @ @ @ @ @ @ @ @ strings . <p> void toUpper() ; <p> Changes all lower-case letters in self to upper-case , using the standard C library facilities declared in &lt;ctype.h&gt; . This function is incompatible with MBCS strings . <p> Returns the hash value of str as returned by str.hash ( RWCString : : exact ) . <p> static sizet initialCapacity ( sizet ic = 15 ) ; <p> Sets the minimum initial capacity of an RWCString , and returns the old value . The initial setting is 15 bytes . Larger values will use more memory , but result in fewer resizes when concatenating or reading strings . Smaller values will waste less memory , but result in more resizes . <p> static sizet maxWaste ( sizet mw = 15 ) ; <p> Sets the maximum amount of unused space allowed in a string should it shrink , and returns the old value . The initial setting is 15 bytes . If more than mw bytes are wasted , then excess space will be reclaimed . <p> static sizet resizeIncrement ( sizet ri = 16 ) ; <p> Sets the resize increment when more @ @ @ @ @ @ @ @ @ @ old value . The initial setting is 16 bytes . <p> Comparisons are done lexicographically , byte by byte . Case sensitivity is exact . Use member collate() or strxfrm() for locale sensitivity . This function is incompatible with const char* strings with embedded nulls . This function may be incompatible with const char* MBCS strings . <p> Returns the result of applying : : strxfrm() to the argument string , to allow quicker collation than RWCString : : collate() . Provided only on platforms that provide : : strxfrm() . This function is incompatible with strings with embedded nulls . <p> RWCString toLower ( const RWCString&amp; str ) ; <p> Returns a version of str where all upper-case characters have been replaced with lower-case characters . Uses the standard C library function tolower() . This function is incompatible with MBCS strings . <p> RWCString toUpper ( const RWCString&amp; str ) ; <p> Returns a version of str where all lower-case characters have been replaced with upper-case characters . Uses the standard C library function toupper() . This function is incompatible with MBCS strings . 
@@75677632 @4377632/ <p> Class RWOrdered represents a group of ordered items , accessible by an index number , but not accessible by an external key . Duplicates are allowed . The ordering of elements is determined externally , generally by the order of insertion and removal . An object stored by RWOrdered must inherit from the abstract base class RWCollectable . <p> Class RWOrdered is implemented as a vector of pointers , allowing for more efficient traversing of the collection than the linked list classes . RWSlistCollectables and RWDlistCollectables , but slower insertion in the center of the collection . <p> Returns TRUE if for every item in self , the corresponding item in od at the same index isEqual . The two collections must also have the same number of members . <p> RWCollectable*&amp; operator ( sizet i ) ; <p> Returns the ith element in the collection . If i is out of range , an exception of type RWBoundsErr will occur . The results of this function can be used as an lvalue . <p> RWCollectable*&amp; operator() ( sizet i ) ; <p> Returns the ith element in @ @ @ @ @ @ @ @ @ @ preprocessor directive RWBOUNDSCHECK before including the header file ordcltn.h . In this case , if i is out of range , an exception of type RWBoundsErr will occur . The results of this function can be used as an lvalue . <p> Redefined from class RWCollection . Adds the item to the end of the collection and returns it . Returns nil if the insertion was unsuccessful . <p> void insertAt ( sizet indx , RWCollectable* e ) ; <p> Redefined from class RWSequenceable . Adds a new item to the collection at position indx . The item previously at position i is moved to i+1 , etc . The index indx must be between 0 and the number of items in the collection , or an exception of type RWBoundsErr will be thrown . 
@@75677633 @4377633/ <h> 3.9 Thread Attributes <p> The threads produced using the mechanisms described in earlier examples can be sufficient for typical applications . These threads use default scheduling and stack management strategies defined by the Threading package and the underlying thread API . However , other situations might require more control over a thread 's scheduling behavior and stack memory utilization . <p> For this additional control , the Threading package defines a set of thread attributes that allow you to choose various thread scheduling and stack management policies . Instances of the RWThreadAttribute class define the initial attributes for new classes . The RWThread and RWThreadSelf classes have methods for manipulating the scheduling attributes of an active thread . <p> To define the initial attributes for a thread , you create an RWThreadAttribute instance , set the desired attribute values , and supply this instance to a threaded runnable class instance . The threaded runnable uses the attribute values to configure each new thread created when start() is called . Once a threaded runnable is started , the scheduling attributes of its active thread can be manipulated using member @ @ @ @ @ @ @ @ @ @ Start Policy - Indicates whether or not the newly created thread should be left in the interrupted state upon returning from start() . Threads created by a call to start() are always interrupted immediately after creation and then released before start() returns to its caller . This thread can be released from the interrupt at some later time by calling the runnable 's releaseInterrupt() member . <p> Contention Scope - Defines whether a thread is to contend for processing resources relative to other threads within the same process or relative to other threads within the same system . <p> Scheduling Inheritance Policy - Defines whether the scheduling attributes for scheduling policy , priority , and time-slice quantum should be taken from the thread attribute object or whether they should be inherited from the creating thread . <p> Concurrency Policy - Requests concurrent execution for a new thread . Typically such a request results in the creation of a new kernel-level thread to support parallel ( separate processors ) or time-sliced execution of a new user-level thread . <p> Scheduling Policy - Identifies the scheduling policy to use for deciding which @ @ @ @ @ @ @ @ @ @ threads should be run , and how long the threads should be run . Each scheduling policy can define additional attributes that can be used to control specific aspects of that policy , such as priority value , concurrency policy , or time-slice quantum . <p> Scheduling Priority - Defines a numerical rank or ordering to use in resolving thread contention for processing resources . In the Threading package , threads with numerically higher priority values receive scheduling preference over threads with lower priorities . The legal range of priority values tends to vary significantly between thread APIs and even between scheduling policies.Some platforms , such as Solaris , require the use of two separate priority values for threads with system contention scope . One value sets the system-level scheduling priority for the thread , and the second value prioritizes access to any thread-level synchronization resources shared with other threads in the same process . <p> Time-slice Quantum - Under a time-sliced scheduling policy , this attribute defines the maximum amount of time that a thread is allowed to run before scheduling the next eligible thread to run . Some @ @ @ @ @ @ @ @ @ @ each thread , while others can apply the same quantum to all threads within a scheduling class , process , or system . <p> User Stack Address - The lowest address or bottom of the stack address space reserved , allocated , and managed by the user . <p> User Stack Size - The memory space size of the user-allocated stack . Locates the top of the stack address space where the bottom of the stack is typically located ( for stacks that grow downward in memory ) . <p> Thread attributes and attribute values are not uniformly supported across all environments . Some of the policies and attribute values described in this guide might be available only under specific operating systems . <p> NOTE : Once you begin using thread attributes , you risk compromising the cross-platform portability of your code . <p> This is largely due to the fact that scheduling and stack allocation policies tend to vary significantly between each of the environments supported by the Threading package . Rogue Wave has made every attempt to alleviate or hide these differences without prohibiting access to the platform-specific @ @ @ @ @ @ @ @ @ @ you to carefully review and understand the implementation differences between each platform that you plan to support . <p> To find out which attributes are supported : <p> Read the detailed information about each attribute and attribute value in the platform-specific section in the Threads.h++ Platform User 's Guide . <p> Use the featuretest macros and functions that allow you to determine , at compile or run-time , which attributes and attribute values are supported in the current environment . <p> Use the member functions that manipulate attributes . The member functions are always present , regardless of whether or not the current environment supports the attributes . You can always rely on the existence of the functions and attribute values described in this guide . <p> If you attempt to access an unsupported attribute or use an illegal or unsupported attribute value : <p> An **26;27;TOOLONG exception is produced if an attribute is not supported . <p> An **26;55;TOOLONG exception is produced if an attribute value is not supported under current circumstances . <p> An RWTHRBoundsError is produced if the value falls outside the legal range for that attribute @ @ @ @ @ @ @ @ @ @ by using the feature-test functionality included by the library . <p> As discussed earlier , the specific level of support for each thread attribute varies from platform to platform . The Threading package has several mechanisms and techniques you can use for testing that level of support . <p> Use the following feature-test macros to determine , at compile-time , whether the current environment has any support for the corresponding thread attribute : <p> **25;83;TOOLONG <p> RWTHRHASCONTENTIONSCOPE <p> **25;110;TOOLONG <p> RWTHRHASPRIORITY <p> **28;137;TOOLONG <p> RWTHRHASSCHEDULINGPOLICY <p> RWTHRHASSTACKCOMMITSIZE <p> RWTHRHASSTACKRESERVESIZE <p> RWTHRHASSTARTPOLICY <p> **27;167;TOOLONG <p> RWTHRHASTIMESLICEQUANTUM <p> RWTHRHASUSERSTACK <p> RWTHRHASDUALPRIORITY <p> **30;196;TOOLONG <p> If a macro is not defined , attempts to query or set the corresponding attribute always produce an exception . If the macro is defined , then the current environment has some level of support or recognition for the attribute and might allow you to get or set the attribute value . <p> Use the following functions at run-time to determine whether the current environment allows you to query the corresponding thread attributes : <p> **25;228;TOOLONG <p> canGetContentionScope() <p> **25;255;TOOLONG <p> canGetPriority() <p> **28;282;TOOLONG <p> canGetSchedulingPolicy() <p> canGetStackCommitSize() @ @ @ @ @ @ @ @ @ @ <p> These functions follow several rules : <p> They return FALSE if the corresponding attribute is not supported in the current environment or if the corresponding " get " function can not return a legal value under current circumstances . <p> They return TRUE if the corresponding attribute is supported in the current environment and the corresponding " get " function can return a legal value under current circumstances . <p> If the corresponding attribute value has not yet been set , then a return value of TRUE indicates that a default value is defined and can be queried . <p> They return TRUE if the corresponding attribute still has the value previously set by a call to the matching " set " function . This behavior is similar to that in the " is set " functions . <p> If the inheritance policy is RWTHRINHERIT , the scheduling policy , priority , and time-slice quantum values can not be queried for their default values . If these scheduling attributes are inherited , the " get min " and " get max " functions for these attributes will likely produce @ @ @ @ @ @ @ @ @ @ the legal range of values . <p> Even if an attribute is supported in a particular environment , you might still be restricted from getting and setting that attribute as a consequence of other attribute values . As an example , the concurrency policy attribute might only be accessible when the contention scope is set for process-scope . Some attribute settings might also require specific security authorizations or privileges . <p> Once a thread has been created and is active , you can use the following RWThread or RWThreadSelf functions to test whether or not you can get the corresponding attribute value for an active thread : <p> Use the following functions at run-time to determine whether the current environment allows you to set the corresponding thread attribute value : <p> **44;369;TOOLONG <p> **40;415;TOOLONG <p> **44;457;TOOLONG <p> canSetPriority() <p> **28;503;TOOLONG <p> **42;533;TOOLONG <p> canSetStackCommitSize() <p> canSetStackReserveSize() <p> **32;577;TOOLONG <p> **27;611;TOOLONG <p> canSetTimeSliceQuantum() <p> canSetUserStack() <p> These functions return one of the following values : <p> FALSE if the corresponding attribute is not supported in the current environment or if the specified attribute value ( if any ) is not supported @ @ @ @ @ @ @ @ @ @ is supported in the current environment and the specified value ( if any ) is legal the under current circumstances . <p> Each of these functions that accepts a policy value produces an RWTHRBoundsError exception if the value specified as an argument is not legal policy value for that attribute . This exception can be avoided by making sure that you are using the appropriate enumerated value names for each attribute . <p> Once a thread has been created and is active , you can use the following RWThread or RWThreadSelf functions to test whether or not you can change the corresponding attribute value for an active thread : <p> Use the following functions to determine whether the corresponding attribute still has the value specified by an earlier call to the matching " set " function : <p> isConcurrencyPolicySet() <p> isContentionScopeSet() <p> isInheritancePolicySet() <p> isPrioritySet() <p> **27;640;TOOLONG <p> isSchedulingPolicySet() <p> isStackCommitSizeSet() <p> isStackReserveSizeSet() <p> isStartPolicySet() <p> **26;669;TOOLONG <p> isTimeSliceQuantumSet() <p> isUserStackSet() <p> These functions return one of the following values : <p> FALSE if the corresponding attribute value is not supported in the current environment , has not yet been @ @ @ @ @ @ @ @ @ @ replaced with a some default value in response to a change in some related attribute . <p> TRUE if the corresponding attribute is supported , has been set by a call to the matching " set " function , has not been reset with a call to the matching " reset " function , and has not been forced to a new value as the result of changes made in other attributes . <p> Use the following functions to query the corresponding attribute value : <p> getConcurrencyPolicy() <p> getContentionScope() <p> getInheritancePolicy() <p> getPriority() <p> **25;697;TOOLONG <p> getSchedulingPolicy() <p> getStackCommitSize() <p> getStackReserveSize() <p> getStartPolicy() <p> getSystemScopePriority() <p> getTimeSliceQuantum() <p> getUserStackAddress() <p> getUserStackSize() <p> These functions throw the following exceptions : <p> **26;724;TOOLONG if the attribute is not recognized or supported by the current environment <p> **26;752;TOOLONG if the specified attribute is supported , but its value has not yet been defined with a call to the matching " set " function , and no default value is available under the current circumstances . <p> The process-scope and system-scope priority functions can be substituted for getPriority() , and vice-versa , as long @ @ @ @ @ @ @ @ @ @ a thread has been created and is active , you can use the following RWThread or RWThreadSelf functions to set the corresponding thread attribute value : <p> getPriority() <p> **25;780;TOOLONG <p> getSchedulingPolicy() <p> getSystemScopePriority() <p> getTimeSliceQuantum() <p> In addition to the exceptions produced by their RWTHRThreadAttribute counterparts , these functions throw an RWTHRThreadNotActive exception if the threaded runnable instance being manipulated does not have an active thread . <p> **26;807;TOOLONG if the attribute is not recognized or supported by the current environment <p> **26;835;TOOLONG if the specified attribute value is not supported by the current environment or is not allowed under current circumstances . <p> RWTHRBoundsError if the specified attribute value is invalid or falls outside the current legal range defined for that attribute . <p> The process-scope and system-scope priority functions can be substituted for setPriority(RWPriority) and vice-versa , as long as the appropriate contention scope has been defined . <p> Once a thread has been created and is active , you can use the following RWThread and RWThreadSelf functions to set the corresponding thread attribute value : <p> setPriority(RWPriority) <p> **35;863;TOOLONG <p> **39;900;TOOLONG <p> **34;941;TOOLONG <p> **28;977;TOOLONG long @ @ @ @ @ @ @ @ @ @ RWThreadAttribute counterparts , these functions can throw an RWTHRThreadNotActive exception if the threaded runnable instance being manipulated does not have an active thread . <p> If you do not specify a value for an attribute , then the values are supplied by one of the following : <p> The Threading package . <p> The underlying API . <p> The creating thread or process . <p> For some attributes , you can query an RWThreadAttribute instance for default attribute values by using the appropriate " get " function prior to setting the corresponding attribute . Before attempting to get the value , though , make sure that a default value is available by calling the appropriate " can get " function , as shown in Example 27 . <p> The default values for some attributes might change in response to changes in other attribute values . For example , the range of legal priority values often varies according to the scheduling policy attribute value . <p> The default values for many of the attributes vary from environment to environment . You can find a description of the default values for attributes @ @ @ @ @ @ @ @ @ @ determine the current limits for the priority , stack size , and time-slice quantum attributes , use the following RWThreadAttribute member functions : <p> getMinStackSize() - This static function returns the bare-minimum stack size required by a thread that calls a null function . The Threading package automatically guarantees that the size of any stack allocated by the system is greater than this size . <p> Use this function when creating a user-defined stack . This function can only be called if the RWTHRHASSTACKRESERVESIZE or RWTHRHASUSERSTACK macros are defined . If those macros have not been defined , an **26;1007;TOOLONG exception is produced . <p> getMinPriority() - Returns the minimum priority value supported by the current contention scope and scheduling policy . This function can only be called if RWTHRHASPRIORITY is defined . If it is not defined , an **26;1035;TOOLONG exception is produced . <p> getMaxPriority() - Returns the maximum priority value supported by the current contention scope and scheduling policy . This function can only be called if RWTHRHASPRIORITY is defined . If it is not defined , an **26;1063;TOOLONG exception is produced . <p> **28;1091;TOOLONG - Returns @ @ @ @ @ @ @ @ @ @ current scheduling policy . This function can only be called when the contention scope value is RWTHRPROCESSSCOPE , or when the contention scope is RWTHRSYSTEMSCOPE and the current environment uses dual-priorities as indicated by the definition of the RWTHRHASDUALPRIORITY macro . If those restrictions are not met , an **26;1121;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASPRIORITY is defined . If it is not defined , an **26;1149;TOOLONG exception is produced . <p> **28;1177;TOOLONG - Returns the maximum priority value supported by process-scope threads under the current scheduling policy . This function can only be called when the contention scope value is RWTHRPROCESSSCOPE , or when the contention scope is RWTHRSYSTEMSCOPE and the current environment uses dual-priorities as indicated by the definition of the RWTHRHASDUALPRIORITY macro . If those restrictions are not met , an **26;1207;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASPRIORITY is defined . If it is not defined , an **26;1235;TOOLONG exception is produced . <p> **27;1263;TOOLONG - Returns the minimum priority value supported by system-scope threads under the current scheduling @ @ @ @ @ @ @ @ @ @ contention scope value is RWTHRSYSTEMSCOPE . If the value is not RWTHRSYSTEMSCOPE , an **26;1292;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASPRIORITY is defined . If it is not define , an **26;1320;TOOLONG exception is produced . <p> **27;1348;TOOLONG - Returns the maximum priority value supported by system-scope threads under the current scheduling policy . This function can only be called when the contention scope value is RWTHRSYSTEMSCOPE . If the value is not RWTHRSYSTEMSCOPE , an **26;1377;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASPRIORITY is defined . If it is not defined , an **26;1405;TOOLONG exception is produced . <p> getMinTimeSliceQuantum() - Returns the minimum time-slice quantum value supported under the current scheduling policy . This function can only be called when the environment and scheduling policy support a time-slice quantum attribute . If the current policy does not give access to the time-slice quantum , an **26;1433;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASTIMESLICEQUANTUM is defined . If it is not defined , an @ @ @ @ @ @ @ @ @ @ maximum time-slice quantum value supported under the current scheduling policy . This function can only be called when the environment and scheduling policy support a time-slice quantum attribute . If the current policy does not give access to the time-slice quantum , an **26;1489;TOOLONG exception is thrown . In addition , this function can only be called if RWTHRHASTIMESLICEQUANTUM is defined . If it is not defined , an **26;1517;TOOLONG exception is produced . <p> Once a thread has been created and is active , you can use a similar set of functions included in the RWThread and RWThreadSelf classes . <p> getMinPriority() <p> getMaxPriority() <p> **28;1545;TOOLONG <p> **28;1575;TOOLONG <p> **27;1605;TOOLONG <p> **27;1634;TOOLONG <p> getMinTimeSliceQuantum() <p> getMaxTimeSliceQuantum() <p> In addition to throwing the same exceptions as their RWThreadAttribute counterparts , these functions might also produce an RWTHRThreadNotActive exception if you attempt to query the current limits on a threaded runnable that does not possess an active thread . <p> The scheduling attributes are used to control the allocation of processing and synchronization among the various competing threads in an application or system . <p> The availability and allowable range for @ @ @ @ @ @ @ @ @ @ attribute values . The dependencies between scheduling attributes are hierarchical in nature and must be considered when getting or setting scheduling attribute values . A change in one attribute can force another previous attribute setting to be discarded . Figure 15 illustrates the structure of these dependency relationships . <p> In the Threading package , new threads of execution are created by calling the start() member on an instance of a threaded runnable class . The start() function creates a new thread and immediately interrupts that thread in order to make any necessary adjustments to the thread 's scheduling attributes before the thread starts executing within its run() member . <p> The start policy attribute indicates whether or not to leave the newly created thread in the interrupted state upon return from start() . Normally , a new thread is released from this interrupt before start() returns . If requested using this attribute , though , the thread can be left in the interrupted state , where it can be released some time later by calling the releaseInterrupt() member of the threaded runnable instance . <p> RWTHRSTARTRUNNING - Specifies that @ @ @ @ @ @ @ @ @ @ and initialization . This is the default start policy . <p> RWTHRSTARTINTERRUPTED - Specifies that a new thread should be left interrupted following start-up and initialization . Interrupted threads can be released when convenient by calling the releaseInterrupt() member on the same threaded runnable class instance . <p> The RWThreadAttribute member functions that are used to manipulate the start policy attribute include : <p> canGetStartPolicy() - Indicates whether the start policy attribute is supported in the current environment and whether getStartPolicy() can currently return a legal value . This function always returns TRUE and has been included for consistency . <p> isStartPolicySet() - Indicates whether the start policy attribute value is the value that was previously set by a call to setStartPolicy() . <p> getStartPolicy() - Returns the default start policy value if the attribute value has not yet been set . Otherwise , it returns the value specified in the last call to setStartPolicy() . The default start policy is available under all circumstances , and is defined as RWTHRSTARTRUNNING . <p> canSetStartPolicy() - Indicates whether the start policy attribute and attribute value passed as an argument are supported @ @ @ @ @ @ @ @ @ @ for either of the start policies and has been included for consistency . <p> setStartPolicy() - Sets the start policy attribute to the value passed as an argument . This function only throws an exception if the value passed is not one of the two legal values . <p> No specific interdependencies exist between the start policy attribute and other scheduling attributes . <p> The start policy specified by an RWThreadAttribute can only be used at thread creation . To interrupt an active thread , use the RWThread member requestInterrupt() or the RWThreadSelf member interrupt() . <p> The contention scope attribute is used to specify whether a thread is to compete for processing resources with other threads in the same process or with other processes in the same system . <p> A process-scope thread is multiplexed with other process-scope threads on one or more underlying kernel threads in a N:1 or N:M relationship . A system-scope thread is typically bound in a 1:1 relationship with a kernel thread . Figure 16 illustrates these relationships . <p> Choosing between process-scope and system-scope . When choosing between process-scope and system-scope threads , @ @ @ @ @ @ @ @ @ @ . Process-scope threads are generally scheduled and synchronized by code executing in the underlying threads library in user-space , while system-level threads are scheduled and synchronized by the kernel . Kernel-level synchronization and scheduling is , in general , significantly more expensive than user-level synchronization and scheduling . Because of this high processing cost , specify system contention scope only when system-wide scheduling issues must be addressed by your code , as when your application must include real-time behavior or operate under real-time constraints . <p> Using the feature test macro . The feature test macro for contention scope is RWTHRHASCONTENTIONSCOPE . If this macro is not defined , attempts to query or set the contention scope attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for contention scope and might allow you to get or set the contention scope attribute . <p> The RWThreadAttribute member functions that manipulate the contention scope attribute value include : <p> canGetContentionScope() - Indicates whether the contention scope attribute is supported in the current environment and whether getContentionScope() can currently return @ @ @ @ @ @ @ @ @ @ contention scope attribute value is the value that was previously set by a call to **37;1663;TOOLONG . <p> getContentionScope() - Returns the default contention scope value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **37;1702;TOOLONG . If the current environment does not support or define the contention scope attribute , then attempts to use this function result in exceptions . <p> canSetContentionScope() - Indicates whether the contention scope attribute and attribute value passed as an argument are supported in the current environment . <p> **37;1741;TOOLONG - Sets the contention scope attribute to the value passed as an argument . If the current environment does not support the contention scope attribute or the specified attribute value , then attempts to use this function result in exceptions . <p> Specifying the contention scope . The contention scope of a thread can only be specified when a thread is created . You can not change the contention scope of an active thread . <p> Changing the contention scope . Changing the contention scope value might cause a previous setting @ @ @ @ @ @ @ @ @ @ and concurrency attribute to be discarded . When you change the contention scope attribute , the Threading package validates these related attributes to ensure that any previous setting is compatible with the new scope , and if not , resets that attribute . The availability , default value , and supported range for these dependent attributes often vary in response to changes in the contention scope value . The specific dependencies and validation requirements are unique to each environment , and can be found in the appropriate user 's guide supplement . <p> Determining contention scope . To determine the contention scope of an active thread : <p> Acquire a handle to the thread 's runnable instance . <p> Use the getActiveAttribute() member in the handle class to retrieve a copy of the RWThreadAttribute instance used to create the thread . <p> Use the getContentionScope() member to query the attribute instance for the contention scope used . <p> The inheritance policy attribute is used to indicate whether the scheduling policy , priority , and time-slice quantum attributes for a new thread should be inherited from the creating thread or whether @ @ @ @ @ @ @ @ @ @ RWThreadAttribute instance . <p> RWTHRINHERIT - Specifies that the default scheduling policy , priority , and time-slice quantum attributes should be inherited from the creating thread , if each of those attribute values has been left unchanged or has been restored to the default value with a call to the appropriate " reset " function . This is the default inheritance policy . <p> RWTHREXPLICIT - Specifies that the default scheduling policy , priority , and time-slice quantum attributes should not be inherited , but should be included in the thread attribute instance . <p> The RWThreadAttribute member functions that manipulate the inheritance policy attribute value include : <p> **25;1780;TOOLONG - Indicates whether the inheritance policy attribute is supported in the current environment and whether getInheritancePolicy() can currently return a legal value . This function always returns TRUE and is included for consistency . <p> isInheritancePolicySet() - Indicates whether the inheritance policy attribute value is the value that was previously set by a call to **41;1807;TOOLONG . <p> getInheritancePolicy() - Returns the default inheritance policy value if the attribute value has not yet been set . Otherwise , it returns @ @ @ @ @ @ @ @ @ @ The default inheritance policy is available under all circumstances and is defined as RWTHRINHERIT . <p> **25;1893;TOOLONG - Indicates whether the inheritance policy attribute and attribute value passed as an argument are supported in the current environment . This function always returns TRUE for either of the inheritance policies and is included for consistency . <p> **41;1920;TOOLONG - Sets the inheritance policy attribute to the value passed as an argument . This function only throws an exception if the value passed is not one of the two legal values . <p> As described in the previous section , some systems support N-to-M thread scheduling . In these systems , a process-scope thread is multiplexed with other process-scope threads on to one or more underlying kernel threads in N-to-M relationship . The concurrency policy attribute can be used to indicate whether or not the underlying threads system should increase the number of kernel threads when it creates a new process-scope thread , as illustrated in Figure 17 . <p> Issues to consider when requesting the creation of additional kernel threads : <p> You can increase the effective concurrency of the threads @ @ @ @ @ @ @ @ @ @ on separate processors and often use time-slicing when scheduling kernel threads on a single processor . <p> When increasing the effective concurrency level , consider the processing cost associated with creating new kernel threads and the higher cost of scheduling and synchronizing them . <p> Process-scope threads are generally scheduled and synchronized by code executing in the underlying threads library in user-space , while the underlying kernel threads are scheduled and synchronized by calls to the kernel . <p> Even though increasing the effective concurrency level can result in increased processing costs , this method is still preferable to choosing system-scope threads over process-scope threads . <p> The difference is that kernel threads added when the concurrency level is increased are still shared between process-level threads , while system-scope threads are permanently bound to kernel threads , thereby prohibiting their reuse during blocking waits . <p> Using the feature test macro . The feature test macro for concurrency policy is **25;1963;TOOLONG . If this macro is not defined , attempts to query or set the concurrency policy attribute always produce an exception . If it is defined , then the @ @ @ @ @ @ @ @ @ @ concurrency policy and might allow you to get or set the concurrency policy attribute . <p> RWTHRNOCHANGE - The creation of a new process-scope with this attribute value thread does not force the creation of a new underlying kernel thread . This value does not prohibit the threads system from choosing to create new kernel threads if its own policies dictate such a necessity . <p> RWTHRINCREASE - Creation of a new process-scope thread forces the creation of a new underlying kernel thread . <p> The RWThreadAttribute member functions that manipulate the concurrency policy attribute value include : <p> **25;1990;TOOLONG - Indicates whether the concurrency policy attribute is supported in the current environment and whether getConcurrencyPolicy() can currently return a legal value . <p> isConcurrencyPolicySet() - Indicates whether the concurrency policy attribute value is the value that was previously set by a call to **41;2017;TOOLONG . <p> getConcurrencyPolicy() - Returns the default concurrency policy value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **41;2060;TOOLONG . If the current environment does not support or define the concurrency @ @ @ @ @ @ @ @ @ @ in exceptions . <p> **25;2103;TOOLONG - Indicates whether the concurrency policy attribute and attribute value passed as an argument are supported in the current environment . <p> **41;2130;TOOLONG - Sets the concurrency policy attribute to the value passed as an argument . If the current environment does not support the concurrency policy attribute or the specified attribute value , then attempts to use this function result in exceptions . <p> Often in a multithreaded system , more threads exist than processors available to run them . The scheduling policy attribute contains the policy that the system uses in selecting threads to run on available processors . <p> Threads can exist in several states as explained below and illustrated in Figure 18 . <p> A thread becomes runnable when created , unless explicitly created in a stopped state . <p> Eventually , a runnable thread is selected , or dispatched , for execution on a processor and becomes active . <p> While executing , a thread can block waiting on a synchronization resource such as a mutex or condition variable . <p> Once the synchronization resource releases the thread , it @ @ @ @ @ @ @ @ @ @ If a higher-priority thread become runnable while a lower-priority thread is active , the lower-priority thread is preempted and returned to the runnable state so that the higher-priority thread can execute . <p> Threads can also be suspended , leaving them in a stopped stated until continued . A thread can voluntarily preempt itself by yielding execution and explicitly block itself by sleeping . <p> A thread usually exits at some point and , depending on the system , might enter an exited state where the thread waits to be joined or simply cease to exist . <p> A scheduling policy dictates how and when threads are to enter or leave the runnable , active , and blocked states . A scheduling policy defines : <p> The criteria for selecting the next runnable thread to dispatch when an active thread yields or blocks . <p> The conditions under which an active thread is to be preempted . <p> The criteria for selecting the next thread to awaken if more than one thread is waiting on the same synchronization resource . In some cases , this determination is made by the @ @ @ @ @ @ @ @ @ @ The scheduling policy is system dependent . In some systems , each thread can be assigned a different scheduling policy , allowing the developer to choose the policy that best meets the requirements for that thread . In other systems , the scheduling policies are defined at the process level , or fixed according to a thread 's contention scope . <p> Possible scheduling policy values . The enumerated type , RWSchedulingPolicy , defines the set of all possible scheduling policy values supported by the Threading package as : <p> RWTHROTHER - Included as a catch-all for scheduling policies that ca n't be categorized as one of the policies defined by the remaining RWSchedulingPolicy values . This policy is usually mapped to the default policy of the underlying thread 's API , but is seldom returned by the getSchedulingPolicy() function , which generally returns the one of the policies ( listed below ) that most closely describes the default policy . <p> RWTHRPREEMPTIVE - In preemptive scheduling , threads run until preempted by a thread of higher-priority or until blocked . Thread priorities are set by the application ; the @ @ @ @ @ @ @ @ @ @ <p> RWTHRTIMESLICEDDYNAMIC - In systems with dynamic time-sliced scheduling , threads still run either until they are preempted by a thread of higher priority , until some time-quantum has elapsed , or until blocked . The difference is that the priority and/or time-slice quantum assigned to a thread can be altered dynamically by the system to give some level of fairness and optimization . <p> RWTHRTIMESLICEDFIXED - Under a fixed , time-sliced scheduling policy , threads are still time-sliced , but the thread priorities are not altered by the system . <p> Using the feature test macro . The feature test macro for scheduling policy is RWTHRHASSCHEDULINGPOLICY . If this macro is not defined , attempts to query or set the scheduling policy attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for scheduling policy and might allow you to get or set the scheduling policy attribute . <p> Member functions . The RWThreadAttribute member functions that manipulate the scheduling policy attribute include : <p> canGetSchedulingPolicy() - Indicates whether the scheduling policy attribute is supported in the @ @ @ @ @ @ @ @ @ @ value . <p> isSchedulingPolicySet() - Indicates whether the scheduling policy attribute value is the value that was previously set by a call to **39;2173;TOOLONG . <p> getSchedulingPolicy() - Returns the default scheduling policy value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **39;2214;TOOLONG . If the current environment does not support or define the scheduling policy attribute , then attempts to use this function result in exceptions . <p> canSetSchedulingPolicy() - Indicates whether the scheduling policy attribute and attribute value passed as an argument are supported in the current environment . <p> **39;2255;TOOLONG - Sets the scheduling policy attribute to the value passed as an argument . If the current environment does not support the scheduling policy attribute or the specified attribute value , then attempts to use this function result in exceptions . <p> resetSchedulingPolicy() - Restores the scheduling policy attribute to its default value . The default value can vary according to the current value of other attributes . <p> Changing the contention scope . In addition to any environment-specific restrictions , the availability @ @ @ @ @ @ @ @ @ @ scope . Changing the contention scope attribute value can cause a previous scheduling policy setting to be discarded and can affect the availability of specific scheduling policies . <p> Changing the scheduling policy . Similarly , changing the scheduling policy value can cause a previous setting of the priority and time-slice quantum attributes to be discarded . When you change the scheduling policy attribute , the Threading package validates these related attributes to insure that any previous setting is compatible with the new policy , and if not , resets that attribute . The default value and supported range for these dependent attributes often vary in response to changes in the scheduling policy value . The specific dependencies and validation requirements are unique to each environment . <p> Inheriting a scheduling policy . Scheduling policy can be inherited from the creating thread if the inheritance policy attribute is defined as RWTHRINHERIT . If the inheritance attribute is RWTHREXPLICIT , the Threading package chooses a default policy appropriate for the current settings and environment . <p> Setting the scheduling policy . Setting the scheduling policy attribute value when the current inheritance @ @ @ @ @ @ @ @ @ @ changed to RWTHREXPLICIT . <p> Using the scheduling policy . The scheduling policy specified by an RWThreadAttribute can only be used when the thread is created . To manipulate the scheduling policy for an active thread , use the following RWThread and RWThreadSelf member functions : <p> canGetSchedulingPolicy() <p> getSchedulingPolicy() <p> canSetSchedulingPolicy() <p> **39;2296;TOOLONG <p> Exceptions . In addition to throwing the same exceptions as their RWThreadAttribute counterparts , an RWTHRThreadNotActive exception is thrown if you attempt to query or set the scheduling policy on a threaded runnable that does not possess an active thread . <p> Thread priority is the key factor considered by most scheduling policies when choosing the next thread to execute on a processor . Priority values define a numerical rank or ordering of the threads that a thread scheduler can use to resolve simultaneous contention for processing resources . <p> In a typical implementation , any threads in the runnable state are represented in an ordered list of queues with one list entry , or queue , per priority level . This is demonstrated in Figure 19 . <p> Range of priority values . In @ @ @ @ @ @ @ @ @ @ receive scheduling preference over threads with lower priorities . The legal range for priority values tends to vary significantly between thread APIs , different contention scopes , and different scheduling policies . <p> Using the feature test macro . The feature test macro for scheduling priority is RWTHRHASPRIORITY . If this macro is not defined , attempts to query or set a priority attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for scheduling priorities and might allow you to get or set a scheduling priority attribute . <p> The macro RWTHRHASDUALPRIORITY indicates whether the current environment requires two separate priority values for threads with system contention scope : <p> One for resolving contention for thread-level synchronization objects within a process . <p> One for scheduling the thread relative to other threads in the system . <p> RWTHRHASDUALPRIORITY can be used to choose between use of the single priority attribute functions and the process-scope and system-scope priority functions . If this macro is defined , then : <p> The macro **28;2337;TOOLONG is defined . <p> The macro @ @ @ @ @ @ @ @ @ @ . The typedef RWPriority is the type for all priority values in the Threading package . The declaration of this typedef varies from one environment to the next , but is always based on one of the intrinsic integer types . <p> canGetPriority() - Indicates whether the scheduling priority attribute is supported in the current environment and whether getPriority() can currently return a legal value . <p> isPrioritySet() - Indicates whether the scheduling policy attribute value is the value that was previously set by a call to setPriority(RWPriority) . <p> getPriority() - Returns the default scheduling priority value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to setPriority(RWPriority) . If the current environment or circumstances do not support priority scheduling , then attempts to use this function result in exceptions . <p> canSetPriority() - Indicates whether the scheduling priority attribute is supported and can be set in the current environment . <p> setPriority(RWPriority) - Sets the scheduling priority attribute to the value passed as an argument . If the current environment does not support the scheduling priority @ @ @ @ @ @ @ @ @ @ range , then the function produces an exception . <p> resetPriority() - Restores the scheduling priority attribute to its default value . The default value can vary according to the current value of other attributes . <p> getMinPriority() - Returns the minimum priority value supported by the current contention scope and scheduling policy . <p> getMaxPriority() - Returns the maximum priority value supported by the current contention scope and scheduling policy . <p> Requirement for two priority values . Some platforms , such as Solaris , require the use of two separate priority values for threads with system contention scope ; <p> One sets the system-level scheduling priority or system-scope priority for the thread . <p> The other is a process-scope priority used to control access to any thread-level synchronization resources shared with other threads in the same process . <p> Requirement for a separate process-scope priority . You should only need to define a separate process-scope priority for a system-scope thread when : <p> You have used more than one priority value for your process-scope threads . <p> The possibility exists that your system-scope thread can deadlock as a @ @ @ @ @ @ @ @ @ @ thread has assumed an inappropriate default process-scope priority value . <p> Support for two priorities . To support this dual priority scheme , the RWThreadAttribute class includes two sets of functions that are specialized versions of the normal priority function listed above . These functions should only be required when defining attributes for threads that have system contention scope . <p> The first set defines a thread priority for use in resolving multithread contention for intra-process synchronization resources . These functions can be used interchangeably with the normal priority functions , as long as the thread attribute instance defines the contention scope as RWTHRPROCESSSCOPE or when the environment supports or requires dual-priorities for system-scope threads . <p> **28;2396;TOOLONG <p> **27;2426;TOOLONG <p> **25;2455;TOOLONG <p> **28;2482;TOOLONG <p> **25;2512;TOOLONG <p> **27;2539;TOOLONG <p> **28;2568;TOOLONG <p> **28;2598;TOOLONG <p> The second set of functions defines a thread priority for use in scheduling system-scope threads relative to other system-scope threads in the system . These functions can be used interchangeably with the normal priority functions , as long as the thread attribute instance defines the contention scope as RWTHRSYSTEMSCOPE : <p> **27;2628;TOOLONG <p> **26;2657;TOOLONG <p> getSystemScopePriority() <p> @ @ @ @ @ @ @ @ @ @ Changing the inheritance or scheduling policy attributes . Changing the inheritance or scheduling policy attributes , either directly or as the result of a change in contention scope , can cause a previous priority setting to be discarded and can affect the range of allowable priority values , in accordance with the following table : <p> Inheritance Policy <p> Scheduling Policy <p> Priority <p> Inherit <p> Inherited <p> Inherited <p> Explicit <p> Preemptive ( if available ) <p> Policy-DependentRange <p> FixedTime-Slicing ( if available ) <p> Policy-DependentRange <p> DynamicTime-Slicing ( if available ) <p> Policy-DependentRange <p> Availability of the process-scope priority attributes . The availability of the process-scope priority attributes might be affected by the current setting of the contention scope attribute , as shown in the next table . <p> Contention Scope <p> RequiresDual Priorities <p> Inheritance Policy <p> Scheduling Policy <p> Process-Scope Priority <p> Process Scope ( if available ) <p> N/A <p> Inherit <p> Inherited <p> Inherited <p> Explicit <p> Preemptive ( if available ) <p> Policy-Dependent Range <p> FixedTime-Slicing ( if available ) <p> Policy-Dependent Range <p> DynamicTime-Slicing ( if available ) <p> Policy-Dependent Range <p> @ @ @ @ @ @ @ @ @ @ <p> N/A <p> Not Available <p> Yes <p> Inherit <p> Inherited <p> Inherited <p> Explicit <p> N/A <p> System-Dependent Range <p> Availability of the system-scope priority attributes . The availability of the system-scope priority attributes might be affected by the current setting of the contention scope attribute , as shown in the next table . <p> Contention Scope <p> Inheritance Policy <p> Scheduling Policy <p> System-Scope Priority <p> Process Scope ( if available ) <p> N/A <p> N/A <p> Not Available <p> System-Scope ( if available ) <p> Inherit <p> Inherited <p> Inherited <p> Explicit <p> Preemptive ( if available ) <p> Policy-Dependent Range <p> FixedTime-Slicing ( if available ) <p> Policy-Dependent Range <p> DynamicTime-Slicing ( if available ) <p> Policy-Dependent Range <p> NOTE : The specific dependencies and validation requirements for the priority attributes are unique to each environment . <p> Inheriting a priority value . A priority value can be inherited from the creating thread if the inheritance policy attribute is defined as RWTHRINHERIT . If the inheritance attribute is RWTHREXPLICIT , the Threading package chooses a default value appropriate for the current settings and environment . Setting @ @ @ @ @ @ @ @ @ @ RWTHRINHERIT forces the inheritance policy attribute to be changed to RWTHREXPLICIT . <p> Using a priority value . The priority specified by an RWThreadAttribute can only be used at thread creation . To manipulate the priority value of an active thread , use the following RWThread and RWThreadSelf functions : <p> canGetPriority() <p> getPriority() <p> canSetPriority() <p> setPriority(RWPriority) <p> getMinPriority() <p> getMaxPriority() <p> **28;2800;TOOLONG <p> **25;2830;TOOLONG <p> **28;2857;TOOLONG <p> **25;2887;TOOLONG <p> **28;2914;TOOLONG <p> **28;2944;TOOLONG <p> **27;2974;TOOLONG <p> getSystemScopePriority() <p> **27;3003;TOOLONG <p> setSystemScopePriority() <p> **27;3032;TOOLONG <p> **27;3061;TOOLONG <p> Exceptions . In addition to throwing the same exceptions as their RWThreadAttribute counterparts , an RWTHRThreadNotActive exception is thrown should you attempt to query or set the priority on a threaded runnable that does not possess an active thread . <p> The time-slice quantum attribute is used to define the maximum amount of time that a thread is allowed to execute before forcibly preempting it to allow another thread to execute . A time-slice quantum is typically associated with a scheduling policy of RWTHRTIMESLICEDFIXED . <p> Using the feature test macro . The feature test macro for scheduling time-slice quantum is RWTHRHASTIMESLICEQUANTUM . @ @ @ @ @ @ @ @ @ @ or set the time-slice quantum attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for time-slice quantum and might allow you to get or set this attribute . A time-slice quantum is defined in terms of milliseconds using an unsigned long value . <p> Member functions . The RWThreadAttribute member functions that are used to manipulate the scheduling time-slice quantum include : <p> canGetTimeSliceQuantum() - Indicates whether the time-slice quantum is supported in the current environment and whether getTimeSliceQuantum() can currently return a legal value . <p> isTimeSliceQuantumSet() - Indicates whether the time-slice quantum value is the value that was previously set by a call to **28;3090;TOOLONG long ) . <p> getTimeSliceQuantum() - Returns the default time-slice quantum value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **28;3120;TOOLONG long ) . If the current environment or circumstances do not allow interrogation of the time-slice quantum , then attempts to use this function result in exceptions . <p> canSetTimeSliceQuantum() - Indicates whether the time-slice @ @ @ @ @ @ @ @ @ @ current environment . <p> **28;3150;TOOLONG long ) - Sets the time-slice quantum attribute to the value passed as an argument . If the current environment does not support the adjustments to the time-slice quantum or if the specified attribute value is outside the legal range , then the function produces an exception . <p> resetTimeSliceQuantum() - Restores the time-slice quantum attribute to its default value . The default value can vary according to the current value of other attributes , such as priority . <p> getMinTimeSliceQuantum() - Returns the minimum priority value supported by the current contention scope and scheduling policy . <p> getMaxTimeSliceQuantum() - Returns the maximum priority value supported by the current contention scope and scheduling policy . <p> Changing the inheritance or scheduling policy attributes . Adjustment of the time-slice quantum is not supported by many platforms and can be safely ignored because this attribute assumes an appropriate default value . Changing the inheritance or scheduling policy attributes , either directly or as the result of a change in contention scope , can cause a previous time-slice quantum setting to be discarded and can affect the availability @ @ @ @ @ @ @ @ @ @ shown in the next table . <p> Inheritance Policy <p> Scheduling Policy <p> Time-Slice Quantum <p> N/A <p> N/A <p> Not Available <p> Inherit <p> Inherited <p> Inherited ( if available ) <p> Explicit <p> Preemptive ( if available ) <p> Not Available <p> FixedTime-Slicing ( if available ) <p> Policy-DependentRange ( if available ) <p> DynamicTime-Slicing ( if available ) <p> Not Available <p> NOTE : The specific dependencies and validation requirements for the time-slice quantum attribute are unique to each environment , and can be found in the appropriate section of the Platform User 's Guide supplement . <p> Inheriting the time-slice quantum . The time-slice quantum value can be inherited from the creating thread if the inheritance policy attribute is defined as RWTHRINHERIT . If the inheritance attribute is RWTHREXPLICIT , the Threading package chooses a default policy appropriate for the current settings and environment . Setting the time-slice quantum attribute value when the current inheritance policy is RWTHRINHERIT forces the inheritance policy attribute to be changed to RWTHREXPLICIT . <p> Using the time-slice quantum . The time-slice quantum specified by an RWThreadAttribute can only be used @ @ @ @ @ @ @ @ @ @ an active thread , use the following RWThread and RWThreadSelf member functions : <p> canGetTimeSliceQuantum() <p> getTimeSliceQuantum() <p> canSetTimeSliceQuantum() <p> **28;3180;TOOLONG long ) <p> getMinTimeSliceQuantum() <p> getMaxTimeSliceQuantum() <p> Exceptions . In addition to throwing the same exceptions as their RWThreadAttribute counterparts , an RWTHRThreadNotActive exception is thrown if you attempt to query or set the time-slice quantum on a threaded runnable that does not possess an active thread . <p> In single-threaded processes , the size of the stack is usually limited only by the amount of free memory space because the stack can continue to grow until it runs into the memory space allocated for the heap . <p> In a multithreaded application , each thread 's stack must be limited because each thread has its own stack , and every thread stack must be allocated in the same address space . To allocate a stack , each thread must reserve some fixed-sized portion of the address space . The growth of these stacks is now limited by their allocation size and the presence of other thread stacks in the same address space . Stack allocation is demonstrated in @ @ @ @ @ @ @ @ @ @ a thread stack is usually left to the system , but some environments allow users to create and manage their own stack space . <p> If the system is given the responsibility for allocating and managing the stack , then you might also have the opportunity to choose whether to commit physical memory and pagefile space to the stack at the time of its creation or to commit memory on-demand as the stack grows . <p> To support each of these variations , the Threading package defines several attributes that can be used to select and define the desired stack allocation policy : <p> Thread Stack Attributes <p> Stack Allocation Policy <p> StackReserve Size <p> StackCommit Size <p> User Stack Addressand Size <p> System Allocated <p> Commit On Demand <p> X <p> Commit At Creation <p> X <p> Mixed <p> X <p> X <p> User Allocated <p> X <p> Issues to consider when using stack attributes : <p> Unless the user stack attributes are set , the RWThreadAttribute class always assumes that the underlying system has responsibility for allocating and managing the stack . <p> Use of the stack attributes @ @ @ @ @ @ @ @ @ @ most situations because they usually assume reasonable default values . <p> Consider manipulating these attributes if you have threads that make very large stack allocations , perhaps as the result of automatic array allocations . <p> If you decide that you want to define the stack size , either for a system-managed or user-managed stack , remember to take into account the additional stack space that might required by code executing in other libraries . <p> Some run-time environments place demands on a thread 's stack , and some dynamic linker-loaders require use of a thread 's stack when locating and attaching to library code or data . <p> Stack overruns in a multithreaded environment can be quite difficult to detect and debug , so you should use care in limiting your stack sizes . You are generally better off if you can make your stacks bigger instead of smaller . <p> Some of the stack attributes mentioned here are mutually exclusive . If you set the stack reserve or commit size , any previous definitions for a user-managed stack are discarded . If the underlying environment does not support @ @ @ @ @ @ @ @ @ @ exclusion between the reserve size and commit size attributes . <p> The default choice for stack management policy is to let the system allocate and manage the stack , but the final choice between system-managed and user-managed stack allocation is determined by which attributes were most recently set . If the user-stack attributes were the last stack attributes changed prior to thread creation , then user-management of the stack is assumed . <p> On most systems , reserving space for the stack only involves reserving virtual memory locations-memory and pagefile resources are not allocated until the memory is committed . No harm is caused by reserving a large area if it might be needed . <p> The feature test macro for stack reserve size is RWTHRHASSTACKRESERVESIZE . If this macro is not defined , attempts to query or set the reserve size attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for stack reserve size and might allow you to get or set this attribute . <p> Stack reserve size is defined in terms of some number @ @ @ @ @ @ @ @ @ @ be rounded to some environment-specific granularity ( such as page size ) . <p> The RWThreadAttribute member functions that manipulate the stack reserve size include : <p> canGetStackReserveSize() - Indicates whether the stack reserve size is supported in the current environment and whether getStackReserveSize() can currently return a legal value . <p> isStackReserveSizeSet() - Indicates whether the reserve size value is the value that was previously set by a call to **26;3210;TOOLONG . <p> getStackReserveSize() - Returns the default reserve size value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **26;3238;TOOLONG . If the current environment or circumstances do not allow interrogation of the stack reserve size , then attempts to use this function result in exceptions . <p> canSetStackReserveSize() - Indicates whether the stack reserve size attribute is supported and can be set in the current environment . <p> **26;3266;TOOLONG - Sets the reserve size attribute to the value passed as an argument . If the current environment does not support this attribute or if the specified attribute value is outside the legal range , @ @ @ @ @ @ @ @ @ @ Restores the reserve size attribute to its default value . The default value and its source vary by environment . <p> getMinStackSize() - Returns the minimum amount of stack space required to implement a thread that calls a null routine . The Threading package also ensures that a system-managed stack is of sufficient size by adding this value to any value defined using **26;3294;TOOLONG . <p> If the current environment or circumstances do not allow interrogation of the minimum stack size , then attempts to use this function result in exceptions . The availability of this function can be inferred by testing the result returned by either canGetStackReserveSize() or canGetUserStack() . <p> An attempt to read the default value for this attribute produces an exception if the user stack attributes have been set , unless the stack reserve or commit size is set or the user stack attributes are reset . In those cases , the default value of system-managed stack attributes are again available . <p> Systems vary in several ways : <p> You might not be allowed to change the amount of space reserved for a stack-sometimes the @ @ @ @ @ @ @ @ @ @ defines a thread 's stack reserve size , a method for determining this value might not be available . <p> You might be allowed to choose the stack reserve size independently of stack commit size , which allows partial commitment to memory , or you might be allowed to specify only one or the other attribute ( the stack is either reserved and can only be committed on demand , or the stack must be entirely committed , if at all ) . <p> The specific attribute availability and validation criteria are unique to each environment and are documented in the appropriate chapters in the Threads.h++ Platform User 's Guide . <p> The feature test macro for stack commit size is RWTHRHASSTACKCOMMITSIZE . If this macro is not defined , attempts to query or set the commit size attribute always produce an exception . If it is defined , then the current environment has some level of support or recognition for stack commit size and allows you to get or set this attribute . <p> Stack commit size is defined in terms of some number of bytes using sizet values @ @ @ @ @ @ @ @ @ @ granularity ( such as page size ) . <p> The RWThreadAttribute member functions that manipulate the stack commit size include : <p> canGetStackCommitSize() - Indicates whether the stack commit size is supported in the current environment and whether getStackCommitSize() can currently return a legal value . <p> isStackCommitSizeSet() - Indicates whether the commit size value is the value that was previously set by a call to **25;3322;TOOLONG . <p> getStackCommitSize() - Returns the default commit size value if the attribute value has not yet been defined . Otherwise , it returns the value specified in the last call to **25;3349;TOOLONG . If the current environment or circumstances do not allow interrogation of the time-slice quantum , then attempts to use this function result in exceptions . <p> canSetStackCommitSize() - Indicates whether the stack commit size attribute is supported and can be set in the current environment . <p> **25;3376;TOOLONG - Sets the commit size attribute to the value passed as an argument . If the current environment does not support this attribute or if the specified attribute value is outside the legal range , then the function produces an exception @ @ @ @ @ @ @ @ @ @ its default value . The default value and its source vary by environment . <p> An attempt to read the default value for this attribute produces an exception if the user stack attributes have been set , unless the stack reserve or commit size is set or the user stack attributes are reset . In those cases , the default value of system-managed stack attributes are again available . <p> Systems vary in several ways : <p> You might not be allowed to specify the amount of memory to commit to the stack . <p> When inheritance defines a thread 's stack reserve size , a method for determining this value might not be available . <p> The specific attribute availability and validation criteria are unique to each environment and are documented in the appropriate section of the Threads.h++ Platform User 's Guide . <p> The macro **30;3403;TOOLONG indicates whether the current environment allows the user to specify that some amount of the memory space allocated for thread stack is to be committed to physical memory at creation . <p> If **30;3435;TOOLONG is defined , then the macro RWTHRHASSTACKCOMMITSIZE is @ @ @ @ @ @ @ @ @ @ not , then the commit size also specifies the amount of memory to reserve for the stack . <p> If you want to allocate and manage a thread 's stack , the relevant attributes include the user stack address and user stack size . <p> The user stack address defines the lowest , or bottom address of the address space reserved , allocated , and managed by the user . <p> The user stack address is defined as a void* value . <p> The user stack size defines the memory space size of the user-allocated stack . It locates the top of the address space where the stack bottom is typically located ( in those environments where stacks grow downward in memory ) . <p> The user stack size is defined in terms of some number of bytes using sizet values . <p> Using the feature test macro . The feature test macro for user stack support is RWTHRHASUSERSTACK . If this macro is not defined , attempts to query or set the user stack attributes always produce an exception . If it is defined , then the current environment @ @ @ @ @ @ @ @ @ @ get or set these attributes . <p> Member functions . The RWThreadAttribute member functions that define and manipulate the user stack attributes include : <p> canGetUserStack() - Indicates whether the user stack attributes are supported in the current environment and whether getUserStackAddress() or getUserStackSize() can currently return a legal value . Default values for user stack attributes do not exist , so this function returns TRUE only if the attributes have been set . <p> isUserStackSet() - Indicates whether the user stack attributes have been previously set by a call to setUserStack ( void* , sizet ) . <p> getUserStackAddress() - Returns the address value specified in the last call to setUserStack ( void* , sizet ) . If the current environment or circumstances do not allow interrogation of the user stack address , then attempts to use this function result in exceptions . <p> getUserStack() - Returns the stack size value specified in the last call to setUserStack ( void* , sizet ) . If the current environment or circumstances do not allow interrogation of the user stack size , then attempts to use this function result in exceptions @ @ @ @ @ @ @ @ @ @ is supported and can be set in the current environment . <p> setUserStack ( void* , sizet ) - Sets the user stack address and size to the values passed as arguments . If the current environment does not support these attributes or if the specified attribute values are outside their legal range , then the function produces an exception . <p> getMinStackSize() - Returns the minimum amount of stack space required to implement a thread that calls a null routine . The Threading package also insures that a system-managed stack is of sufficient size by adding this value to any value defined using **26;3499;TOOLONG . <p> If the current environment or circumstances do not allow interrogation of the minimum stack size , then attempts to use this function result in exceptions . The availability of this function can be inferred by testing the result returned by either canGetStackReserveSize() or canGetUserStack() . <p> Exceptions . Any attempt to read the default values for these attributes produces an RWTHRInternalError exception . These attributes have no default values . <p> For additional information on user stack management support , see the appropriate @ @ @ @ @ @ @ @ @ @ Every threaded runnable instance contains a thread attribute instance that defines the thread attributes to use when creating a new thread during a call to start() . The Threading package allows you to change or query the thread attribute instances associated with any threaded runnable . <p> RWThreadAttribute objects can be supplied to and shared between any number of threaded runnable objects . Changes made to the values of a shared thread attribute instance can be seen by all runnables that have been given a handle to that attribute instance . <p> The thread attribute instance referenced by each threaded runnable is only used or evaluated at the time the thread is created . A threaded runnable makes a local copy of its current thread attribute instance each time start() is called . This prevents the attribute values that were present when a thread was created from being lost as a result of future changes in a runnable 's thread attribute instance or the attribute 's values . <p> Changing a runnable 's thread attribute instance or values of that attribute instance does not affect the active thread , if @ @ @ @ @ @ @ @ @ @ can only affect the next thread created as result of a call to start() . <p> RWThreadAttribute instances can be supplied to threaded runnable objects if the runnables are constructed using the appropriate static make() functions . If a thread attribute instance is not specified when a threaded runnable is constructed , then that runnable is initialized with its own RWThreadAttribute instance initialized with default values . <p> The following list identifies the make() functions for each threaded runnable class that accepts an RWThreadAttribute instance : <p> static RWServerPoolmake ( const RWThreadAttribute&amp; , sizet ) Constructs an RWServerPool instance whose main thread is created using the specified thread attribute instance and whose pool threads are created using default thread attributes . <p> static RWServerPoolmake ( sizet , const RWThreadAttribute&amp; ) Constructs an RWServerPool instance whose main thread is created with default thread attributes and whose pool threads are created using the specified thread attribute instance . <p> static RWServerPoolmake ( const RWThreadAttribute&amp; , sizet , const RWThreadAttribute&amp; ) Constructs an RWServerPool instance whose main thread is created using the first thread attribute instance and whose pool threads are created using @ @ @ @ @ @ @ @ @ @ RWThreadAttribute&amp; ) Replace the threaded runnable 's current thread attribute object with another . Changing a threaded runnable 's attribute object after the runnable has already been started does not affect its current thread-it can only affect the thread created the next time the runnable is started . <p> **26;3527;TOOLONG RWThreadAttribute&amp; ) Change the thread attribute instance used to initialize new runnable server objects as they are created in the thread pool . Changing the pool thread attribute after the server has started does not affect new threads started by the pool server until the server pool instance is restarted . <p> getAttribute()Retrieves a handle to the thread attribute instance , if any , specified during the threaded runnable 's construction or the instance specified in the last call to setAttribute() . If no attribute has ever been specified , this function returns the default attribute instance created when the runnable was constructed . <p> Because threaded runnables make a local copy of the thread attribute instance during thread creation , the instance returned by this function might not have the same attribute values as were used to create the @ @ @ @ @ @ @ @ @ @ retrieve a copy of the thread attribute instance that actually created the current active thread . <p> getActiveAttribute()Get a handle to a copy of the actual thread attribute instance used to create the runnable 's current active thread . If the threaded runnable has not yet been started , this function returns a copy of a default attribute instance . Once start() has been called , this function returns a copy of the local attribute instance that was saved when the thread was created . <p> **27;3555;TOOLONG a handle to the pool thread attribute instance , if any , specified during server pool construction or the instance specified in the last call to setPoolAttribute() . If no attribute has ever been specified , this function returns the default attribute instance created when the runnable was constructed . <p> Because a server pool makes a local copy of the pool thread attribute instance during start-up , this instance might not have the same attribute values as were used to create the threads in the server pool . Use the getActivePoolAttribute() function to retrieve a copy of the thread attribute instance that @ @ @ @ @ @ @ @ @ @ to a copy of the actual thread attribute instance that created the current server pool threads . If the server pool has not yet been started , this function returns a copy of a default attribute instance . Once start() has been called , this function returns a copy of the attribute instance that was saved when the server was started . 
@@75677634 @4377634/ <h> API Gateway - Simplified Security and Management <p> The Akana API Gateway solution streamlines management , deployment , development and operation of APIs , enhancing security and regulatory compliance through authentication , authorization and audit capabilities . It provides central definition and management of security , routing , orchestration , mediation , auditing , threat protection , and other operational governance policies across multiple instances . The Gateway enables enterprises to standardize API and service delivery with high security , performance and availability . <p> Provide a content firewall , protecting against malicious content including protection against viruses in attachments and validation of message content XML and JSON data structure , form and query parameters . <p> Analytics Dashboards and out-of-the-box reports provide visibility into the performance of APIs and services from different perspectives , including department , partner , application contract , API/service or operation <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75677635 @4377635/ <h> Hard Work is the Secret to Success <p> Research now shows that the lack of natural talent is irrelevant to great success . The secret ? Painful and demanding practice and hard work <p> Even when you are talking about people like Tiger Woods and Warren Buffett . I think this is really hard for people to accept . Maybe it 's hard to accept because then we 'd have to accept that we are n't billionaires or star football players because we did n't work hard enough at it . <p> I 'd bet that success is greatly tied to interest . It 's hard to work really hard at something you are n't interested in . But if you like writing code , you enjoy solving that puzzle , then you do it a lot and you get good at it . Once you are good at it , people give you kudos , and maybe even pay you , and that motivation makes you feel good , and so you do it some more , and you get better at it . Sooner or later @ @ @ @ @ @ @ @ @ @ " practicing " hard for a long time . <p> ( So that 's why , if you are n't good at writing blog posts or comments , you should keep at it ! ) <p> The article also points out to be good you not only have to practice , but you have to get lots of feedback and you have to incorporate that feedback into your practice . <p> So that 's why the open source community writes such good code and produces good hackers . They write lots of code ( i.e. practice a lot ) and get lots of feedback . 
@@75677638 @4377638/ <h> 9.2 Error Categories <p> In the Essential Tools Module model , errors are divided into two broad categories : internal and external . ( A third category also exists : stream buffer allocation errors . The Rogue Wave public interface does include a class to handle these errors , although they are far less common and are not discussed in detail here . ) <p> Internal errors , which are further classified as either recoverable or non-recoverable , are due to errors in the internal logic of the program . As you might expect , they can be difficult to recover from and , indeed , the common default response is to abort the program . External errors are due to events beyond the scope of the program . Any non-trivial program should be prepared to recover from an external error . <p> Internal errors are due to faulty logic or coding in the program . Common types of internal errors include : <p> Bounds errors <p> Inserting a null pointer into a collection <p> Attempting to use a bad date <p> All these errors should be preventable @ @ @ @ @ @ @ @ @ @ of indices for an array , so you can probably avoid a bounds error . You would correct your program 's use of a bad date as an obvious logic error . <p> Internal errors can be further classified according to the cost of error detection , and whether or not the error will be detected at run time . The two categories are : <p> Non-recoverable internal errors share the following distinguishing characteristics . They are : <p> Easily predicted in advance <p> Encountered at relatively low levels <p> Costly to detect <p> Detected only in the debug version of the library <p> Non-recoverable internal errors by definition have no recovery mechanism . Examples of these errors include bounds errors and inserting a null pointer into a collection . <p> A library defines some errors unrecoverable because detecting errors takes time . For performance reasons , a library demands a minimal level of accuracy and rejects any part of your program that falls short . Errors are non-recoverable in the sense that the production version of the library has no mechanism for detecting such errors . This means there @ @ @ @ @ @ @ @ @ @ errors are non-recoverable because the cost of checking that an index is in range can well exceed the cost of the array access itself . If a program does a lot of array accesses , checking every one may result in a slow program . To avoid this , the library may require you to always use a valid index . Because a minimum level of accuracy is demanded , non-recoverable errors are simple in concept and relatively easy to avoid . <p> You can best discover and eliminate non-recoverable errors by compiling and linking your application with the debug version of the library . See Section 9.4 in this chapter for details . The debug version includes extra checks designed to uncover coding errors . Some of these checks may take extra time , or even cause debug messages to be printed . For this reason , you will want to compile and link with the production version for an efficient final product . If the debug version of the library discovers an error , it typically aborts the program . <p> Recoverable internal errors are similar to their @ @ @ @ @ @ @ @ @ @ at low levels . <p> They differ in that they are <p> not costly to detect <p> detected in both the debug and the production versions of the library <p> A bounds error in a linked list or an attempt to use an invalid date are both examples of recoverable internal errors . The library 's response to these errors is to throw an exception inheriting from RWInternalErr , using the macro RWTHROW . <p> The production version of the library can check for recoverable internal errors because the cost is relatively low . For example , to find a bounds error in a linked list , the cost of walking the list far exceeds the cost of detecting whether the index is in bounds . Hence , you can afford to check for a bounds error on every access . <p> If an error is discovered , the library throws an exception inheriting from RWInternalErr , as we have mentioned . Following is an example : <p> Throwing an exception gives you the opportunity to catch and possibly recover the exception . However , because the internal logic of @ @ @ @ @ @ @ @ @ @ save the document you are working on , and abort the program . <p> External errors are due to events beyond the scope of the program . As we mentioned in the introduction , any non-trivial program should be prepared to recover from an external error . In general , external errors are : <p> Not easily predicted in advance <p> Encountered at more abstract levels <p> Not costly to detect <p> Detected in both the production and the debug versions of the library <p> Examples of external errors include : an attempt to set a bad date , such as 31 June 1992 ; an attempt to invert a singular matrix ; a stream write error ; being out of memory . The Essential Tools Module responds by throwing an exception inheriting from RWExternalErr , or providing a test for object validity . <p> External errors may be run time errors . In an object-oriented environment , run time errors frequently result from an attempt to set an object into an invalid state , perhaps as a result of invalid user input . The example given above , initializing @ @ @ @ @ @ @ @ @ @ , is an external run time error . <p> External errors often take the form of exceptions thrown by the operating system . The Essential Tools Module takes responsibility for detecting these exceptions and recovering the resources it has acquired ; it will close files and restore heap memory . As the user , however , you are responsible for all resources acquired by code external to the Essential Tools Module library during these kinds of exceptions . Generally , the Essential Tools Module assumes that these exceptions will not be thrown during memory-related C library calls such as memcpy . The Essential Tools Module make every effort to detect throws which occur during operations on the Essential Tools Module objects or user-defined objects . <p> In theory , the Essential Tools Module 's response to an external error is to throw an exception , or to provide a test for object validity . It should never abort the program . In practice , however , some compilers do not handle exceptions , so the Essential Tools Module provides an opportunity to recover in an error handler , or to @ @ @ @ @ @ @ @ @ @ of using the isValid function to validate user input : 50235 @qwx670235 
@@75677639 @4377639/ <p> We remind you that in Rogue Wave Views all symbols whose names begin with the characters " ilv " are reserved for internal use . <p> 3 . Define how this class will be persistent and register this class with Rogue Wave Views . <p> Using a very simple example " the storage of two values " the following section explains how to create a named property that you can associate with graphic objects . You can , however , build named properties with member functions to handle more elaborate data members , or have named properties that store pointers to existing classes . Using named properties , you can link application data with a high level of complexity to light graphic objects , with minimum coding and without altering the API of your application classes . <p> Example : Creating a Named Property <p> To illustrate , we are going to create a named property that holds both an integer and a character string and make it easily accessible and persistent . <p> The named property that we are going to create must be a subclass of @ @ @ @ @ @ @ @ @ @ string . Its complete header file is given below : <p> #include **30;3613;TOOLONG <p> class MyProperty <p> : public IlvNamedProperty <p> <p> public : <p> MyProperty ( int integer , <p> char* string ) ; <p> virtual MyProperty() ; <p> int getInteger() const return integer ; <p> void setInteger ( int integer ) integer = integer ; <p> const char* getString() const return string ; <p> void setString ( const char* string ) ; <p> static IlSymbol* GetSymbol() ; <p> DeclarePropertyInfo() ; <p> **41;3645;TOOLONG ; <p> private : <p> int integer ; <p> char* string ; <p> static IlSymbol* Symbol ; <p> ; <p> In addition to the two data members integer and string ( and their accessors ) , we will focus on the Symbol static data member and on the two macro calls that appear in the declaration part of the class , namely DeclarePropertyInfo and **29;3688;TOOLONG . <p> Note that the destructor of the class is virtual like the one of the base class IlvNamedProperty . <p> Defining the Symbol for Accessing the Named Property <p> First we are going to define the property symbol that will @ @ @ @ @ @ @ @ @ @ to define this symbol is to make it a static data member of your property class , Symbol , and provide it with a public accessor , GetSymbol . By doing this , any application will be able to retrieve an instance of MyProperty without having to know which symbol is used to associate it with an object . <p> Therefore , the public and static accessor GetSymbol is defined to return the appropriate IlSymbol and create it if necessary . <p> In the code below , an extract of the implementation file , we define both the accessor to the property symbol and the static data member , which we initialize to 0 . Note that the symbol is created the first time it is queried in MyProperty : : GetSymbol . <p> IlSymbol* <p> MyProperty : : GetSymbol() <p> <p> if ( ! Symbol ) <p> Symbol = IlGetSymbol ( " MyPropertySymbol " ) ; <p> return Symbol ; <p> <p> IlSymbol* MyProperty : : Symbol = 0 ; <p> Defining the Constructor for the Named Property <p> Let 's now examine the constructor and the destructor . @ @ @ @ @ @ @ @ @ @ the parent class , IlvNamedProperty , and initialize our data members : <p> MyProperty : : MyProperty ( int integer , <p> char* string ) <p> : **26;3719;TOOLONG ( ) ) , <p> integer(integer) , <p> string(0) <p> <p> setString(string) ; <p> <p> MyProperty : : MyProperty() <p> <p> if ( string ) <p> delete string ; <p> <p> The first time a property of the MyProperty type is created , the static member function GetSymbol is called to set the static data member Symbol to a valid value . <p> The string parameter is copied by the setString member function that will check whether the data member string is valid . This is why we initialize this data member to 0 in the initializers of the constructor . This parameter is destroyed in the destructor , if it was valid . <p> Defining the setString Member Function <p> Below is the definition of the setString member function that copies and stores the string : <p> void <p> MyProperty : : setString ( const char* string ) <p> <p> if ( string ) <p> delete string ; <p> string = @ @ @ @ @ @ @ @ @ @ ) <p> : 0 ; <p> <p> This code is quite simple . If a valid string " a non-null string " was stored , it is destroyed . If the parameter is valid " non-null " a copy of this string is made and stored . If the parameter is not valid , the data member is simply reset to 0 . <p> At this stage , our class can store and retrieve both an integer and a character-string value . <p> Defining the Persistence and Copy Constructors <p> For our named property to be complete , we have to add the class-level information and persistence-related member functions . The easiest way to do this is to use the following two macros in the body of the class declaration : <p> DeclarePropertyInfo declares the class information data members for the MyProperty class . These members are used to retrieve information , such as the class name and its hierarchy . It also declares the member functions that are required to implement persistence for this class . <p> **29;3747;TOOLONG declares the constructors required for persistence and copy . <p> These @ @ @ @ @ @ @ @ @ @ functionality to your class . <p> Once the macros have been declared , all we have to do to add copy and persistence features to our class is to define a copy constructor and a constructor that take an IlvInputFile reference as its parameter : <p> MyProperty : : MyProperty ( const MyProperty&amp; source ) <p> : **26;3778;TOOLONG ( ) ) , <p> integer ( source. integer ) , <p> string(0) <p> <p> setString ( source. string ) ; <p> <p> MyProperty : : **28;3806;TOOLONG i , IlSymbol* s ) <p> : **26;3836;TOOLONG ( ) ) , <p> integer(0) , <p> string(0) <p> <p> // ' s ' should be equal to GetSymbol() <p> i.getStream() &gt;&gt; integer &gt;&gt; IlvQuotedString() ; <p> **25;3864;TOOLONG ( ) . Buffer ) ; <p> <p> The first constructor initializes a new instance of MyProperty with a copy of its source parameter . <p> The second constructor reads the provided input stream to initialize its instance with what is read . <p> Defining the write Member Function <p> Now that we are able to read a new instance of the class , we can save it @ @ @ @ @ @ @ @ @ @ write member function , which is implicitly declared by the macro DeclarePropertyInfo . <p> void <p> MyProperty : : write ( IlvOutputFile&amp; o ) const <p> <p> o.getStream() &lt;&lt; integer &lt;&lt; IlvSpc() &lt;&lt; IlvQuotedString(string) ; <p> <p> The saving order must be the same as the reading order . <p> Note that you may define a named property that does not have any additional information to save . In this case , you would use the DeclarePropertyInfoRO macro instead of DeclarePropertyInfo in the class declaration and drop the write member function that would be useless . <p> Providing an Entry Point to the Read and Copy Constructors <p> To provide Rogue Wave Views with an entry point to the read and copy constructors , you must add another macro to the implementation file , outside the body of any function , as follows : <p> **42;3891;TOOLONG <p> Calling this macro actually creates a read static member function that invokes the read constructor . It also defines a copy member function that calls the copy constructor . <p> Registering the Class <p> The final step to have our named property up @ @ @ @ @ @ @ @ @ @ class with Rogue Wave Views as follows : 
@@75677640 @4377640/ <h> Rogue Wave Software leadership team <h> Brian Pierce <p> Chief Executive Officer <p> Brian Pierce is a technology industry veteran who has led and repeatedly built rapidly scaling businesses through dynamic , hands-on management . An experienced software executive with more than 20 years of technical , sales and operational experience , Brian has served as CEO since 2008 . He leads the management team as the company continues to aggressively expand its product portfolio , revenue and market position , both organically and through acquisition . <p> Prior to Rogue Wave , Brian served as a Senior Vice President at Infor Global Solutions where he had responsibility for five independently operating business units with over $75M in revenue . He also served as President and Chief Operating Officer of TriSyn Group , an enterprise-class applications software company focused on the top 100 banks in the U.S. At TIBCO , Brian was Senior Vice President of Customer Satisfaction and Support , where he implemented a world-class global professional service and 24x7 support organization for a rapidly growing business . He was Vice President of Field Operations at InConcert @ @ @ @ @ @ @ @ @ @ TIBCO in 1999 . Brian started his career at Xerox where he spent 10 years in various technical , sales and management positions . <p> Brian 's passion is working with high performance teams to deliver maximum value for customers , employees and stakeholders . <h> Kevin Hooper <p> Chief Revenue Officer <p> Kevin Hooper leads revenue generation at Rogue Wave , focusing on developing and executing sales strategies , as well as aligning and optimizing the customer experience to deliver revenue . Kevin started his career designing nuclear power plant control rooms and coding some of the first interfaces to access databases over ARPANET in the early 1990s . Kevin brings experience with large sales organizations , including direct , channel , and strategic partnerships at Oracle , IBM , HP and NEC . Always focused on entrepreneurial business lines , new customer acquisition , and channels , Kevin brings his passion for solving customer problems with technology . Kevin holds a BSc in Mathematics and Statistics and a Masters in Industrial Engineering . <h> Ian McLeod <p> Chief Product Officer <p> With a passion for the software tools @ @ @ @ @ @ @ @ @ @ support , and product management teams , overseeing strategy , development , packaging and go-to-market for our product portfolio . Ian has over 20 years experience in product management and engineering leadership roles , most recently as EVP and Chief Product Officer for SmartBear Software , where he led the product management , product development , and support teams and was part of the executive team that drove five-fold revenue growth in five years . Earlier in his career Ian served in senior management roles at PHT Corporation , Segue Software ( acquired by Borland ) , Rational Software ( acquired by IBM ) and GTE Internetworking . Ian started his career at GE as part of the Edison Engineering Program , where he earned his master 's degree from Rensselaer Polytechnic Institute , after earning a bachelor 's degree at Lehigh University . <h> Rod Cope <p> Chief Technology Officer <p> Rod Cope drives Rogue Wave technology vision and heads the product management organization . Rod has over 20 years of experience in software development spanning a number of industries including telecommunications , aerospace , healthcare , and manufacturing @ @ @ @ @ @ @ @ @ @ a profitable venture-backed company , and joined Rogue Wave as CTO following the acquisition . At OpenLogic , Rod designed and architected the SaaS-based scanning technology , seeing the enterprise need to embrace and govern open source as enterprises continue to adopt OSS in large scale . Prior to OpenLogic , he provided technical leadership on significant projects for companies such as IBM , Anthem , and Ericsson . Rod holds both Bachelor 's and Master 's degrees in Software Engineering from the University of Louisville . <h> Christine Bottagaro <p> Chief Marketing Officer <p> Christine Bottagaro leads the marketing organization at Rogue Wave , driving messaging and positioning , go-to-market campaigns , and sales enablement . Christine has 20 years of experience in developing marketing strategies and leading global growth for technology companies . Christine previously held senior marketing roles at Sybase , SAP , and Rally Software . In those organizations , she led comprehensive marketing initiatives for enterprise software spanning product marketing , corporate marketing , integrated go-to-market campaigns , customer reference programs , sales enablement , content direction , through building and managing high-performing teams . @ @ @ @ @ @ @ @ @ @ Colorado , and an MBA from the University of Colorado Leeds School of Business . <h> Peter Bennfors <p> Chief Financial Officer <p> Peter runs our finance and accounting teams , including overseeing financial planning , banking , reporting and analysis , tax , compliance and overall corporate financing efforts . Prior to joining Rogue Wave , Peter held senior finance roles with Misys , Asset Control and most recently , SRSsoft . In addition to running corporate finance , Peter has also managed sales operations , human resources , audit and IT aspects . Peters strong track record of enabling organizational success is through building excellent teams and practices . Peter received a BSc in Accounting and Financial Management from the University of Buckingham , England , and is a Chartered Accountant , Institute of Chartered Accountants in England and Wales . 
@@75677641 @4377641/ <p> The terms Web Services and SOA are often used interchangeably , but the reality is that they 're quite different . Let 's begin by describing what SOA is n't , and well leave that to Joe McKendrick and Dave Linthicum : <p> An effective , functioning service-oriented architecture requires governance , and the ability to share services across multiple business units and enterprises . Its easy to build Web services . You could build 10 of them in an afternoon . But , then you end up with a JBOWS architecture ( Just a Bunch of Web Services ) , which will grow into a different sort of SOA ; a Spaghetti-Oriented Architecture . Joe McKendrick , analyst and editor with Webservices.org <p> SOA is a true systemic change in the way you approach enterprise architecture . That 's where the value is , and not just Web service-enabling your systems , or purchasing and implementing products with the " SOA hype label " bound to them . Dave Linthicum , well known author , professor and writer <p> So what is Mainframe SOA , and how can you achieve @ @ @ @ @ @ @ @ @ @ Architecture is an architectural methodology for the loose coupling and management of services . The emphasis in SOA is on the " A " . SOA uses loosely coupled , interoperable and composeable services . These services have well-defined interfaces as well as QoS attributes ( or policies ) on how these interfaces can be used by Service Consumers . <p> SOA is concerned with manageability , reliability , security and change management . Collectively these terms are known as " Governance " . In order to bring SOA to a mainframe environment , companies must apply Governance to any implementation of Web Services . <p> Its essential that your SOA solution considers the following categories . Failure to do so can lead to an ungoverned mess , or " Just a Bunch Of Web Services " <p> SOAP &amp; XML Capability : SOAP and XML capability ( commonly called " web services " ) is the foundation of SOA . Many vendors only offer mainframe web services , ignoring the other components of SOA . <p> Security : security is essential when integrating mainframe applications , especially those dealing @ @ @ @ @ @ @ @ @ @ Services security is to use WS-Security , which is the widely accepted standard for securing services . <p> Policy Management : policy management is the heart of SOA governance . A policy can define how a service can be used , who can use it , what security is required and much , much more . Policy management based on WS-Policy standards is essential . <p> Registry : the Holy Grail of SOA is reuse . The key to reuse is discovery of services . This is accomplished by publishing services in a Registry . A registry provides for reuse and discovery and is an essential ingredient in SOA governance . <p> Monitoring , Logging &amp; Audit Controls : effective Governance requires measurement , for without measurement you will be unable to judge whether your services are meeting service level agreements . Monitoring , logging and audit capability are essential building blocks of Governance . <p> Development Tools : it is impossible to develop services without the use of a comprehensive development tool . The tool needs to be powerful and it must allow management of your SOA . It @ @ @ @ @ @ @ @ @ @ steep learning curve requiring extensive training . Finally , it should not consume enormous resources on a developers work station ( ideally it should be " thin client " ) . <p> Support for Architectural Standards : a viable SOA must be adaptable to a wide range of architectural standards , particularly yours . Features such as flexible web service development ( bottom-up , top-down or meet-in-the middle ) , configurable dictionary , customizable access and environments , etc. are all hallmarks of an adaptable SOA . The bottom line is that your solution should fit the way you do things , not the other way around . <p> Change and Release Management : an often overlooked aspect of service development is the " service lifecycle " . Integrated change and release management is essential to allow you to effectively manage change in your environment . Ideally your SOA solution should integrate into your existing change management procedures , and should provide you with impact analysis when a service is changed . <p> Workflow Management : orchestration is perhaps the most misunderstood aspect of service development . Some people consider @ @ @ @ @ @ @ @ @ @ conversation , requires a proprietary orchestration tool to make it work . In fact , a better approach is to use a tool that is smart enough to understand a " business use case " , and to publish that as an atomic service , without the need for proprietary orchestration to " glue together " the screen transitions . It is services themselves that need to be orchestrated , and that orchestration should be performed using industry standard techniques . The only acceptable technique for orchestration is to compose services using " Business Process Execution Language ( BPEL ) . <p> More than ten years after the predicted demise of the mainframe , the platform is anything but dead . The bulk of the Fortune 1000 still run the majority of their critical systems on the mainframe , and these companies do so because the mainframe is reliable , scalable and efficient the average mainframe application offers considerably lower TCO than an equivalent distributed application , and does so at lower risk . <p> The challenge facing corporate IT departments today is how to leverage exiting investments in mainframe @ @ @ @ @ @ @ @ @ @ in enterprise wide SOA . Most importantly , the mainframe must participate in SOA without compromising its advantages in performance , reliability or cost effectiveness . To truly leverage the mainframe , it must become a first class participant in an enterprise SOA . <p> SOLA is the markets most complete mainframe SOA solution . SOLA is the fastest , most reliable , most efficient and most economical mainframe SOA enablement platform . It is the only mainframe SOA product that 's used in high volume ( 10,000,000+ transactions per day ) mission critical applications by some of the best known firms on the Fortune 500 . <p> There are several vendors in the space that offer mainframe web services coupled with one or more components of mainframe SOA . IBMs CICS TS v3.x also provides SOAP and XML capability upon which a solution can be built . <p> Regardless of which option you chose , if you do not buy a complete SOA solution , you will be faced with the daunting task of integrating several components to create a viable mainframe SOA . As mainframe SOA is relatively new @ @ @ @ @ @ @ @ @ @ SOLA is the only product in the space that offers a complete mainframe SOA solution out of the box . SOLA provides proven , quick , efficient and cost effective application integration by publishing legacy applications as Web Services and providing every single component of a viable mainframe SOA . <p> As important as the essential components of enterprise SOA are , they are a single dimension of a more complex issue . SOLA was designed from the ground up to address the entire spectrum of mainframe SOA issues . <p> Solid Foundation : building a successful mainframe SOA must start with a solid foundation . The 9 essential components of enterprise SOA make for a good beginning , but SOLA goes far beyond . <p> Human Assets : what good is leveraging technology assets if you ignore human assets ? SOLA tasks the right people with the right jobs . <p> Training , development and support costs can far exceed the cost of the solution itself <p> Scalability and Adaptability : a good solution should be flexible ; it should be able to adapt to just about anyones enterprise @ @ @ @ @ @ @ @ @ @ unhindered growth . SOLA is standards-based and built for the enterprise . As its run time is entirely mainframe based , it inherits the mainframes legendary scalability and fault tolerance . <p> Streamlined Infrastructure : you should n't have to integrate your integration . A streamlined and efficient infrastructure reduces complexity and increases reliability . It can also help lower costs due to standardization and simplified support . SOLA was designed for optimum efficiency , from its mainframe run time to its batch support and ultra efficient parser , SOLA eliminates the " plumbing " that can handicap other solutions . It is also this efficiency that helps make SOLA the fastest and most cost effective product in the space . <p> Development : the development tool is the interface between the tool and the people that get the job done . SOLAs development environment is as easy to use as it is powerful . Web services can be created in minutes with no programming or training required . The development environment runs in a browser and features powerful web 2.0 capabilities such as drag and drop , tab based workspaces @ @ @ @ @ @ @ @ @ @ , there is no workstation software to install and older workstations can be leveraged ( attention to human assets and cost effectiveness at work ) . <p> Governance : industry experts believe that governance is the single most important issue facing the fledgling SOA community . From diagnosing production outages to managing changes and meeting SLAs , governance is a non negotiable requirement in a viable SOA . A solution has to either be governable by a third party tool or incorporate strong governance capabilities . SOLA does both . With WS-Security , WS-Policy , integrated monitoring , logging and auditing , and many more built in governance features , SOLA provides a comprehensive collection of governance and lifecycle management capabilities . SOLA is also fully governable ; its standards based design lends itself to simple and cost effective integration with third party governance solutions . SOLA can function as a stand-alone solution for mainframe SOA and can be governed by Akana 's Integrated SOA Governance Automation Solutions , Workbench and Service Manager , acting as a Certified Governed Service Platform . Certified Governed Service Platform status means that customers @ @ @ @ @ @ @ @ @ @ fidelity of the governance systems and structures defined in an enterprise SOA program . The certification process ensures that Governed Service Platforms can implement and enforce governance policies providing reporting data to enable a closed-loop audit process . The Governed Service Platform status ensures that SOLA can be consistently governed along with other enterprise service platforms . <p> There are other tools available to help you develop your own Mainframe SOA solution . IBMs CICS TS v3.x provides the foundation ( SOAP and XML capability ) for mainframe SOA built into CICS . It is very tempting to believe that you can avoid purchasing a product and work with this " free " capability to create your own mainframe SOA . <p> SOLA is proving its worth in production every day in one of the most demanding industries in the world the financial services industry . At one customer over 200 legacy applications expose hundreds of Web Services using SOLA . Clients estimate that SOLA saved each application $0.5 to $2 million through cost avoidance and direct savings . <p> " We had estimated about $800K using traditional technology to @ @ @ @ @ @ @ @ @ @ the project for $30K . " John McKinley , former CTO , Merrill Lynch <p> At a typical chargeback rate of $0.20 per CPU second , parsing 1,000 bytes would cost $0.000020 . That amounts to a minuscule $20 to parse 1 million transactions . <p> SOLA is built for high performance and high transaction volume . Several customers report running up to 10 million transactions per day through SOLA . <p> To test the difference in performance between SOLA and CICS TS 3.2 , we wrote a COBOL program containing various data types . The goal of the program was to generate a large XML response to put both products through their paces . When we attempted to import the program using CICS Web services assistant , the import failed because the program contained many unsupported data types . SOLA imported the same program without any issues . <p> To make the comparison fair , we altered the program to remove the data types that IBM couldnt handle , then imported the modified program using both Web services assistant and SOLA . This program was similar to the original @ @ @ @ @ @ @ @ @ @ <p> Millions of transactions have been processed through SOLA during extensive stability tests . No failures were experienced . SOLA has been in production for five years no production failures have been experienced . To date , billions of transactions have been processed by SOLA . <p> SOLA has several significant advantages over competitive products . Taken together these features provide lower cost and greater productivity . <p> SOLA Features <p> Leverage Human Assets All competitive products create services from existing mainframe programs , but only SOLA leverages human assets . With SOLA the mainframe programmer the person who knows the program the best creates the services . Competitive approaches expect the distributed programmer the person who knows the program the least ( if at all ) to create services . <p> Global Dictionary One of SOLAs many features is an integrated global dictionary that allows for the automatic translation of COBOL field names without affecting the source program . The SOLA dictionary centralizes translation services , therefore minimizing duplication of effort for developers . <p> Security based on WS-Security and WS-Policy SOLA security is based on WS-Security and WS-Policy @ @ @ @ @ @ @ @ @ @ standards on the mainframe , SOLA provides efficient and flexible security , obviating the need for a middle tier security agent . <p> Batch Capability SOLA provides a number of significant features that are available to the z/OS batch programmer . Firstly , the SOLA DOM parser and API provide the batch programmer with methods to easily and inexpensively consume and create XML documents . Secondly , the SOLA outbound support is also available to the batch programmer , making it simple for a batch program to consume an outbound web service . <p> Browser based Web 2.0 development environment With SOLA there 's no workstation software to install the entire SOLA development toolset runs in a browser . This is a huge advantage in our experience the majority of developers do n't  have workstations that are powerful enough to run the " previous generation " development toolsets provided by competitors . <p> Support for Architectural Standards Using the combination of the SOLA dictionary , WSDL-first development and powerful WSDL customization features , SOLA can publish web services that comply with any and all possible architectural standards . <p> WSDL-First Development @ @ @ @ @ @ @ @ @ @ WSDL that complies with their architecture standards before creating web services . SOLA allows developers to create services that comply with an existing WSDL as well as create services from scratch that generate their own definitions . The SOLA dictionary can be leveraged to make this process faster and easier . <p> UDDI Directory All services created by SOLA are automatically published to an external UDDI 3.0 registry , which ensures that services exposed by SOLA are visible and useable within the enterprise . <p> Standards Based SOLA is a standards based solution , allowing interoperability across platforms , operating systems and programming languages . Being standards based also allows SOLA to expand and evolve without cumbersome enterprise-wide revisions , giving it unparalleled reusability and growth potential . <p> Customization APIs SOLA provides customization APIs that allow customers to add capabilities beyond the products existing feature set . These APIs allow the user access to SOLA processing at various points in the SOAP stack so that processing can be manipulated by user specific application code . These APIs also support custom security exits . Custom APIs can be defined at @ @ @ @ @ @ @ @ @ @ <p> Dashboard The SOLA dashboard allows you to keep an eye on your web services , regions and more with a graphic user interface that provides at-a-glance status information , as well as access to SOLAs monitoring , audit and error logs . <p> XACML Authorization SOLA allows you to create your own authorization protocols to suit the way your organization functions rather than forcing you to adapt to a rigidly defined authorization structure . <p> SOLA Advantages <p> Publishes legacy applications as Web Services , allowing them to easily integrate with . Net , J2EE or any other development environment . <p> Furthermore , no coding is required to publish Web Services with SOLA . It is simple and easy to use with a minimal learning curve . An integrated test harness allows the developer to test and validate their Web Services with just a few mouse clicks . Finally , SOLA is proven in extensive mission critical production systems today . <p> SOLA is already helping to achieve the pinnacle of application integration - reuse . Business functions previously isolated in legacy applications are now open for reuse @ @ @ @ @ @ @ @ @ @ Other solutions require extensive middleware ( hardware and software ) . Although the initial cost of these solutions appears economical the ongoing support and management is cost prohibitive . <p> The SOLA Development Environment uses a J2EE compliant server and requires no workstation software to be implemented . The full features of the development environment are accessible through a browser . <p> SOLA COMMAREA Analyzer The SOLA COMMAREA Analyzer is used to analyze programs that expose a communications area interface . The analyzer reads a programs compile listing , parses the COMMAREA and determines how the fields within the COMMAREA are used . It then produces a WSDL file documenting the interface , a test harness and a run-time metadata template . The template can be moved to production using standard change management procedures . The program will be automatically documented in the SOLA directory . <p> SOLA 3270 Analyzer The SOLA 3270 Analyzer implements an interactive graphical interface . Using this tool , developers execute the application by going through the applications screens/maps . SOLA automatically records the interactions and aggregates them into a single web service ( e.g. @ @ @ @ @ @ @ @ @ @ web service ) . It then produces a WSDL file documenting the interface , a test harness and a run-time metadata template . The template can be moved to production using standard change management procedures . The aggregated transaction is automatically documented in the SOLA directory . <p> SOLA Outbound Analyzer The SOLA Outbound Analyzer allows developers to import the WSDL representing an external web service and then analyze the operations of that service to create callable methods . The analysis automatically creates COBOL or PL/I copybooks that represent the interface to the operations . This approach allows programmers to execute an external Web Service with a simple " CICS Link " command . <p> The SOLA UDDI Directory The SOLA UDDI Directory is maintained in DB2 . All Web Services created by SOLA are fully documented in the SOLA Directory and are organized by project . Since it is a UDDI directory , it is searchable in a variety of ways . <p> The SOLA Testing Facilities SOLA automatically creates a test harness for every Web Service created . This is an extremely helpful tool for the Web Service @ @ @ @ @ @ @ @ @ @ allows for the testing of new Web Services before deployment . <p> MRO SOLA can run using standard CICS multiple region operation ( MRO ) . The http/MQ listener runs in a listening region , dispatching the host application programs in application owning regions . SOLA handles the communication of data between the listening and application regions . Although CICS has a limit of 32K that can be passed between the listener and application regions , SOLA can accept requests and deliver responses that exceed this limit . <p> Error Logging SOLA provides full error logging . Error logging reports are available through a Web reporting tool and are also provided as a Web Service . <p> Monitoring SOLA monitors every transaction that it handles . Monitor reports are available through a Web reporting tool and are also provided as a Web Service . <p> Auditing SOLA provides an optional auditing facility , which records both input and output SOAP messages for audited transactions . The facility is extremely useful for problem diagnosis . Auditing is controlled using WS-Policy . <p> Security SOLA has the most powerful and most versatile @ @ @ @ @ @ @ @ @ @ ( WS Security , &amp; SAML 2.0 etc. ) and by providing mapping between various identities to the mainframe security paradigm ( for example , mapping from SAML 2.0 , X509 , AD/LDAP to mainframe RACF/ACF2/TOP-Secret ) . Furthermore , the users authorization choices range from most basic available on the mainframe such as RACF to XACML PDP residing on or off of the mainframe . <p> Transport Mechanism SOLA offers http/s and MQ as transports . <p> Outbound SOAP requests SOLA provides the ability for the programmer to issue an outbound SOAP request to an external system . That SOAP request is transported by http , https ( SSL ) or MQ to the external system . The requesting program can be running either in CICS or batch . <p> Configuration SOLA takes advantage of the full scalability and fail-over features of parallel sysplex . SOLA introduces no affinities , allowing the workload manager to run transactions on any system in the sysplex . <p> SOLA is the only mainframe SOA product to offer closed-loop Governance automation . A service is automatically governed from the point of creation because @ @ @ @ @ @ @ @ @ @ of WS-PolicyAttachment , is associated with the service though all phases of the Software Development Lifecycle . It is not possible to create or run an ungoverned service . <p> On top of this , SOLAs built in monitoring , logging and auditing capabilities , as well as its standards based architecture combine to make SOLA fully governable by external governance products like Akana 's Policy Manager . 
@@75677643 @4377643/ <h> 3.2. - Cache Lines and Cache Size <p> It could be left up to the programmer or compiler to determine what data should be placed in the cache memories , but this would be complicated since different processors have different numbers of caches and different cache sizes . It would also be hard to determine how much of the cache memory to allocate to each program when several programs are running on the same processor . <p> Instead the allocation of space in the cache is managed by the processor . When the processor accesses a part of memory that is not already in the cache it loads a chunk of the memory around the accessed address into the cache , hoping that it will soon be used again . <p> The chunks of memory handled by the cache are called cache lines . The size of these chunks is called the cache line size . Common cache line sizes are 32 , 64 and 128 bytes . <p> A cache can only hold a limited number of lines , determined by the cache size . For example @ @ @ @ @ @ @ @ @ @ cache lines . 
@@75677644 @4377644/ <h> Location of Essential Files <p> Learning the ins and outs of a new directory structure can be difficult , so here is some help on the location of key files . The paths use the Unix convention of forward slashes ( / ) ; Windows users should substitute back slashes ( ) . Links take you to help topics that present information about the directory structures graphically . <p> Compiled libraries <p> Assuming you are using standard CBM directory paths , compiled libraries are created in the lib directory of a Rogue Wave workspace . There is one workspace and corresponding lib directory for each build configuration for which libraries have been built . The build configuration results in the path LONG ... The path to Tools.h++ libraries compiled with Msvc under Windows NT with a build type code of 6d would be <p> **43;3935;TOOLONG <p> You do , however , have the option of specifying alternative workspace locations anywhere on your system by use of the rwspm script 's -w option . <p> Header files <p> Header files are exported to the Rogue Wave workspace . Tools.h++ @ @ @ @ @ @ @ @ @ @ workspace . Header files for all other products are placed in a subdirectory of rw named for the product . So the location of the header files for Tools.h++ compiled with Msvc under Windows NT with a build type code of 6d would be <p> **42;3980;TOOLONG <p> and the location of the header files for Threads.h++ compiled with the same parameters would be <p> LONG ... <p> Makefiles <p> The customized makefile ( or makefiles ) used to build a library is written to the **39;4024;TOOLONG directory or its subdirectories . The path for Tools.h++ compiled with Msvc and a build type of d7 under Windows NT would be <p> LONG ... <p> Examples makefiles are exported to your declared workspace under **39;4065;TOOLONG . For the Tools.h++ case cited above , the default path would be <p> LONG ... <p> Note that some products divide the examples into subsets , which results in subdirectories of **39;4106;TOOLONG . In this case , there may be multiple makefiles in **39;4147;TOOLONG and in its subdirectories . <p> Source files <p> A library 's implementation source files ( . cpp ) remain in the @ @ @ @ @ @ @ @ @ @ -l flag of the rwspm script , to copy these files to **39;4188;TOOLONG . The path within the parts directory for Tools.h++ on a Unix platform would be <p> LONG ... <p> Object files <p> Like the makefile , the object files ( . obj ) created by a build are generated in the **39;4229;TOOLONG directory or its subdirectories . The path for Tools.h++ compiled with Msvc and a build type of d7 under Windows NT would be <p> The readme documentation for C++ libraries is in the docs directory of the library 's product tree . All of the C++ product online documentation ( user guides , references , and so on ) is in the **26;4270;TOOLONG directory . <p> Rogue Wave strongly advises that you check the build guide for a library product before building it , particularly for products with dependencies on other products . The build guides are located in the htmldocs directory of the Rogue Wave root directory . The name follows the pattern **25;4298;TOOLONG , as in tls708bd for Tools.h++. 
@@75677645 @4377645/ <p> The DB Interface Module provides both a standard interface , which shields you from SQL , and an alternative interface called Open SQL , which allows you to directly execute SQL statements . For more information on the Open SQL interface , see Section 3.1.6 , " Open SQL Classes , " , and Chapter 15 , " Using the Open SQL Classes . " This chapter summarizes the different kinds of classes in the DB Interface Module . <p> SourcePro DB insulates your applications from the variations in data types defined in different databases . Chapter 7 , " The Data Model , " explains in detail how this is done . Applications written with the DB Interface Module work with the primitive C++ data types , plus these additional types : <p> RWDBNullIndicator : Used for detecting NULL values when retrieving data from a relational database . <p> RWDBValue : Used internally by the DB Interface Module to provide data type normalization . It is visible to your applications as the data type of a single cell of an RWDBRow or an RWDBMemTable . It is @ @ @ @ @ @ @ @ @ @ type . <p> Class RWDBSystemHandle contains all the hooks used by a DB Access Module to interact with the native database API . Every RWDBConnection instance has a pointer to an RWDBSystemHandle . Applications can get direct access to the underlying database API through a connection 's system handle . <p> Class RWDBEnvironmentHandle let 's you set environment attributes for specific databases . Every RWDBDatabase instance has a pointer to an RWDBEnvironmentHandle . To access it , an application calls RWDBDatabase : : environmentHandle , which returns a pointer to the base class of a family of classes that contain implementation-specific information . Of course , using RWDBEnvironmentHandle can reduce the portability of applications . <p> Class RWDBExpr is a base class for a family of classes in the DB Interface Module that allow you to program SQL expressions in C++ . Instances of these expressions are usually created anonymously . For example , the following fragment instantiates several RWDBExpr objects : <p> The alternative classes RWDBBulkReader and RWDBBulkInserter are designed to help improve application performance . RWDBBulkReader and RWDBBulkInserter implement reading and inserting ( writing ) directly from arrays supplied @ @ @ @ @ @ @ @ @ @ with the bulk read and write classes and can handle most of the supported data types . For possible data type limitations , see the relevant Access Module User 's Guide . <p> Every DB Access Module contains an instance of a class derived from RWDBPhraseBook , which is a list of SQL phrases in the dialect of a specific database . Instances of class RWDBDatabase use the phrasebook from their respective Access Modules to generate SQL statements . Applications can obtain a reference to an RWDBPhraseBook via the phraseBook() method of RWDBDatabase . <p> Classes RWDBDatabaseCallback and RWDBDatabaseCallbackImp allow you to execute your code at particular callback locations while allocating and destroying database-specific environment handles . With use of database callbacks , you can customize the database environment handles to your needs . <p> Classes RWDBConnCallback and RWDBConnCallbackImp allow users to execute their code at particular callback locations while allocating , destroying , connecting and disconnecting database specific connection handles . With use of connection callbacks , you can customize the database connection handles to your needs . <p> Most callback classes are explained in Chapter 10 , " @ @ @ @ @ @ @ @ @ @ the DB Interface Module Reference Guide . 
@@75677647 @4377647/ <p> As teams develop code with more features , more connectivity , and stricter standards than ever before , it gets increasingly difficult to find bugs and fix security flaws . As teams adopt agile strategies and continuous integration , the pressure mounts to deliver functional , safe , and compliant code on time . <p> In this environment , how do you stop data breaches and application crashes before they 're passed on to the customer ? How do you show conformance to standards when they 're difficult to understand and take valuable time to prove ? Finding issues earlier in the process is not only simpler and cheaper , it opens up resources to spend more time creating real value for your customers rather than fixing defective code . <p> Static code analysis is where it all begins . Through complete program analysis of syntax , semantics , variable estimation , and control and data flow , static code analysis finds issues that are difficult or impossible to find through manual testing . That 's because SCA is based on application structure and data , covering a much broader @ @ @ @ @ @ @ @ @ @ Klocwork takes static code analysis to the next level making it happen on-the-fly . By bringing the power of analysis to the developers desktop and displaying results while lines of code are being written , problems are discovered ( and fixed ) at the earliest possible point before the build . This means less testing later on and fewer downstream impacts to cost and schedule . Klocwork also broadens analysis coverage well beyond syntax and semantics , identifying critical security , safety , and coding standards issues in front of developers ' eyes well before check in . And all this is done within many common IDEs , including Eclipse , Visual Studio , and IntelliJ IDEA . 
@@75677648 @4377648/ <p> A IliDbField object can dynamically change its look and feel . Its style can be any of the following : <p> IliEntryFieldStyle <p> IliTextStyle <p> IliOptionMenuStyle <p> IliTableComboBoxStyle <p> IliToggleStyle <p> IliToggleSelectorStyle <p> IliStringListStyle <p> To change the style of an IliDbField gadget in Rogue Wave Views Studio , you must select the required style from the Style field in the corresponding DbField inspector . <p> Changing the DbField Style in the DbField Inspector <p> The following sections describe the different styles of a DbField gadget , giving you the best situations to use them in . <p> IliEntryFieldStyle <p> This style can be used to display or edit a value of any type . It is not designed to be used with a column that accepts a Boolean value or with a column that has a foreign table . Other styles are better adapted to these two situations . <p> IliTextStyle <p> This style is a scrolling text area that can be used to display or edit multiple lines of data . It is not designed to be used with a column that accepts a Boolean value @ @ @ @ @ @ @ @ @ @ Other styles are better adapted to these two situations . <p> IliOptionMenuStyle <p> This style is designed to be used with a column that has a foreign table or with a column that accepts a Boolean value ( see Foreign Tables ) . It consists of a label and a button . The button accesses a menu that contains values to be selected and displayed in the label . <p> If the DbField is linked to a Boolean value column , the menu contains the options Yes and No , and will not accept any other input . <p> However , if the column has a foreign table , only the values contained in the menu can be selected in the field . <p> IliTableComboBoxStyle <p> This style is designed to be used with a column that has a foreign table or a column that accepts a Boolean value ( see Foreign Tables ) . It consists of an entry field and a button . The button accesses a menu that contains values that can be entered in the field . <p> A DbField with the IliTableComboBoxStyle <p> If the @ @ @ @ @ @ @ @ @ @ menu contains the options Yes and No , and will not accept any other input . <p> However , if the column has a foreign table and if the Constrained property in the DbField inspector is set to Yes , only the values contained in the menu can be entered in the field . <p> However , if the Constrained property in the DbField inspector is set to No , values other than those in the menu can be entered directly into the field . <p> Finally , if the Completion property in the DbField inspector is set to Yes , when one or more characters are entered in the DbField , the option is completed by the appropriate menu entry ( provided the characters uniquely define a menu entry ) . <p> IliToggleStyle <p> This style is very similar to the IliDbToggle object . It is a graphical object that enables you to display a state . A toggle usually includes a state marker and a label . The state marker is to the left of the label and indicates whether the state is on or off ( according @ @ @ @ @ @ @ @ @ @ the button depends on the look that has been selected in Rogue Wave Views Studio ( Windows , Windows XP , or Motif ) . <p> A Toggle in Windows95 Look and Feel and a Toggle in Motif Look and Feel <p> This style is specifically designed to be connected to a table column that has a Boolean value . In this way it can be used to turn the value on or off in the column as required . It should not be used with columns that contain values of other types or with a column that has a foreign table . <p> There are two ways to create a toggle that is linked to a table object column : either the style of an IliDbField instance can be changed or an instance of IliDbToggle can be created directly . <p> The IliDbToggle class provides more flexibility regarding the look of the toggle state marker . However , changing the style of an existing IliDbField enables you to create a form using the Forms Assistant and to customize the style of each of the DbField contained in the form @ @ @ @ @ @ @ @ @ @ be used with a column that has a foreign table mapping . It is a set of toggles that are contained in a frame . Only one of the toggles can be turned on at a time . <p> A DbField with the IliToggleSelectorStyle <p> Note : This IliToggleSelectorStyle should not be used when the list of values is long since the style becomes difficult to manage . <p> IliStringListStyle <p> This style is designed to be used with a column that has a foreign table . It consists of a string list and a string in the list can be selected using the mouse or the keyboard . The strings in the list are read from the foreign table . See Foreign Tables . 
@@75677649 @4377649/ <p> When a table is added to an SQL data source and the columns of the underlying table object are specified , you will notice that the name of the column is automatically set . It is automatically set to the name of the database table column . In most situations , this behavior is acceptable . However , there are certain situations when it can be useful to be able to change this name . <p> You may have noticed in the Rogue Wave Views Data AccessGetting Started Manual that when an additional table is added to the data source , any columns that are not uniquely named are prefixed by the table name they originate from . <p> If you have already set up a number of gadgets that are linked to columns and then add another table to the data source , certain table column names can change . This will have an effect on any gadgets tied to these columns . The gadget will fail to locate the column it is tied to because the column name has changed . <p> To work around this @ @ @ @ @ @ @ @ @ @ page of the SQL Data Source inspector . Providing you do not create any ambiguities , you can type the original column name here . Any gadgets connected to the column will then be updated to show the values in the column . <p> Forcing the Name of a Column Using the Datatype Page <p> Note : The table gadget is the only gadget whose column names change dynamically with the data source . <p> If you leave the Name field empty , the column name will change automatically to avoid any ambiguity whenever a new table is added . 
@@75677650 @4377650/ <h> Lifecycle Manager for APIs <p> In order to win in todays fast paced digital world , businesses must maintain stability and reliability while depending on constantly changing internal and external ( cloud and partner ) environments that support their digital services . Akana 's ( formerly SOA Software ) Lifecycle Manager enables enterprises to effectively collaborate between business , developers and IT operations , resulting in rapid development and deployment cycles while increasing reliability , stability and availability of their APIs and supporting assets . <p> Ensure alignment of API programs with strategic business objectives and make sure that enterprises build the right services at the right time . Achieve quicker return on investment , making sure APIs are built to plan and built to priority . Understand dependencies between planned services and prioritize development appropriately , and build services based on current and planned needs according to a well thought-out program . <h> Improve Alignment between IT and Business <p> Deliver APIs and services that are connected to the enterprises broad set of existing software capabilities and aligned with the enterprises architectural principles and policies . Provide @ @ @ @ @ @ @ @ @ @ exist , how they 're related to each other and how each fits into a companys business and technical landscape . Provide a context for understanding and assessing existing software assets and automate SDLC processes for new APIs and services . <h> Manage API Devops <p> Connect to Devops tooling to coordinate propagation and deployment of APIs and Services across dev , test , stage and production environments . Automatically provision APIs and services to Akanas leading API management products while applying runtime monitoring , security and privacy policies selected over the course of executing the enterprises defined SDLC . <h> Automate API and App Provisioning <p> Add configurable workflow based provisioning of APIs to developers and partners . Easily capture approval information through configurable forms and provide control on how APIs get provisioned to partners . These capabilities can be readily integrated into an IT organizations native tools and processes , increasing organizational agility to respond to changing corporate and regulatory mandates and internal process changes . <h> Use Tools that You Know <p> Lifecycle Manager is integrated with mainstream development tools like such as Eclipse , Microsoft Visual Studio @ @ @ @ @ @ @ @ @ @ parsing , extraction and population from SCMs , GitHub and other development tools and platforms . Synchronize with continuous integration tools like Jenkins to track build traceability and delivery of tested and approved executables to downstream deployment platforms . <h> Visualize Asset Relationships <p> Quickly and easily understand asset-to-asset relationships via graphical representation within a browser or IDE . Viewing such relationships in an impact analysis process helps users understand how Enterprise Architecture relates to IT development projects and plan for incremental change across their set of APIs and services . <p> Enterprises must be able to track all of the elements of their API and services architecture , changing them as needed while maintaining a clear understanding of underlying interdependencies . Learn how Akana helps . <p> Learn how can businesses quickly externalize their data as APIs , increase customer engagement across their digital channels , while maintaining the desired level of control as mandated by their industry . 
@@75677652 @4377652/ <p> The front lines of information security risk management evolve in parallel with the dominant technologies in common use . The emergence of the web brought web-based threats and resulting countermeasures . The rise of SQL databases brought SQL injection and its mitigations . Now , we have the increasing usage and business importance of application programming interfaces ( APIs ) , which are vital the development of mobile applications and the digital enterprise in general . APIs , like all technologies , have security vulnerabilities . In fact , the very openness that makes them so useful in expanding the enterprise into the digital realm can itself be an avenue of risk exposure . <p> API security risks are also potentially worse , in business impact terms , than earlier generations of information security risk . APIs are often a key part of fast-track application development , enabling processes such as DevOps and connecting multiple corporate entities in rapid implementation cycles . While great for business , these capabilities can also expose more than one business to risks that might have previously been limited to a single corporation @ @ @ @ @ @ @ @ @ @ in pace and connectivity . <p> Akana works with many clients worldwide who are concerned about API security issues . To help them and the broader industry gain a better understanding of the state of API security , we conducted a survey of 1,200 IT professionals on the subject in May , 2015 . The respondents came from a range of industries and organization sizes . The survey reveals , perhaps not surprisingly , that API security is an identified risk for many IT departments and business managers . The specific ways that companies handle API security do vary , though , with organizations with larger portfolios of APIs in production having more aggressive and sophisticated API security policies in effect . The size of the organization overall does not appear to have much effect on the level of API security in use . 
@@75677653 @4377653/ <h> 2.16 Contents of RWDBEnvironmentHandle <p> The DBTools.h++ Sybase CT access library returns an environment handle that has the type **29;4325;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . In addition , this handle contains the CSCONTEXT pointer : <p> CSCONTEXT* cscontext() const ; <p> This pointer can be used to set or retrieve configuration parameters that are not directly supported by the environment handle . <p> The timeout method defines the length of time in seconds that the Sybase Client-Library waits for a server response when making a request : <p> inttimeout() const ; RWDBStatustimeout ( int value ) ; <p> In the Sybase Client-Library documentation , the default is an infinite timeout period . The application can set this value any time . It takes effect for all open connections immediately upon being called . <p> The default value is 25 , according to the Sybase Client-Library documentation . This method has no effect if the maximum number of connections being set is less than the number of currently open connections . This behavior @ @ @ @ @ @ @ @ @ @ <p> The textLimit method defines the length in bytes of the longest text or image value an application is prepared to receive : <p> longtextLimit() const ; RWDBStatustextLimit ( long value ) ; <p> The Sybase Client-Library will read but ignore any part of the text or image value that goes over the limit defined by this function . Refer to the Sybase Client-Library documentation for more information . <p> NOTE : This method affects only the client side text limit , not the server side text limit for this connection . To change the server side limit , you must call ct.option() directly . <p> Please see the Sybase Client-Library documentation for hidden keys semantics . The default behavior of the Sybase Client-Library is not to expose any hidden keys . Setting it to TRUE will change the default behavior. 
@@75677655 @4377655/ <h> 2.15 Contents of RWDBSystemHandle <p> The RWDBConnection : : systemHandle() method returns a pointer to a base class from which a family of implementation-specific classes are derived . To use the database API directly , you can downcast this pointer to the appropriate type , and use its implementation-specific features . Naturally , this usage reduces an application 's portability . <p> For the Oracle access library , the implementation-specific system handle has the datatype RWDBOracleSystemHandle . It contains a pointer to the Logon Data Area ( LDA ) and to the Host Data Area ( HDA ) . These provide access to the server . The handle also maintains control parameters used when accessing the database . The production of a new RWDBConnection creates a new RWDBOracleSystemHandle . The handle starts the session and maintains the LDA and HDA . The following functions may be used to retrieve these components : <p> LdaDef* lda() ; ub1* hda() ; <p> NOTE : The following function has been eliminated : HdaDef* hda() ; The type HdaDef is not available on all clients and is functionally identical to ub1 . @ @ @ @ @ @ @ @ @ @ to RWDBReader . Please see the caching chapter in the User 's Guide for information on how to alter the size of a fetch . Existing programs that use fetchSize() should change the cache size of their RWDBReaders instead . <p> The function parameterSize() was superseded by the function **27;4356;TOOLONG . Calls to parameterSize() can safely be replaced with equivalent calls to **27;4385;TOOLONG . <p> The function **28;4414;TOOLONG was superseded by the function maximumBlobSize() . Calls to **28;4444;TOOLONG can safely be replaced with equivalent calls to maximumBlobSize(). 
@@75677656 @4377656/ <h> ABV.GENERAL <h> Buffer overflow-array index out of bounds <p> A buffer overflow , or overrun , is an anomaly in which a program writing data to a buffer overruns the buffer 's boundaries and overwrites adjacent memory . Typically , this problem occurs when a program is copying strings of characters to a buffer . <p> C and C++ provide no built-in protection against accessing or overwriting data in any part of memory , and do not automatically check that data written to an array ( the built-in buffer type for this language ) is within the array 's boundaries . <p> The ABV.GENERAL checker is a generic checker that looks for array bounds violations " any access to an array element that is outside of the bounds of that array . <h> Vulnerability and risk <p> Buffer overflows can be triggered by inputs that are designed to execute code or alter the way the program operates . This may result in erratic program behavior , including memory access errors , incorrect results , a crash , or a breach of system security . <p> Consequences of buffer @ @ @ @ @ @ @ @ @ @ and potentially malicious code . For example , buffer overflows can manipulate a program in several ways : <p> By overwriting a local variable that is near the buffer in memory to change the behavior of the program to benefit the attacker <p> By overwriting the return address in a stack frame so that execution resumes at the return address specified by the attacker ( usually a user input-filled buffer ) <p> By overwriting a function pointer or exception handler , which is subsequently executed <h> Code examples <h> Vulnerable code example 1 <p> Klocwork produces a buffer overflow report for line 4 indicating that the array index of ' fixedbuf ' may be out of bounds : array ' fixedbuf ' of size 10 allows index values 0 .. 24 . The ABR checker looks for array bounds violations , and in this case , finds that access to array element ' fixedbuf ' is outside of the bounds of that array . <h> Fixed code example 1 <p> In the fixed code example , the sprintf function , which simply assumes that the output buffer is large enough @ @ @ @ @ @ @ @ @ @ snprintf function , which writes a maximum number of bytes to the buffer . Note that this is just one way to prevent the buffer overflow in this example code , and this fix will result in string truncation , which may need to be accounted for , depending on the application . <h> Vulnerable code example 2 <p> There are situations when an array or a pointer to an allocated buffer is cast to a different type before its elements are accessed . In this example , the upper bound of the loop at line 4 is taken to be the size of the array ' a ' in characters , but array ' a ' is accessed as an array of integers at line 6 . Klocwork produces a buffer overflow report for the snippet above indicating that the array index of ' a ' may be out of bounds due to the difference between 1-byte characters and 4-byte integers at line 6 : the array ' a ' of size 2 may use index values 2 .. 7 . The traceback of the issue contains information indicating @ @ @ @ @ @ @ @ @ @ ' is treated as an array of size 2. 
@@75677657 @4377657/ <h> 2.13 Contents of RWDBEnvironmentHandle <p> The access library for the Sybase DB-Library returns an environment handle of type **29;4474;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . The available applications are described in Section 2.13.1 to Section 2.13.13 . <p> Please note that some connect time parameters are set only when a connection is established with the SQL server . When the method returns a valid RWDBStatus for these parameters , it does not necessarily mean that the connection parameter has been accepted by the server . Appropriate error messages will be fielded to the application only when a connection is established . <p> The timeout() method defines the length of time in seconds that the Sybase DB-Library waits for a server response when making a request . Two timeout() methods are available : <p> int timeout() const ; RWDBStatus timeout ( int value ) ; <p> According to the Sybase DB-Library manual , the default is an infinite timeout period . The application can set this value at any time . It takes effect @ @ @ @ @ @ @ @ @ @ In the Sybase DB-Library , national language is set for a particular connection using DBSETLNATLANG() . For DBSETLNATLANG() to take effect , it must be called before an RWDBConnection is obtained . Refer to the Sybase DB-Library manual for the semantics of setting national language using DBSETLNATLANG() . <p> The encrypt method defines whether or not network password encryption is to be used when logging into a Sybase 10.0+ SQL server . Two encrypt() methods are available : <p> RWBoolean encrypt() const ; RWDBStatus encrypt ( RWBoolean value ) ; <p> Setting the method to TRUE enables password encryption . To take effect , the method must be called before an RWDBConnection is obtained . Refer to the Sybase DB-Library manual for the semantics of setting password encryption . <p> If an application enables secured login , it must subsequently set security labels using securityLabel() . An application can not enable secured login without setting security labels . To take effect , the enableSecurity(TRUE) must be called before an RWDBConnection is obtained . Refer to the Sybase DB-Library manual for the complete semantics of enabling secured logins . <p> The @ @ @ @ @ @ @ @ @ @ defines the label value . To take effect , the method must be called before an RWDBConnection is obtained . Refer to the Sybase DB-Library manual for the detailed semantics of label name , label value , and enabling secured logins. 
@@75677658 @4377658/ <p> " On 2 to 3 million lines of code , we ran Klocwork against multiple competitors . It handled the code base very well and had the ability to deal with C++ templates in a useful way ... there was also a low rate of false positives . " Mr. Alexander Much , head of software systems engineering , Elektrobit <p> Elektrobit is at the heart of embedded , supplying HMI technologies , navigation , electronic control units , and software for over 70 million vehicles and over 1 billion embedded devices . <p> When Elektrobit chose to adopt a new static code analysis ( SCA ) tool , it involved a mix of technical evaluation and programmer education to get the right tool and the right people on board within the organization . This case study explains the process and results when choosing Klocwork. 
@@75677661 @4377661/ <p> With SourcePro , you write your code once , and deploy on any platform . This infrastructure layer for C++ insulates developers from the specifics of the underlying platform and provides low-level access . Developers choose the level of abstraction they require . <p> " Our R&amp;D staff needed to devote as much time as possible to our core identity recognition platform , without impacting timely maintenance and platform updates for our installed base . Rogue Wave components made the integration of these new platforms seamless for our development team , enabling them to focus on their core competencies . " <p> Andrew Friedrich , SRD <p> Director of Product Marketing <h> Build once , deploy anywhere <p> By writing against SourcePros APIs , developers deploy on any combination of operating system , compiler , and database . And , SourcePro provides a layer of independence to support cloud-based or on-premise application development . <p> Developers build their applications against our APIs , which rarely change . Even when the underlying platform capabilities change , we rewrite our components to take advantage of upgrades , insulating our users @ @ @ @ @ @ @ @ @ @ the latest technology with minimum impact to your code <p> With each release , SourcePro incorporates compiler , operating system and database innovations to speed performance without requiring any changes in your code . SourcePro provides constructs for threading abstractions and high-performance containers . <p> SourcePro speeds up initial application development and streamlines ongoing maintenance . The result ? Faster software with a longer lifespan and lower maintenance costs . <h> Minimize your maintenance costs <p> SourcePro is designed to minimize the maintenance cost of your applications . Each component is tested on all platforms to ensure high quality across all these areas : 
@@75677662 @4377662/ <h> 2.16 Contents of RWDBEnvironmentHandle <p> The access library for ODBC returns an environment handle that has the type **28;4505;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . <p> Connect time parameters are not set until a connection is established with the server . When a method returns a valid RWDBStatus , it does n't necessarily mean that the connection parameter was accepted by the server . Appropriate error messages are fielded to the application only when a connection is established . <p> When tracing is on , the driver manager writes each ODBC function call to the trace file ; Section 2.16.4 explains how to specify a trace file name . Tracing is enabled if the Trace keyword in the ODBC section of the ODBC.INI file ( or registry ) is set to 1 when an application gets an **28;4535;TOOLONG . If you need complete control of tracing capabilities through class **28;4565;TOOLONG , you must disable the trace in the ODBC.INI file ( or registry ) . <p> The trace file name is an RWCString @ @ @ @ @ @ @ @ @ @ is not enabled , this file name is ignored . If tracing is enabled , the driver writes to this file each time a driver call is made . If no trace file is specified and tracing is enabled , the driver manager writes to SQL.LOG . <p> The qualifier can be either a database or a directory name . If the qualifier is a database , the driver sends a USE database statement to the data source . If the qualifier is a directory , the driver changes its current directory to the directory specified by qualifier . 
@@75677666 @4377666/ <p> The IlvGadgetManager class is a subclass of the IlvManager class that deals with gadgets . For details about managers , see the related User 's Manual . Unlike IlvManager objects , instances of IlvGadgetManager have only one associated view because gadgets , can not appear in several views at the same time , whereas basic graphic objects can . <p> As a general rule , unless you want to save gadgets to an . ilv file ( the Rogue Wave Views format ) , we recommend that you use gadget containers rather than gadget managers to store gadgets . <p> We do not recommend that you use simple containers to store gadgets since these objects do not implement features such as keyboard focus management . Adding gadgets to these containers might produce unexpected results . <p> In addition , gadgets can not be zoomed in or out . As a consequence , we do not recommend that you modify the scaling factor of a gadget holder . 
@@75677667 @4377667/ <h> On-Demand Webinar : OSS has taken over the enterprise : The top five OSS trends of 2015 <p> It 's everywhere . From your phone to the enterprise , open source software ( OSS ) is running far and wide . Gartner predicts that by 2016 , 99 percent of Global 2000 enterprises will use open source in mission-critical software . While it 's free , easy to find , and pushes software to the market faster , it 's vital to understand how to use OSS safely . <p> Join Richard Sherrard , director of product management at Rogue Wave , for a live webinar reviewing the top five OSS trends of 2015 . From OSS discovery , to risk , and governance , we 'll take a deep dive into the trends we 've noticed this year while providing you with some predictions for 2016 . <p> In this webinar you 'll learn how to : <p> Discover the OSS in your codebase to ensure that code is free of bugs , security vulnerabilities , and license conflicts <h> Presenter <p> Richard Sherrard , director of @ @ @ @ @ @ @ @ @ @ at Rogue Wave focused on their Open Source governance solutions . Past experiences with software component reuse within applications and the challenges this brings to an organization makes him an advocate for enabling the proper control mechanisms around open source usage within organizations . Richard brings nearly 20 years of experience in the Software Industry to Rogue Wave . Prior to Rogue Wave he held product management positions with Black Duck Software , Borland Software and Segue Software . 
@@75677668 @4377668/ <p> This is a complete example of a direct subtype of the IlvManagerViewInteractor class . It allows the user to move a graphic object to another location by dragging it with the mouse . Here is the declaration of this class ( it can also be found in the header file **34;4595;TOOLONG ) : <p> class IlvMoveInteractor <p> : public IlvManagerViewInteractor <p> <p> public : <p> **29;4631;TOOLONG manager , <p> IlvView* view ) <p> : **32;4662;TOOLONG , view ) , <p> move(0) <p> virtual void **25;4696;TOOLONG event ) ; <p> virtual void handleExpose ( IlvRegion* clip = 0 ) ; <p> virtual void drawGhost() ; <p> void drawGhost ( const IlvRect&amp; , <p> IlvRegion* clip = 0 ) ; <p> void drawGhost ( IlvGraphic* , IlvRegion* clip = 0 ) ; <p> virtual void doIt ( const IlvPoint&amp; ) ; <p> const IlvRect&amp; getRectangle() const return xorrectangle ; <p> protected : <p> IlvPos deltax , deltay ; <p> IlvRect bbox ; <p> IlvGraphic* move ; <p> IlvRect xorrectangle ; <p> IlBoolean wasSelected ; <p> void handleButtonDown ( const IlvPoint&amp; ) ; <p> void **25;4723;TOOLONG IlvPoint&amp; ) ; <p> void @ @ @ @ @ @ @ @ @ @ interactor let 's you select and deselect objects by clicking on them with the left mouse button and the Shift key pressed . You can move an object or a set of selected objects but you can not resize them . <p> The following protected fields are used in this class : <p> deltax , deltay - Stores the distance between the mouse and the top-left corner of the objects being moved . <p> bbox - Stores the bounding box of the objects being moved . <p> move - Keeps a pointer to the object being moved . <p> xorrectangle - Stores the rectangle dragged to mark a region . <p> wasSelected - Keeps a Boolean value indicating whether the designated object was selected before it was moved . This information is required because the object is selected when you start to move it . There are two different cases in this interactor , depending on whether one or more object is being moved . If more than one object is moved , a moving rectangle that encloses the bounding boxes of these objects is displayed . Otherwise , the moving @ @ @ @ @ @ @ @ @ @ on mouse events . All other events are dispatched to accelerators by a call to IlvManager : : shortCut , but only if an object is not being moved at this point . This is because some accelerators might remove the object being worked on , which can be dangerous : <p> void <p> IlvMoveInteractor : : **25;4750;TOOLONG event ) <p> <p> switch ( event.type() ) <p> case IlvButtonDown : <p> xorrectangle.w(0) ; <p> move = 0 ; <p> if ( event.modifiers() &amp; ( IlvLockModifier IlvNumModifier ) ) <p> **40;4777;TOOLONG ; <p> return ; <p> <p> if ( event.button() ! = IlvLeftButton ) <p> **31;4819;TOOLONG , getView() ) ; <p> return ; <p> <p> if ( ! event.modifiers() ) <p> **25;4852;TOOLONG ( event.x() , event.y() ) ) ; <p> else <p> IlvManager* manager = getManager() ; <p> if ( event.modifiers() &amp; IlvShiftModifier ) <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> IlvGraphic* obj = manager-&gt;lastContains ( p , getView() ) ; <p> IlvDrawSelection* sel = 0 ; <p> if ( obj ) sel = getSelection(obj) ; <p> if ( ! sel &amp;&amp; obj &amp;&amp; **31;4879;TOOLONG ) @ @ @ @ @ @ @ @ @ @ ) ; <p> <p> break ; <p> case IlvButtonUp : <p> if ( event.button() == IlvLeftButton ) <p> handleButtonUp ( IlvPoint ( event.x() , event.y() ) ) ; <p> else **31;4940;TOOLONG , getView() ) ; <p> break ; <p> case IlvButtonDragged : <p> if ( event.modifiers() == IlvLeftButton ) <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> handleButtonDragged(p) ; <p> <p> break ; <p> default : <p> if ( ! move ) <p> **31;4973;TOOLONG , getView() ) ; <p> break ; <p> <p> The following types of events are handled by the handleEvent member function : <p> Only the left button is handled . If the event involves another mouse button , the event is ignored and dispatched to manager accelerators : <p> if ( event.button() ! = IlvLeftButton ) <p> **31;5006;TOOLONG , getView() ) ; <p> return ; <p> <p> The handleButtonDown member function is called if there is no event modifier : <p> if ( ! event.modifiers() ) <p> **25;5039;TOOLONG ( event.x() , event.y() ) ) ; <p> If the Shift modifier is set , the selection state of the object pointed to by @ @ @ @ @ @ @ @ @ @ IlvShiftModifier ) <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> IlvGraphic* obj = **26;5066;TOOLONG , getView() ) ; <p> IlvDrawSelection* sel = 0 ; <p> if ( obj ) sel = getSelection(obj) ; <p> if ( ! sel &amp;&amp; obj &amp;&amp; **31;5094;TOOLONG ) <p> LONG ... <p> <p> <p> Button-Up Events <p> If the event comes from the left button , handleButtonUp is called . Otherwise , the event is dispatched to accelerators . <p> case IlvButtonUp : <p> if ( event.button() == IlvLeftButton ) <p> handleButtonUp ( IlvPoint ( event.x() , event.y() ) ) ; <p> else **31;5127;TOOLONG , getView() ) ; <p> break ; <p> Button-Dragged Events <p> The handleButtonDragged member function is called , but only if the event comes from the left button . <p> case IlvButtonDragged : <p> if ( event.modifiers() == IlvLeftButton ) <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> handleButtonDragged(p) ; <p> <p> break ; <p> drawGhost Member Function <p> This member function is split in three parts : the common part , which is the entry point from the member function handleEvent , @ @ @ @ @ @ @ @ @ @ being done . <p> If there is only one selected object , a specific drawGhost is called for this object . Otherwise , another drawGhost function that handles a rectangle is called : <p> void <p> IlvMoveInteractor : : drawGhost() <p> <p> if ( ! xorrectangle.w() ) return ; <p> if ( **34;5160;TOOLONG == 1 ) <p> drawGhost(move) ; <p> else <p> drawGhost(xorrectangle) ; <p> drawGhost for a Rectangle <p> This member function is called if there is more than one selected object . It displays the bounding box of all the selected objects being moved in the view . The palette of the IlvManager object is used : <p> void <p> IlvMoveInteractor : : drawGhost ( const IlvRect&amp; rect , IlvRegion* clip ) <p> <p> if ( ! rect.w() ) return ; <p> IlvManager* manager = getManager() ; <p> if ( clip ) **36;5196;TOOLONG ( clip ) ; <p> LONG ... <p> if ( clip ) **36;5234;TOOLONG ( ) ; <p> <p> drawGhost for an Object <p> This member function is called if there is only one selected object . It displays the object at its new coordinates by @ @ @ @ @ @ @ @ @ @ set to XOR mode . The new coordinates are computed from the difference between the coordinates of the rectangle being dragged and the coordinates of the original bounding box of the object : <p> void <p> IlvMoveInteractor : : drawGhost ( IlvGraphic* obj , IlvRegion* clip ) <p> <p> if ( ! **32;5272;TOOLONG ! xorrectangle.w() ) <p> return ; <p> IlvPos tempdx , tempdy ; <p> if ( getTransformer() ) <p> IlvRect r1(xorrectangle) ; <p> IlvRect r2(bbox) ; <p> **32;5306;TOOLONG ; <p> **32;5340;TOOLONG ; <p> tempdx = r1.x() - r2.x() ; <p> tempdy = r1.y() - r2.y() ; <p> else <p> tempdx = xorrectangle.x() - bbox.x() ; <p> tempdy = xorrectangle.y() - bbox.y() ; <p> <p> obj-&gt;translate ( tempdx , tempdy ) ; <p> **27;5374;TOOLONG ; <p> obj-&gt;draw ( getView ( ) , getTransformer() , clip ) ; <p> **27;5403;TOOLONG ; <p> **25;5432;TOOLONG , -tempdy ) ; <p> <p> doIt Member Function <p> The doIt member function must apply the translation to all selected objects . The delta parameter gives the translation vector expressed in the view coordinate system so it must be converted to the object coordinate system . @ @ @ @ @ @ @ @ @ @ be done by calling the IlvGraphic member functions directly ; it must be done by the manager . Here , IlvManager : : applyToSelections calls TranslateObject for each selected object : <p> void <p> **27;5459;TOOLONG object , IlAny argDelta ) <p> <p> IlvPoint* delta = ( IlvPoint* ) argDelta ; <p> **28;5488;TOOLONG ( ) , delta.y() ) ; <p> <p> void <p> IlvMoveInteractor : : doIt ( const IlvPoint&amp; delta ) <p> <p> IlvPoint origin ( 0 , 0 ) , <p> tdelta(delta) ; <p> if ( getTransformer() ) <p> **36;5518;TOOLONG ; <p> **36;5556;TOOLONG ; <p> <p> IlvPoint dp ( tdelta.x ( ) -origin.x() , <p> tdelta.y()-origin.y() ) ; <p> LONG ... &amp;dp ) ; <p> <p> handleButtonDown Member Function <p> The handleButtonDown member function selects the object to be moved , storing its previous state in wasSelected . Then , it computes the bbox field by means of a call to the ComputeBBoxSelections function . This function returns in bbox the bounding box of all the selected objects : <p> The first part initializes the result to the empty rectangle , and then queries the manager for all the @ @ @ @ @ @ @ @ @ @ in the array objs : <p> bbox.resize ( 0 , 0 ) ; <p> IlUInt nbselections ; <p> IlvGraphic** objs = **39;5594;TOOLONG ; <p> The next part starts a loop to scan every object : <p> IlvRect rect ; <p> for ( IlUInt i=0 ; i &lt; nbselections ; i++ ) <p> This next part reads the bounding box of each object , transformed in the view coordinate system , and adds it to the result : <p> **26;5635;TOOLONG , t ) ; <p> for ( IlUInt i=0 ; i &lt; nbselections ; i++ ) <p> **26;5663;TOOLONG , t ) ; <p> bbox.add(rect) ; <p> <p> handleButtonDragged Member Function <p> If there is a moving object and if it is moveable , the dragging position is snapped to the manager grid ( if one exists ) and a new xorrectangle is computed . Then , the member function ensureVisible makes sure that the point the user drags will remain on the visible part of the view : <p> void <p> IlvMoveInteractor : : **25;5691;TOOLONG IlvPoint&amp; point ) <p> <p> if ( ! move ) return ; <p> IlvPoint p = @ @ @ @ @ @ @ @ @ @ ) <p> if ( xorrectangle.w() ) drawGhost() ; <p> p.translate ( deltax , deltay ) ; <p> **35;5753;TOOLONG ( ) , p ) ; <p> p.translate ( -deltax , -deltay ) ; <p> xorrectangle.move ( p.x ( ) + deltax , p.y() + deltay ) ; <p> **26;5790;TOOLONG ( ) , bbox.h() ) ; <p> ensureVisible(p) ; <p> drawGhost() ; <p> <p> <p> handleButtonUp Member Function <p> If there are objects to move , they are translated by calling the member function doIt . Otherwise , the last designated object is deselected : 
@@75677669 @4377669/ <h> 2.17 Contents of **28;5818;TOOLONG <p> Strings and binary data can be stored in an Oracle8 database using either Locator types ( CLOB and BLOB ) or LONG and RAW datatypes . The class **28;5848;TOOLONG has four methods for controlling whether RWDBValue : : String and RWDBValue : : Blob are mapped to locators when creating tables with DBTools.h++ . These methods set and return information about an internal flag that is used to determine whether or not a column should be typed as an OCI* Locator type . ( See Table 2 for the default mappings . ) The methods are : <p> RWBoolean **28;5878;TOOLONG ; <p> Returns TRUE if , when creating tables , a Locator column is associated with an RWDBColumn that has an RWDBValue : : ValueType of String . The default value is FALSE . <p> void **37;5908;TOOLONG ; <p> When creating tables , sets the flag for controlling whether or not a Locator column is associated with an RWDBColumn that has an RWDBValue : : ValueType of String . <p> RWBoolean **26;5947;TOOLONG ; <p> Returns TRUE if , when creating tables , a @ @ @ @ @ @ @ @ @ @ RWDBValue : : ValueType of Blob . The default value is FALSE . <p> void **35;5975;TOOLONG ; <p> When creating tables , sets the flag for controlling whether or not a Locator column is associated with an RWDBColumn that has an RWDBValue : : ValueType of Blob . 
@@75677670 @4377670/ <h> Uncle Bob , Laura Thomson , Andi Gutmans , and Rod Cope to speak <p> Rogue Wave Software has selected four keynote speakers for ZendCon 2016 : Robert C. " Uncle Bob " Martin , Laura Thomson , Andi Gutmans , and Rod Cope . These four speakers will lead a group of keynoters during the enterprise PHP conference in Las Vegas , October 18-21 at the Hard Rock Hotel and Casino . <p> A world renowned software craftsman , speaker , and author , Uncle Bob will bring his wit , extensive knowledge , and unique views to ZendCon . As the first chairman of the Agile Alliance and a leading member of the Worldwide Software Craftsmanship Movement - Clean Code , Uncle Bob is a sought-after expert that will have insights for all ZendCon attendees . <p> Joining Uncle Bob on the ZendCon keynote list is the woman that wrote the book on PHP , PHP and MySQL Web Development , Laura Thomson . Director of engineering at Mozilla and board member at Internet Security Research Group , Thomson specializes in web architecture development , web @ @ @ @ @ @ @ @ @ @ and strategy development . <p> Zend co-founder Andi Gutmans will attend ZendCon 2016 as a keynote speaker and will share his views of the software world in his new role with AWS . Gutmans is the co-creator of PHP and brings an unmatched view of PHP in the enterprise . <p> " My heart will always be with PHP , so attending ZendCon as a keynote speaker is a no-brainer for me , " says Gutmans . " I 've seen the language and the community evolve and grow , so I 'm excited to continue to play a role at ZendCon , and share new insights with my friends . " <p> Rounding out the list of announced keynote speakers is OpenLogic founder and Rogue Wave CTO , Rod Cope . A regular on the technology conference circuit , Cope is an open source advocate and user since the 1980 's , and currently guides new technology at Rogue Wave . <p> " Our list of keynote speakers is shaping up to make this the best ZendCon we 've held , " says Adam Culp , Zend senior professional services consultant at @ @ @ @ @ @ @ @ @ @ pleased to have a well-rounded group of PHP and open source experts who have such impressive and broad of expertise . " <p> For more information , visit the ZendCon website , or register now to attend these great keynotes. 
@@75677672 @4377672/ <h> 2.16 Contents of RWDBEnvironmentHandle <p> The access library for the Microsoft SQL Server returns an environment handle that has the type **29;6012;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . <p> Please note that some connect time parameters are set only when a connection is established with the SQL server . When the method returns a valid RWDBStatus for these parameters , it does not necessarily mean that the connection parameter has been accepted by the server . Appropriate error messages will be fielded to the application only when a connection is established . <p> The timeout() method defines the length of time in seconds that Microsoft SQL Server ODBC driver waits for a server response when making a request . Two methods are available : <p> SQLUINTEGER timeout() const ; RWDBStatus timeout ( SQLUINTEGER value ) ; <p> In the Microsoft SQL Server library manual , the default is an infinite timeout period . The application can set this value at any time . It takes effect for all open connections immediately upon being @ @ @ @ @ @ @ @ @ @ manager writes each ODBC function call to the trace file ; Section 2.16.5 explains how to specify a trace file name . Tracing is enabled if the Trace keyword in the ODBC section of the ODBC.INI file ( or registry ) is set to 1 when an application gets an **29;6043;TOOLONG . If you need complete control of tracing capabilities through class **29;6074;TOOLONG , you must disable the trace in the ODBC.INI file ( or registry ) . <p> The trace file name is an RWCString containing the name of the trace file . If tracing is not enabled , this file name is ignored . If tracing is enabled , the driver writes to this file each time a driver call is made . If no trace file is specified and tracing is enabled , the driver manager writes to SQL.LOG . <p> The qualifier can be either a database or a directory name . If the qualifier is a database , the driver sends a USE database statement to the data source . If the qualifier is a directory , the driver changes its current directory to the @ @ @ @ @ @ @ @ @ @ , national language is set for a particular connection using the SQLDriverConnect() connection string keyword LANGUAGE . For this setting to take effect , it must be called before an RWDBConnection is obtained . Please refer to the Microsoft SQL Server ODBC driver documentation for the semantics of setting the national language . <p> **29;6105;TOOLONG includes the secureLogin method , which allows Windows NT users to use SQL Server 's secure login feature . Enabling secureLogin tells SQL Server to use the user 's NT login to establish a connection . The user and password fields supplied to RWDBManager : : database() will be ignored . Two methods are provided : <p> The following example shows how to gain access to class **29;6136;TOOLONG . Note that the application must be compiled with an include path to the Microsoft SQL Server library include files . 
@@75677673 @4377673/ <h> 4.3 URL Patterns <p> The url-pattern element of a servlet-mapping or a filter-mapping associates a filter or servlet with a set of URLs . When a request arrives , the container uses a simple procedure for matching the URL in the request with a url-pattern in the web.xml file . Section 4.7.2 describes the servlet-mapping element . Section 4.8.2 describes the filter-mapping element . <p> A URL pattern may contain a subset of US-ASCII characters . Other values must be escaped . RFC 2396 describes the legal values for a URL pattern . <p> Note that HydraExpress matches a URL pattern as a sequence of bytes rather than a sequence of characters . HydraExpress considers URL-escaped and unescaped sequences to be identical . In other words , the URL pattern http : //example.com/a/* is identical to the URL pattern http : //example.com/%61/* . To represent a character pattern that may have more than one byte sequence , add a mapping for each byte sequence . <p> URL patterns use an extremely simple syntax . Every character in a pattern must match the corresponding character in the URL path @ @ @ @ @ @ @ @ @ @ a pattern , /* matches any sequence of characters from that point forward . The pattern *. extension matches any file name ending with extension . No other wildcards are supported , and an asterisk at any other position in the pattern is not a wildcard . <p> For example , a web.xml file for the examples context on the servlet container at example.com matches the pattern in LONG ... as follows : <p> http : **38;6167;TOOLONG <p> Matches <p> LONG ... <p> Matches <p> http : **29;6207;TOOLONG <p> Matches <p> http : **36;6238;TOOLONG <p> Does not match <p> A context located at the path /examples on the Agent at example.com matches the pattern in **44;6276;TOOLONG as follows : <p> LONG ... <p> Matches <p> LONG ... <p> Matches <p> http : **39;6322;TOOLONG <p> Matches <p> LONG ... <p> Does not match , the extension is uppercase <p> LONG ... <p> Does not match , the extension is mapi rather than map <p> Different filters in a single context often use the same url-pattern . In this case , each filter that matches the request may process the request , @ @ @ @ @ @ @ @ @ @ no two servlet-mapping elements in the same application may use the same url-pattern . If the web.xml file contains two identical mappings to different servlets , the container makes no guarantees about which servlet the container calls for a given request . However , two servlets may use overlapping url-pattern elements . In that case , the matching procedure determines which servlet the container calls . <p> A request may match more than one servlet-mapping in a given context . The servlet container uses a straightforward matching procedure to determine the best match . The matching procedure has four simple rules . First , the container prefers an exact path match over a wildcard path match . Second , the container prefers to match the longest pattern . Third , the container prefers path matches over filetype matches . Finally , the pattern **40;6363;TOOLONG always matches any request that no other pattern matches ( see Section 4.3.3 ) . <p> For example , a context web.xml file can map the home page for an online catalog to one pattern and the search page for the catalog to a different pattern @ @ @ @ @ @ @ @ @ @ matching process for a context . Since the container prefers to match the longest pattern , a URL that includes /Catalog/search/ always matches the mapping for catalogSearch rather than the mapping for catalogBrowse . <p> A mapping that contains the pattern **40;6405;TOOLONG matches a request if no other pattern matches . This is the default mapping . The servlet mapped to this pattern is called the default servlet . <p> The default mapping is often directed to the first page of an application . Explicitly providing a default mapping also ensures that malformed URL requests into the application return are handled by the application rather than returning an error . <p> The servlet-mapping element below maps the Welcome servlet instance to the default mapping . 
@@75677674 @4377674/ <h> 2.17 Contents of RWDBEnvironmentHandle <p> The DB Access Module for Sybase CT returns an environment handle that has the type **29;6447;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . In addition , this handle contains the CSCONTEXT pointer : <p> CSCONTEXT* cscontext() const ; <p> This pointer can be used to set or retrieve configuration parameters that are not directly supported by the environment handle . <p> The timeout() method defines the length of time in seconds that the Sybase Client-Library waits for a server response to a command : <p> CSINT timeout() const ; RWDBStatus timeout ( CSINT value ) ; <p> In the Sybase Client-Library documentation , the default is an infinite timeout period . The application can set this value any time . It takes effect for all open connections immediately upon being called . <p> The default value is 25 , according to the Sybase Client-Library documentation . This method has no effect if the maximum number of connections being set is less than the number of currently open connections . @ @ @ @ @ @ @ @ @ @ Module . <p> The textLimit() method defines the length in bytes of the longest text or image value an application is prepared to receive : <p> long textLimit() const ; RWDBStatus textLimit ( long value ) ; <p> The Sybase Client-Library will read but ignore any part of the text or image value that goes over the limit defined by this function . Refer to the Sybase Client-Library documentation for more information . <p> NOTE -- This method affects only the client side text limit , not the server side text limit for this connection . To change the server side limit , you must call ctoptions() directly . <p> Please see the Sybase Client-Library documentation for hidden keys semantics . The default behavior of the Sybase Client-Library is not to expose any hidden keys . Setting it to true will change the default behavior . <p> The noLongCharCapability() methods access and define the setting that will be used for the CSDATANOLCHAR capability in future connections . Setting this capability to CSTRUE disables the use of the CSLONGCHAR client type ( this is not a server side datatype ) . @ @ @ @ @ @ @ @ @ @ expand when copied from the client to the server . This may occur when CSDATANOLCHAR capability is set to CSFALSE . Try setting the capability to CSTRUE . <p> Each CSCONTEXT object has an associated CSLOCALE structure . The CSLOCALE structure stores the localization information that is used to process data and generate error messages by the CSCONTEXT object and the CSCONNECTION objects that it produces . <p> The CSLOCALE structure stores values for four locale properties : <p> CSLCCTYPE -- Character set to use for data type conversions . <p> CSLCCOLLATE -- Collating sequence to use when sorting and comparing character data . <p> CSLCTIME -- Date and time data representation to use for a datetime string , such as date and time formats , names in the native languages , and month and day abbreviations . <p> CSLCMESSAGE -- Language and character set to use for messages . <p> These definitions are taken from the Sybase International Developer 's Guide for Open Client/Server . <p> The values that can be set for these properties are the vendorlocale values specified in the locales.dat file in the directory &lt;Sybase home @ @ @ @ @ @ @ @ @ @ various locale values , please see Section 2.10 in this guide and the Sybase International Developer 's Guide for Open Client/Server . <p> The DB Access Module for Sybase CT provides three methods for accessing locales on the CSLOCALE structure . This CSLOCALE structure is associated with the CSCONTEXT structure encapsulated by the **29;6478;TOOLONG . Any changes on the CSLOCALE structure are only inherited by the future CSCONNECTION objects and do not affect the existing CSCONNECTION objects . The three methods for accessing locales on the CSLOCALE structure are : <p> RWCString localeProperty ( CSINT property ) const ; <p> Returns the value of the locale property . Any of the four locale properties can be specified as the parameter . <p> void localeProperty ( CSINT property , const RWCString&amp; value ) ; <p> Sets the locale property to the value specified . Any of the four locale properties or CSLCALL can be specified as the first parameter . If CSLCALL is used , it sets the value of all four locale properties . If the second parameter is passed as an empty string , it clears the value of @ @ @ @ @ @ @ @ @ @ ; <p> Sets the CSLOCALE structure of the CSCONTEXT to the one supplied . <p> The CSLOCALE structure must be preallocated using Sybase call cslocalloc() before making this call . Sybase copies the contents of the CSLOCALE structure into the CSCONTEXT . Hence , it is safe to drop the allocated structure after this call . <p> If the CSLOCALE* is passed in as NULL , it clears the CSLOCALE structure associated with the CSCONTEXT structure . 
@@75677676 @4377676/ <p> Iterator categories are hierarchical . Forward iterators can be used wherever input or output iterators are required , bidirectional iterators can be used in place of forward iterators , and random access iterators can be used in situations requiring bidirectionality . <p> A second characteristic of iterators is whether or not they can be used to modify the values held by their associated container . A constant iterator is one that can be used for access only , and can not be used for modification . Output iterators are never constant , and input iterators always are . Other iterators may or may not be constant , depending upon how they are created . There are both constant and non-constant bidirectional iterators , both constant and non-constant random access iterators , and so on . <p> The following table summarizes specific ways that various categories of iterators are generated by the containers in the standard library . <p> Input iterators are the simplest form of iterator . To understand their capabilities , consider an example program . The find() generic algorithm ( to be described in more detail @ @ @ @ @ @ @ @ @ @ ) , performs a simple linear search , looking for a specific value being held within a container . The contents of the container are described using two iterators , here called first and last . While first is not equal to last the element denoted by first is compared to the test value . If equal , the iterator , which now denotes the located element , is returned . If not equal , the first iterator is incremented , and the loop cycles once more . If the entire region of memory is examined without finding the desired value , then the algorithm returns the end-of-range iterator . <p> An iterator can be compared for equality to another iterator . They are equal when they point to the same position , and are otherwise not equal . <p> An iterator can be dereferenced using the * operator , to obtain the value being denoted by the iterator . <p> An iterator can be incremented , so that it refers to the next element in sequence , using the operator ++ . <p> Notice that these characteristics can all @ @ @ @ @ @ @ @ @ @ since the behavior of the given functions can all be modified by overloading the appropriate operators . Because of this overloading , iterators are possible . There are three main varieties of input iterators : <p> Ordinary pointers . Ordinary pointers can be used as input iterators . In fact , since we can subscript and add to ordinary pointers , they are random access values , and thus can be used either as input or output iterators . The end-of-range pointer describes the end of a contiguous region of memory , and the deference and increment operators have their conventional meanings . For example , the following searches for the value 7 in an array of integers : <p> Container iterators . All of the iterators constructed for the various containers provided by the standard library are at least as general as input iterators . The iterator for the first element in a collection is always constructed by the member function begin() , while the iterator that denotes the " past-the-end " location is generated by the member function end() . For example , the following searches for the @ @ @ @ @ @ @ @ @ @ : : iterator where = find ( aList.begin ( ) , aList.end() , 7 ) ; <p> Each container that supports iterators provides a type within the class declaration with the name iterator . Using this , iterators can uniformly be declared in the fashion shown . If the container being accessed is constant , or if the description constiterator is used , then the iterator is a constant iterator . <p> Input stream iterators . The standard library provides a mechanism to operate on an input stream using an input iterator . This ability is provided by the class istreamiterator , and will be described in more detail in Input Stream Iterators . <p> An output iterator has the opposite function from an input iterator . Output iterators can be used to assign values in a sequence , but can not be used to access values . For example , we can use an output iterator in a generic algorithm that copies values from one sequence into another : <p> Two ranges are being manipulated here ; the range of source values specified by a pair of input iterators @ @ @ @ @ @ @ @ @ @ , is specified by only a single argument . It is assumed that the destination is large enough to include all values , and errors will ensue if this is not the case . <p> As illustrated by this algorithm , an output iterator can modify the element to which it points , by being used as the target for an assignment . Output iterators can use the dereference operator only in this fashion , and can not be used to return or access the elements they denote . <p> As we noted earlier , ordinary pointers , as well as all the iterators constructed by containers in the standard library , can be used as examples of output iterators . ( Ordinary pointers are random access iterators , which are a superset of output iterators . ) So , for example , the following code fragment copies elements from an ordinary C-style array into a standard library vector : <p> Just as the istreamiterator provided a way to operate on an input stream using the input iterator mechanism , the standard library provides a data type , ostreamiterator , @ @ @ @ @ @ @ @ @ @ in an iterator-like fashion . These will be described in Output Stream Iterators . <p> Yet another form of output iterator is an insert iterator . An insert iterator changes the output iterator operations of dereferencing/assignment and increment into insertions into a container . This permits operations such as copy() to be used with variable length containers , such as lists and sets . Insert iterators will be described in more detail in Insert Iterators . <p> A forward iterator combines the features of an input iterator and an output iterator . It permits values to both be accessed and modified . One function that uses forward iterators is the replace() generic algorithm , which replaces occurrences of specific values with other values . This algorithm is written as follows : <p> Ordinary pointers , as well as any of the iterators produced by containers in the standard library , can be used as forward iterators . The following , for example , replaces instances of the value 7 with the value 11 in a vector of integers . <p> A bidirectional iterator is similar to a forward iterator , @ @ @ @ @ @ @ @ @ @ -- ) , permitting movement in either a forward or a backward direction through the elements of a container . For example , we can use bidirectional iterators in a function that reverses the values of a container , placing the results into a new container . <p> Some algorithms require more functionality than the ability to access values in either a forward or backward direction . Random access iterators permit values to be accessed by subscript , subtracted one from another ( to yield the number of elements between their respective values ) or modified by arithmetic operations , all in a manner similar to conventional pointers . <p> When using conventional pointers , arithmetic operations can be related to the underlying memory ; that is , x+10 is the memory ten elements after the beginning of x . With iterators the logical meaning is preserved ( x+10 is the tenth element after x ) , however the physical addresses being described may be different . <p> Algorithms that use random access iterators include generic operations such as sorting and binary search . For example , the following algorithm @ @ @ @ @ @ @ @ @ @ similar to , although simpler than , the function randomshuffle() provided by the standard library . <p> The program will cycle as long as first is denoting a position that occurs earlier in the sequence than the one denoted by last . Only random access iterators can be compared using relational operators ; all other iterators can be compared only for equality or inequality . On each cycle through the loop , the expression last - first yields the number of elements between the two limits . The function randomInteger() is assumed to generate a random number between 0 and the argument . Using the standard random number generator , this function could be written as follows : <p> An iterator naturally imposes an order on an underlying container of values . For a vector or a map the order is given by increasing index values . For a set it is the increasing order of the elements held in the container . For a list the order is explicitly derived from the way values are inserted . <p> A reverse iterator will yield values in exactly the reverse order @ @ @ @ @ @ @ @ @ @ , for a vector or a list , a reverse iterator will generate the last element first , and the first element last . For a set it will generate the largest element first , and the smallest element last . Strictly speaking , reverse iterators are not themselves a new category of iterator . Rather , there are reverse bidirectional iterators , reverse random access iterators , and so on . <p> The list , set and map data types provide a pair of member functions that produce reverse bidirectional iterators . The functions rbegin() and rend() generate iterators that cycle through the underlying container in reverse order . Increments to such iterators move backward , and decrements move forward through the sequence . <p> Similarly , the vector and deque data types provide functions ( also named rbegin() and rend() ) that produce reverse random access iterators . Subscript and addition operators , as well as increments to such iterators move backward within the sequence . 
@@75677680 @4377680/ <h> Faster delivery of secure , reliable , and conformant code <p> As teams develop code with more features , shorter timelines , and stricter standards than ever before , it gets increasingly difficult to find bugs and fix security flaws . With this complexity , how do we stop data breaches and application crashes before they 're passed on to the customer ? How do we find them earlier in the process , so developers can spend more time creating real value for the customer rather than fixing defective code ? <p> It starts at the developer 's desktop . It 's here where code is written , tested , reviewed , and written again . Finding problems here , at the earliest possible point before the build , means less testing later on and fewer downstream impacts to cost and schedule . It continues with Continuous Integration ( CI ) , only Klocwork supports popular CI tools to perform analysis on incremental code changes , during check in , to keep pace with rapid release delivery cycles . Klocwork puts static code analysis where you need it @ @ @ @ @ @ @ @ @ @ issues in front of developers ' eyes - before , during , and after check in. 
@@75677683 @4377683/ <p> By collaborating with our technology partners , both companies can offer our mutual customers optimized solutions for the next generation of high performance computing . <h> Rogue Wave Premier Partners <p> Intel <h> Rogue Wave Strategic Partners <h> Rogue Wave Platform Partners <p> See the list of Resellers and Distributors that we 've certified to be able to sell and support our products in markets where we do n't have a direct company presence . <p> Our programs provide our partners with the resources and support they need to meet their long-term business goals . To inquire about becoming a Rogue Wave partner , please email us at **30;6509;TOOLONG 
@@75677684 @4377684/ <p> Notice that errors with a severity level of 0 are given special handling when such errors occur , the RWDBStatus : : errorCode is set to RWDBStatus : : ok , the rest of the RWDBStatus is populated , and the application 's error handler ( if any ) is invoked . This means that DBTools.h++ applications will ignore these errors by default , but can process them if necessary . It also means that your error handler should check vendorError2 ( severity ) before raising an exception . <p> The following format shows how RWDBStatus reports messages from SQL Server : <p> errorCode : serverError , unless ( 1 ) severity and message number are both 0 , or ( 2 ) message number is one of : 5701 , 5703 , 5704 . In either case , errorCode is set to RWDBStatus : : ok , and the user-installed error handler is invoked . <p> message : If severity is not 0 , Server Error : %s , where %s is the text of the SQL Server message ( msgtxt ) . Otherwise message is the @ @ @ @ @ @ @ @ @ @ Server reporting the error ( srvname ) . <p> vendorMessage2 : Unused . <p> vendorError1 : SQL Server message number ( msgno ) . <p> vendorError2 : The error 's severity level ( severity ) . <p> Notice that RWDBStatus provides special handling for messages that result from SQL PRINT statements ( in which both severity and message number are 0 ) and for " context switch " messages ( for example , " Changed database context to master " ) . When these messages occur , the RWDBStatus : : errorCode is set to RWDBStatus : : ok , the rest of the RWDBStatus is populated , and the application 's error handler ( if any ) is invoked . Since , in such cases , errorCode is ok , DBTools.h++ applications will ignore these errors by default . However , the error information itself is still accessible if the application needs to check it . Your error handler should check vendorError2 ( severity ) before raising an exception . 
@@75677685 @4377685/ <h> 1.3 Tools.h++ and the Standardization of C++ <p> Almost everybody sees the benefits of standardizing the C++ language and the Standard C++ Library . The trick is to keep working during the process . We call this a period of transition , and the C++ community is engaged in it now . <p> Here is what the transition looks like : a standard nearing completion , but not yet fully stable . Although the standard itself is unlikely to be substantially revised , the fine tuning and ratification will continue into 1997 . <p> And here is what the transition looks like : compilers evolving toward the standard at various rates . For a time , you will find new language featuressuch as namespaces , default template arguments , member function templates , nested class templatessupported on some compilers and not others . Some compilers may not even include a version of the Standard C++ Library ; many will offer versions which conform to the standard only so far as they support the necessary language features . It will be some time before commercial compilers actually implement the @ @ @ @ @ @ @ @ @ @ as described in the standard . <p> Finally , here is what the transition looks like : you , the developer , and what you 're going through now . You are the one evolving designs and implementations toward the emerging standard . Change will come at rates determined by your development environment , application domain , and corporate culture . <p> Our goal for Tools.h++ is to help you to maintain consistency in your development while moving , at your own pace , along the path of the latest C++ technology . <p> The primary challenge of this new version of Tools.h++ was to establish our relationship with the ANSI/ISO Standard C++ Library . Rogue Wave is committed not only to bringing our products into compliance with the standard , but to harnessing its full power . The object is to provide you with even more useful and efficient class libraries . The process of integrating our libraries with the C++ standard begins here with Tools.h++ Version 7 . <p> For this version of Tools.h++ , we have concentrated our integration efforts on the Standard C++ Library containers , @ @ @ @ @ @ @ @ @ @ . Each of the standard containers has been wrapped with a new or re-engineered Tools.h++ collection class template . You 'll find a full explanation of templates in Section 11 . Following are the major design goals for our integration of Tools.h++ and the Standard C++ Library , along with examples of how they are reflected in this version : <p> Design Goal : Leverage <p> To offer greater value by taking advantage of the Standard C++ Library to build upon a higher foundation than the base C++ language . <p> For example , Tools.h++ offers collections that use Standard C++ Library containers for their implementations . Building Tools.h++ upon the standard enables these collections to easily supply standard iterators , which in turn allows them to be used with the rich set of Standard C++ Library algorithms . At the same time , you retain the safe , easy-to-use , object-oriented interface that Tools.h++ collections have always provided . <p> Design Goals : Interoperability <p> To support one of the primary benefits of the C++ standard , which is to allow libraries , modules , classes , and algorithms @ @ @ @ @ @ @ @ @ @ level . <p> For example , we made sure you can safely and efficiently pass a Tools.h++ doubly-linked list where a Standard C++ Library list is expected . <p> Design Goal : Freedom <p> To maintain access to the Standard C++ Library . <p> For example , when using a Tools.h++ collection implemented with a Standard C++ Library container , you are always free to drop down to the level of the implementation that takes advantage of the non-object-oriented features of the Standard C++ Library . <p> Design Goal : Object-orientation <p> To enhance the Standard C++ Library with efficient , object-oriented interfaces . <p> All our new and re-engineered collection class templates exemplify this goal . In each case , we have put an efficient wrapper around a corresponding Standard C++ Library container to provide a familiar , though expanded , Tools.h++ collection interface . <p> Design Goals : Simplicity and Safety <p> To enhance the Standard C++ Library with a simpler interface , which reduces risk and makes client code easily maintainable . <p> The object-oriented interface helps achieve this goal . Unlike the Standard C++ Library , @ @ @ @ @ @ @ @ @ @ freeing the user from the need to specify iterators and algorithms . <p> Design Goal : Compatibility <p> To protect our customers ' investment in code written with previous versions of Tools.h++ . <p> For example , we have re-engineered the Tools.h++ Version 6.1 collection class templates to base them on Standard C++ Library containers . In almost all cases , your existing source code that used classes in the previous version of the library will compile with the new library without modification . <p> Design Goal : Smooth Transition <p> To provide the means for developers to begin moving along the path toward standard C++ at their own pace and with minimal hassle . <p> For example , you can use Tools.h++ with or without the Standard C++ Library . If your development environment supports a version of the Standard C++ Library certified for use with Tools.h++ , we offer 28 new or re-engineered class templates implemented using the Standard C++ Library container classes . If you do n't have the Standard C++ Library , we offer you a subset interface to many of the same class templates , @ @ @ @ @ @ @ @ @ @ The appropriate implementation is selected automatically and transparently at compile time . By coding to the more restricted interface , you will be able to take full advantage of the Standard C++ Library as soon as it becomes available to you . <p> Future versions of Tools.h++ will make full use of the Standard C++ Library and other newly added features of the C++ language . This version includes several areas where we have elected to wait before incorporating the latest available technology . In some cases , we 're waiting until the standard library or language feature is more widely available . In other cases , frankly , we 're waiting until we gain more experience with the new features to see how we can best mold them into a unified and effective whole . We want to be careful not to commit ourselves and our customers to less than optimal patterns of usage . In the meantime , we 'd like to draw your attention to the following areas : <p> Tools.h++ continues to use classes RWCString and RWWString . These classes , along with their substring classes @ @ @ @ @ @ @ @ @ @ been considered among the most useful and powerful classes in the library . This suite of functionality is not offered by the Standard C++ Library . You may use the C++ standard string and wstring in your applications , but you may occasionally incur the overhead of copying if you must convert between Tools.h++ and standard strings . <p> Tools.h++ continues to use class RWLocale . At the time of this release , the C++ standard locale class specification is still undergoing review by the ANSI/ISO standards committees . <p> Exception Hierarchy <p> Tools.h++ continues to use its own exception hierarchy , which is similar to the exception hierarchy in the draft C++ Standard . We do n't expect to change over until the standard exception hierarchy is more widely available . You are free to use standard exceptions in your application , but you must be prepared also to catch Tools.h++ exceptions when making calls into the Tools.h++ library from within your try blocks . <p> Namespaces <p> Tools.h++ is not yet using or attempting to use namespaces specified by the current draft . For now , we continue @ @ @ @ @ @ @ @ @ @ the global namespace . Of course , this does not preclude you from using namespaces in your own application , if your compiler allows it . 
@@75677687 @4377687/ <p> This step shows how to get the value of a property of the control . The code is based on the property Day of the Calendar control . You will have to modify the name of the property and its type if you choose another property and/or another control . <p> We will just modify slightly the code of step3 so that the GetTypeAccelerator also displays the value of the property Day when the control type is Calendar . <p> To do this , we replace the line : <p> IlvCOut &lt;&lt; " The type is : " &lt;&lt; userType &lt;&lt; " . n " ; <p> by the first line below : <p> IlvCOut &lt;&lt; " The type is : " &lt;&lt; userType ; <p> // Code added for step 5 . <p> if ( ! wcscmp ( userType , L " Calendar " ) ) <p> IlvValue value ( " Day " ) ; <p> IlInt day = **27;6541;TOOLONG ; <p> IlvCOut &lt;&lt; " , the day is : " &lt;&lt; day ; <p> <p> IlvCOut &lt;&lt; " . n " ; <p> After having checked @ @ @ @ @ @ @ @ @ @ an IlvValue object whose name is the name of the property ( Day in this case ) is instantiated . Then the value of this property is obtained by calling queryValue on the IlvGraphicCOMAdapter object ( as for any value object in Rogue Wave Views ) . Then the value is displayed with IlvCOut . <p> You see that it is very easy to access a property and to get its value . To modify its value would also be simple . For example , to set the Day property to 5 , you would write : 
@@75677688 @4377688/ <p> The Root Window 's layout enables you to modify the grouping parameters while viewing the results . <p> Figure 63 " Root Window and Process/Thread Display <p> Figure 63 illustrates a 17-process MPI job comprised of a single MPI starter process , e.g. , mpiexec ( p1 ) , and 16 MPI processes ( 0-15 ) . At the highest level , processes are grouped by Process State , then by Function . The individual groupings are then sorted in ascending order ( Members ) by the process I 'd . <p> Configure : Show or hide the configuration panel on the right using the Configure button or the View &gt; Show Configure Panel menu item . <p> Move Up and Move Down : By default , the properties are displayed in a hierarchical manner , such that the property at the top of the Configuration Panel forms the highest level grouping , the next property forms the second level of grouping subordinate to the first , and so on . Use Move Up and Move Down to control where to display a property in the hierarchy . <p> @ @ @ @ @ @ @ @ @ @ automatically saved across TotalView sessions . To revert to the default order , press Reset . <p> Nested Attributes : Instead of the default hierarchical display , the properties can be " flattened " into a single line in which each property is separated by a colon , using the View &gt; Nested Attribute menu item . This menu item toggles between the hierarchical and flat display modes . <p> Show MPI Rank : For MPI jobs , TotalView shows by default the rank in MPICOMMWORLD of MPI processes in the compressed ptlist in the Members column . Non-MPI processes are shown using the " pdpid " where dpid is the debugger process I 'd of the process . Use the View &gt; Show MPI Rank menu item to toggle between displaying MPI processes using the MPI rank or " pdpid " notation . <p> Copy/Select All : To copy data to an external program , use the clipboard : Select one or more rows using your computer 's keyboard shortcuts , or select Edit &gt; Select All , and copy to the clipboard using Edit &gt; Copy . <p> Default @ @ @ @ @ @ @ @ @ @ Group , Process State , Function and Thread I 'd in a hierarchical or " nested " manner . <p> Since there is only one control group in the debug session , the control group has been omitted , and the Process state becomes the top-level property , in this case displaying two process states . <p> Breakpoint : The first grouping lists the MPI starter process in Breakpoint process state , stopped in function MPIRBreakpoint , and one thread with thread I 'd 1.1 . The Procs column shows the number of processes , and the Threads column shows the number of threads displayed in the Members column . The Members column shows the dpid the process and dpid.dtid of the threads , displayed as a compressed process/thread list ptlist . <p> Stopped : This grouping displays all processes in a Stopped process state , of which there are 32 , the MPI job size . The membership shows 0-31 , which means MPI ranks 0 to 31 , inclusive . <p> Changing the Display <p> To change the view , select the Configure &lt;&lt; button and select or de-select properties @ @ @ @ @ @ @ @ @ @ Line property is selected . <p> . <p> Figure 65 " Root Window : Configure Pane , Group by Source Line <p> In this example , we 've de-selected Process State , Function , and Thread I 'd and selected Source Line in order to group by Source Line instead . <p> Because Source Line is a thread property , the Members column now displays only threads . Here are the three lines : <p> Line 1 is the mpirun process used to launch the txbasicmpi mpi program . <p> Line 2 displays all the threads at Line 100 in the source file txbasicmpi.c . The membership is 0.1 , which means thread ( dtid ) 1 in MPI rank 0 . <p> Line 3 displays all the threads that are at line 112 inside that same file , representing the remaining 30 threads . <p> Note that even though the Control Group is selected , it has no grouping effect most of the time and is relevant only for debugging multiple jobs at once ( which is uncommon ) , in which case the window would display a separate top-level @ @ @ @ @ @ @ @ @ @ and Source Line <p> If you select Thread State , leaving Source Line also selected , you can group by both properties , as in Figure 66 . <p> Figure 66 " Root Window : Grouped by Status and Source Line <p> Again , there are two groupings in the list : the first is the mpirun process . Note that the second grouping is now multi-line : <p> The first line of the second grouping displays a single thread , showing both that its status is at Breakpoint and that it is at line 100 in txbasicmpi.c . <p> The second line displays 31 threads , all at a different Breakpoint at line 112 in txbasicmpi.c. 
@@75677692 @4377692/ <h> 2.11 Error Messages : Contents of RWDBStatus <p> Sybase Client-Library distinguishes between errors originating from Adaptive Server and errors generated within Client-Library and CS-Library . DBTools.h++ honors the distinction by assigning error code serverError to errors from Adaptive Server , and error code vendorLib to errors from Client-Library and CS-Library . <p> The format that RWDBStatus uses to report errors from Client-Library and CS-Library follows this paragraph . Notice that errors with a severity level of zero are given special handling : the RWDBStatus : : errorCode is set to RWDBStatus : : ok , the rest of the RWDBStatus is populated , and an application 's error handler ( if any ) is invoked . This means that DBTools.h++ applications will ignore these errors by default , but an application can process them if necessary . It also means that the error handler for the application should check vendorError2(severity) before raising an exception . <p> errorCode : RWDBStatus : : vendorLib , unless the severity is zero , as rated by Client-Library or CS-Library . If severity is zero , errorCode is set to RWDBStatus : : @ @ @ @ @ @ @ @ @ @ <p> message : Vendor Library Error : %s , where %s is the error text from Client-Library or CS-Library ( CSCLIENTMSG.msgstring ) . <p> vendorMessage1 : The text reported by Client-Library or CS-Library as an operating system error , if any ( CSCLIENTMSG.osstring ) . <p> vendorMessage2 : The text that describes the error ( CSCLIENTMSG.sqlstate ) . Not all client messages have state values associated with them . <p> vendorError1 : The Client-Library or CS-Library error number ( CSCLIENTMSG.msgno ) . <p> vendorError2 : The error 's severity level ( CSCLIENTMSG.severity ) . <p> Sybase Client-Library error messages are made available only in debug mode ; CS-Library errors are available in all build types . <p> The following format shows how RWDBStatus reports messages from Adaptive Server . Notice that RWDBStatus provides special handling for messages that result from SQL PRINT statements ( in which both severity and message number are 0 ) and for context switch messages ( for example , Changed database context to master ) . When these messages occur , the RWDBStatus : : errorCode is set to RWDBStatus : : ok , the rest @ @ @ @ @ @ @ @ @ @ error handler ( if any ) is invoked . Because errorCode is RWDBStatus : : ok , DBTools.h++ applications will ignore these errors by default . However , the error information itself is still accessible if the application needs to check it . The error handler should check vendorError2 ( severity ) before raising an exception . <p> errorCode : RWDBStatus : : serverError , unless : <p> severity and messagenumber are both zero , or <p> messagenumber is one of : 5701 , 5703 , 5704 . <p> In either case , errorCode is set to RWDBStatus : : ok , and the user-installed error handler is invoked . <p> message : If severity is not zero , Server Error : %s else Server Messages , where %s is the text of the server message ( CSSERVERMSG.msgtext ) . <p> vendorMessage1 : Name of the server reporting the error ( CSSERVERMSG.srvname ) . <p> vendorMessage2 : The text describing the **27;6570;TOOLONG . Not all client messages have state values associated with them . 
@@75677693 @4377693/ <h> API Security <p> Enterprises are reshaping their business models to address the new digital economy by making data and applications available as APIs for consumption in mobile applications , cloud applications and Internet of Things ( IoT ) . While APIs connect enterprises with mobile apps and a large community of developers , these APIs also need to be scalable , reliable , and most importantly secure . As these businesses start monetizing their resources through digital channels they need to become more vigilant about security and complaince and prevent their APIs against threats and hacks . <p> The Akana API Security solution streamlines management , deployment , development and operation of APIs , enhancing security and regulatory compliance through authentication , authorization and audit capabilities . The Akana API Gateway , deployed at the edge of the network to provide perimeter security and defence , protects the enterprise by handling authentication and authorization , encrypting data , preventing threats and attacks and rate limiting traffic . The API Gateway can be deployed in the cloud or on-premises . <h> Authentication and Authorization <p> Choose from a wide @ @ @ @ @ @ @ @ @ @ ensure that only valid users and applications get access <p> Integrate with leading identity and access management providers or use the built-in access control system <h> Threat Protection <p> Provide a content firewall , protecting against malicious content including protection against viruses in attachments and validation of message content XML and JSON data structure , form and query parameters . <p> Analytics Dashboards and out-of-the-box reports provide visibility into the performance of APIs and services from different perspectives , including department , partner , application contract , API/service or operation <h> Learn More <p> Learn about the necessary components of a well-constructed API security strategy . Understand API risk assessment , the various attack vectors that could potentially make your API vulnerable , and risk mitigation strategies to avoid API hacks . <p> In this webinar , we will walk you through the various aspects of how an API could be potentially exploited . We will discuss the necessary best practices to secure your data and enterprise applications while continue continuing to support your businesss digital initiatives . 
@@75677695 @4377695/ <p> A runnable object provides the basic mechanisms used to create , control , and monitor the threads of execution within your application . Runnables are used to define the task or activity to be performed by a thread . <p> Each runnable object is reference-counted ; a runnable body instance keeps a count of the number of handles that currently reference it . A runnable object is deleted when the last handle that references the body is deleted . <p> The public interface for a runnable is provided by its handle classes . Many of the public functions in a handle simply forward control to a corresponding protected function in the body class . A runnable handle class instance may be empty . Any attempt to use an empty handle to access a runnable will produce an RWTHRInvalidPointer exception . <p> The RWRunnable class provides an interface for threads executing outside a runnable . It defines the runnable member functions that may only be executed by an external thread . The thread executing inside of a runnable should access the runnable using the RWRunnableSelf handle class . The @ @ @ @ @ @ @ @ @ @ either inside or outside of a runnable . <p> You may convert an RWRunnableSelf handle into an RWRunnable handle by calling the RWRunnableSelf : : getRunnable() member , but any attempt to violate the thread access restrictions imposed by the separate interfaces will generally result in an RWTHRIllegalAccess exception . <p> The runnable object represented by an RWRunnable is executed by calling start() . A protected virtual run() member defines the work or activity to be performed by the runnable object . The start() member defines the form of dispatching to be used in executing the run() member , synchronous or asynchronous . Regardless of the dispatching mechanism , the run() member is always executed as a consequence of calling start() . <p> In a synchronous runnable , the thread that calls start() is the same thread that executes run() ; the flow of control is simply passed internally from the start() member to the run() member . By the time the start() function returns , the runnable will have completed , or at least attempted , to perform its specified task . <p> In an asynchronous , or threaded @ @ @ @ @ @ @ @ @ @ of a new thread of execution . Following creation , this new thread proceeds to execute the run() member , freeing the thread that called start() to move on to other things . <p> Only one thread can execute within a runnable at any time . Any attempt to call start() while a thread is executing within the runnable will result in an RWTHRThreadActive exception in the scope of the caller . <p> Once a runnable has been started , a any thread can wait for that runnable object to finish by calling the runnable 's join() member . <p> If an exception occurs and is propagated out of a runnable 's run() member , the runnable will catch the exception and store it . Clients of the RWRunnable class can rethrow this exception using the raise() member . <p> Clients of RWRunnable can request cancellation of an active runnable or interrupt the runnable 's execution . RWRunnable also provides wait functions that allow another thread to block until the runnable enters an execution state of interest . <p> Returns an internal interface bound to the same runnable instance , @ @ @ @ @ @ @ @ @ @ getNestedRunnable(void) const ; <p> Returns a handle to the nested runnable object , if any . Possible exceptions include RWTHRInvalidPointer and RWTHRInternalError . <p> void join(void) ; <p> Waits for this runnable to complete execution . Returns immediately if the runnable has already been started and has completed and is currently inactive . Waits for the runnable to start and then complete if it has never been started . If the runnable object is going to be restarted , this function should be used with care by threads other than the thread starting the runnable ; user code will need to synchronize the threads starting the runnable with the threads joining the runnable so that joining threads will know which iteration they are joining . Possible exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , and RWTHRInternalError . <p> RWWaitStatus join ( unsigned long milliseconds ) ; <p> Waits for this runnable to complete execution or until expiration of the specified timeout period . Returns immediately if the runnable has already been started and completed and is currently inactive . Waits for the runnable to start and then complete if it has never @ @ @ @ @ @ @ @ @ @ be restarted , this function should be used with care by threads other than the thread starting the runnable , so that joining threads will know which start operation they are joining . Possible exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , and RWTHRInternalError . <p> void raise(void) const ; <p> Throw the exception , if any , stored by the runnable during execution of the associated code . This function simply returns if no exception was produced during the most recently completed execution of this runnable . <p> void releaseInterrupt(void) ; <p> Reactivates a thread executing within the runnable which had been interrupted via requestInterrupt() . This function restores the execution state of the runnable to the state it was in prior to being interrupted . Possible exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , RWTHRThreadActive , and RWTHRInternalError . <p> RWWaitStatus **25;6599;TOOLONG ; <p> Requests and waits for the runnable to cancel itself . Cancellation starts when the thread running within the runnable instance calls serviceCancellation() . <p> This function returns RWTHRCOMPLETED to indicate that the runnable was canceled , exited , or was not active anyway . It returns RWTHRABORTED to @ @ @ @ @ @ @ @ @ @ exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , and RWTHRInternalError . <p> A cancellation request can not be withdrawn ; a runnable will stay marked as canceled until the next time start() is called . <p> RWWaitStatus **28;6626;TOOLONG long milliseconds ) ; <p> Requests and waits for the runnable to cancel itself or until the specified amount of time has passed . This member returns RWTHRCOMPLETED to indicate that the runnable was canceled , exited , or was not active anyway ; RWTHRABORTED to indicate that cancellation started but did not complete ( the cancellation exception was caught and destroyed in a catch-block ) ; or RWTHRTIMEOUT to indicate that the time-out period elapsed before the runnable completed cancellation . <p> If the cancellation request times out , then the execution state may not have changed at all , or may have changed to RWTHRCANCELING , in which case , cancellation has already started , and may yet abort or succeed . A cancellation request can not be withdrawn ; a runnable will stay marked as canceled until the next time start() is called . <p> This function requests the thread executing @ @ @ @ @ @ @ @ @ @ is serviced . To respond to the request for an interrupt , the thread executing within the runnable must call serviceInterrupt() . The interrupted thread is blocked inside the serviceInterrupt() call until some other thread releases the interrupt by calling releaseInterrupt() . <p> This function returns RWTHRABORTED if the runnable is not active when the call is made . It returns RWTHRACQUIRED if the runnable was successfully interrupted . A return value of RWTHRACQUIRED does not guarantee that the runnable will be in an interrupted state at the point of return . Since any thread may release a runnable from an interrupt , it is possible for a different thread to release the interrupt before this function returns . If the interrupt is serviced , the execution state will change to RWTHRINTERRUPTED until the interrupt is released . <p> Same as the previous function except that the user limits the time the calling thread will wait by specifying a waiting interval of milliseconds . If the specified interval expires before the interrupt is serviced , this function returns RWTHRTIMEOUT . Possible exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , and RWTHRInternalError . @ @ @ @ @ @ @ @ @ @ object . For synchronous implementations ( for example , RWRunnableFunction ) the associated code will execute synchronously within the runnable object and this function will wait for the associated code to complete before returning . For asynchronous implementations ( for example , RWThreadFunction ) the associated code will run asynchronously within the runnable and this function will return immediately . Calling start() changes the execution state to RWTHRSTARTING , then for synchronous runnables , changes it to RWTHRRUNNING . Asynchronous runnables enter the RWTHRINTERRUPTED state shortly before starting , and are then automatically or manually released to RWTHRRUNNING . <p> Waits until the runnable object enters an execution state referenced by the mask . The mask is a union of states which will cause wait() to unblock and return . The value returned is the execution state value that satisfied the specified mask . Possible exceptions include RWTHRInvalidPointer , RWTHRIllegalAccess , and RWTHRInternalError . <p> Waits until the runnable object enters a state contained in the mask , or until the time-out period of milliseconds has elapsed . The mask is a union of states which will cause wait() to @ @ @ @ @ @ @ @ @ @ prior to the expiration of the time-out period , this member will write the state value that satisfied the wait in the state argument location ( if not rwnil ) , and returns a value of RWTHRSIGNALED . If the time-out period elapses without a state change that satisfies the mask , then the function returns RWTHRTIMEOUT without changing the storage specified by the state argument . 
@@75677696 @4377696/ <h> 8.4 The MIME Package Representation of a Message <p> This section describes the structure of the MIME package representation of a message . <p> Figure 15 shows an informal diagram of a multipart message that contains single part MIME parts . Note that this diagram contains only the most important information . In particular , the diagram does not illustrate the details of the RWMimeHeader class . <p> The message itself is represented as an instance of RWMimeMultipart . A multipart holds three things : a collection of RWMimeHeader objects , a collection of RWMimePart objects , and an RWCString preamble . The part body collection and the header collection may be empty . The preamble is always present , but may be an empty string . <p> Each RWMimePart itself contains a collection of headers and a part body . For a simple MIME part , the part body is an RWCString . <p> The MIME message in Figure 16 contains two MIME parts . The first part is text intended for display in an email reader . The second is an attached text file . <p> @ @ @ @ @ @ @ @ @ @ this message as an instance of RWMimeMultipart . The instance holds an RWMimeHeader object for each header in the message -- in this case , 6 objects . The preamble of the multipart , an RWCString , contains this text : <p> If you are reading this text , your mailer does not understand MIME multipart attachments . <p> The message holds two RWMimePart objects . The first part contains a single header and the RWCString part body <p> This text forms the body of the email message in a MIME-compliant email viewer . 
@@75677698 @4377698/ <p> The first field of each line is a tag to identify the type of line . The possible tags are as follows : <p> Tag <p> Description <p> version <p> build specification format version <p> jspconfig <p> optional application server settings <p> jspcompile <p> the web applications to analyze <h> version line <p> The version line is used to define the build specification format version . It must be the first line in the build specification . Only one version line may appear in a build specification . <p> Example version line : <p> version ; 105 <p> Version 1.4 or later indicates that the build specification was generated using a source encoding of UTF-8 , allowing multibyte characters ( for example , Japanese ) . To ensure that kwbuildproject processes the build specification with UTF-8 encoding , the version must be version ; 104 or later . <h> jspconfig line <p> The jspconfig line is used to identify a non-default application server . If no application server was specified in the kwwebappscan command line , the jspconfig line will look like this : <p> jspconfig ; config1 @ @ @ @ @ @ @ @ @ @ specified in the kwwebappscan command line : 
@@75677700 @4377700/ <h> 16.3 Challenges of Localizing Currencies , Numbers , Dates , and Times <p> If you write applications for cultures other than your own , you will soon confront the challenges of representing currencies , numbers , dates , and times . Currencies vary in both unit value and notation . Numbers are written differently ; for example , Europe and the United States use periods and commas in opposite ways . Often a program must display values in notations customary to both vendor and customer . <p> Scheduling , a common software function , involves time and calendar calculations . Local versions of the Gregorian calendar use different names for days of the week and months , and different ordering for the components of a date . Time may be represented according to a 12- or 24-hour clock , and further complicated by time zone conventions , like daylight-saving time ( DST ) , that vary from place to place , or even year to year . <p> The Standard C Library provides &lt;locale.h&gt; to accommodate some of these different formats , but it is incomplete . It @ @ @ @ @ @ @ @ @ @ , and almost no help for conversions involving two or more locales . Common time zone facilities , such as those defined in POSIX.1 ( see the Appendix ) , are similarly limited , usually offering no way to compute wall clock time for other locations , or even for the following year in the same location . 
@@75677704 @4377704/ <h> 2.11 Error Messages : Contents of RWDBStatus <p> Oracle does not distinguish between errors originating from the server and errors generated within OCI itself . All errors are reported in the same manner , without classification . DBTools.h++ follows the Oracle error processing by always assigning the error code RWDBStatus : : serverError . In all cases , the application 's error handler will not be invoked unless there is an error . <p> The format of an RWDBStatus error report from an Oracle Server appears below . The RWDBStatus : : message contents are obtained by converting the return code into the appropriate message through the oerhms() call of OCI . <p> errorCode : serverError . <p> message : " ServerError : %s " , replacing %s with the text from the oerhms() call . <p> vendorMessage1 : Name of the Oracle Server reporting the error , as initially provided by the application when RWDBDatabase is instantiated . <p> vendorMessage2 : Unused . <p> vendorError1 : Return code from the OCI library . <p> vendorError2 : Operating system error code from the OCI library , or zero if there is no operating system error code . 
@@75677705 @4377705/ <h> 9.2 Message Patterns in WSDL <p> The W3C WSDL Specification defines four message patterns to support four types of operations : <p> Request-response <p> One-way <p> Notification <p> Solicit-response <p> Given the definition of the input and output messages for the operation in the WSDL file , HydraExpress generates the appropriate code for all four message patterns . <p> This section discusses each message pattern , with an introduction to the WeatherSummary.wsdl that is used for illustration . It also includes a brief discussion on synchronous and asynchronous behavior as it relates to message patterns . <p> The Weather Summary service represents a centralized provider of weather condition data for some number of zip code locations in some area . <p> A client , or individual , requests weather data based on a zip code , and the service provides it , through the request-response operation . <p> Participating zip code locations send updated weather data to the service when local conditions change , using the one-way operation . <p> Clients can subscribe to receive notification of changed conditions through the notification operation . <p> Finally , the @ @ @ @ @ @ @ @ @ @ wishes to continue receiving notifications , through the solicit-response operation . <p> To complete this scenario , there should be another request-response operation that allows a zip code location to either subscribe or unsubscribe from the notification service , receiving a confirmation message in reply . This operation has been left out for the sake of simplicity . <p> The operation getSummary contains an input message getSummary , which is the client request , and an output message getSummaryResponse , which is the server response . The contents of these messages are then defined in the WSDL 's message element : <p> The message getSummary contains one part , a zipcode of type xsd:string . The client request thus provides a zipcode to the server . <p> The message getSummaryResponse contains one part , a weatherData object of type wsx:WeatherSummary . Based on the zipcode , the server return an XML WeatherSummary element for the location specified by the zipcode . <p> The implementation of this pattern occurs in the client-side WeatherSummaryClient.cpp , a sample implementation that uses the generated class in WeatherSummaryProxy.cpp , and in the server-side WeatherSummaryImp.cpp , @ @ @ @ @ @ @ @ @ @ response . <p> The message contains a WeatherSummary element that provides updated weather conditions for the zip code . <p> The implementation of this pattern occurs in the client-side WeatherSummaryClient.cpp , a sample implementation that uses the generated class in WeatherSummaryProxy.cpp , and in the server-side WeatherSummaryImp.cpp , the server implementation that receives the request . <p> This pattern is implemented on the server side by WeatherSummaryImp.cpp which makes the call to the weatherNotification() operation method in the server-side notification proxy **35;6656;TOOLONG , and on the client side in **33;6693;TOOLONG , which sets up a listener on the client to receive the notification . <p> For an additional examples on the notification pattern , see Chapter 10 , <p> This operation is implemented on the server side in WeatherSummaryImp.cpp , which makes the call to the notification proxy in **35;6728;TOOLONG to send the renewal request to the client . On the client side , the class in **33;6765;TOOLONG sets up a listener , receives the message , and sends a response . <p> The request-response and the solicit-response patterns are generally synchronous , as their usage usually assumes that the @ @ @ @ @ @ @ @ @ @ and the notification patterns are inherently asynchronous in that the requestor expects no response . <p> While one of the strengths of WSDL is that it allows any mix of message patterns and transports in a single service , it is important to be aware that the behavior of a service is tied to the type of transport being used . For example , an asynchronous service will not behave asynchronously if it is sent using a synchronous transport , such as HTTP . This is because HTTP requires a response as a receipt . <p> For this reason , it may be wise to build one-way and notification messages asynchronously even though no response is required , in order to avoid having the client block for a transport receipt . In addition , using the asynchronous methods for one-way and notification builds more responsiveness and adaptability into your program without much more complication . 
@@75677706 @4377706/ <h> Anatomy of a Java Path checker <p> The kwcreatechecker command creates five files in the checker directory . You specify the checker directory name with the --code option , which is mandatory . Three of these files are stubs that require user input . The most crucial of these stub files is the knowledge base file . <p> The three files that require updating are : <p> &lt;CHECKER.CODE&gt;.jkb , which is the knowledge base file where you define the checker behavior ; see Knowledge base entries <p> The two other files that are generated , but do n't require manual input are : <p> logger.xml , which unlocks logger information produced by kwjava about the code analyzed by the Path checker , as well as knowledge base parameters that were applied , such as sources and sink . You can use this output to debug and improve your knowledge base . 
@@75677707 @4377707/ <p> A multilayer feedforward neural network is an interconnection of perceptrons in which data and calculations flow in a single direction , from the input data to the outputs . The number of layers in a neural network is the number of layers of perceptrons . The simplest neural network is one with a single input layer and an output layer of perceptrons . The network in Figure 13-7 illustrates this type of network . Technically , this is referred to as a one-layer feedforward network with two outputs because the output layer is the only layer with an activation calculation . <p> Figure 13- 7 : A Single-Layer Feedforward Neural Net <p> In this single-layer feedforward neural network , the networks inputs are directly connected to the output layer perceptrons , Z1 and Z2 . <p> The output perceptrons use activation functions , g1 and g2 , to produce the outputs Y1 and Y2 . <p> Since <p> , <p> , <p> and <p> . <p> When the activation functions g1 and g2 are identity activation functions , the single-layer neural net is equivalent to a linear regression @ @ @ @ @ @ @ @ @ @ activation functions , then the single-layer neural net is equivalent to logistic regression . Because of this correspondence between single-layer neural networks and linear and logistic regression , single-layer neural networks are rarely used in place of linear and logistic regression . <p> The next most complicated neural network is one with two layers . This extra layer is referred to as a hidden layer . In general there is no restriction on the number of hidden layers . However , it has been shown mathematically that a two-layer neural network <p> can accurately reproduce any differentiable function , provided the number of perceptrons in the hidden layer is unlimited . <p> However , increasing the number of perceptrons increases the number of weights that must be estimated in the network , which in turn increases the execution time for the network . Instead of increasing the number of perceptrons in the hidden layers to improve accuracy , it is sometimes better to add additional hidden layers , which typically reduce both the total number of network weights and the computational time . However , in practice , it is @ @ @ @ @ @ @ @ @ @ three hidden layers . <p> The error calculations used to train a neural network are very important . Researchers have investigated many error calculations in an effort to find a calculation with a short training time appropriate for the networks application . Typically error calculations are very different depending primarily on the networks application . <p> For forecasting , the most popular error function is the sum-of-squared errors , or one of its scaled versions . This is analogous to using the minimum least squares optimization criterion in linear regression . Like least squares , the sum-of-squared errors is calculated by looking at the squared difference between what the network predicts for each training pattern and the target value , or observed value , for that pattern . Formally , the equation is the same as one-half the traditional least squares error : <p> , <p> where N is the total number of training cases , C is equal to the number of network outputs , is the observed output for the ith training case and the jth network output , and is the networks forecast for that case . @ @ @ @ @ @ @ @ @ @ forecast variable . That is , the recommended practice is to use C=1 when using a multilayer feedforward neural network for forecasting . For classification problems with more than two classes , it is common to associate one output with each classification category , i.e. , C=number of classes . <p> Notice that in ordinary least squares , the sum-of-squared errors are not multiplied by one-half . Although this has no impact on the final solution , it significantly reduces the number of computations required during training . <p> Also note that as the number of training patterns increases , the sum-of-squared errors increases . As a result , it is often useful to use the root-mean-square ( RMS ) error instead of the unscaled sum-of-squared errors : <p> where is the average output : <p> . <p> Unlike the unscaled sum-of-squared errors , does not increase as N increases . The smaller values for , indicate that the network predicts its training targets closer . The smallest value , , indicates that the network predicts every training target exactly . The largest value , , indicates that the network @ @ @ @ @ @ @ @ @ @ forecast equal to the mean of the training targets . <p> Notice that the root-mean-squared error is related to the sum-of-squared error by a simple scale factor : <p> Another popular error calculation for forecasting from a neural network is the Minkowski-R error . The sum-of-squared error , , and the root-mean-squared error , , are both theoretically motivated by assuming the noise in the target data is Gaussian . In many cases , this assumption is invalid . A generalization of the Gaussian distribution to other distributions gives the following error function , referred to as the Minkowski-R error : <p> . <p> Notice that when R=2 . <p> A good motivation for using instead of E is to reduce the impact of outliers in the training data . The usual error measures , and , emphasize larger differences between the training data and network forecasts since they square those differences . If outliers are expected , then it is better to de-emphasize larger differences . This can be done by using the Minkowski-R error with R=1 . When R=1 , the Mindowski-R error simplifies to the sum of @ @ @ @ @ @ @ @ @ @ as the Laplacian error . This name is derived from the fact that it can be theoretically justified by assuming the noise in the training data follows a Laplacian , rather than Gaussian , distribution . <p> Of course , similar to E , generally increases when the number of training cases increases . Similar to , a scaled version of the Laplacian error can be calculated using the following formula : <p> As previously mentioned , multilayer feedforward neural networks can be used for both forecasting and classification applications . Training a forecasting network involves finding the network weights that minimize either the Gaussian or Laplacian distributions , E or respectively , or equivalently their scaled versions , or . Although these error calculations can be adapted for use in classification by setting the target classification variable to zeros and ones , this is not recommended . Use of the sum-of-squared and Laplacian error calculations is based on the assumption that the target variable is continuous . In classification applications , the target variable is a discrete random variable with C possible values , where C=number of classes . @ @ @ @ @ @ @ @ @ @ one of only two categories is referred to as a binary classification network . It has a single output : the estimated probability that the input pattern belongs to one of the two categories . The probability that it belongs to the other category is equal to one minus this probability , i.e. , . <p> Binary classification applications are very common . Any problem requiring yes/no classification is a binary classification application . For example , deciding to sell or buy a stock is a binary classification problem . Deciding to approve a loan application is also a binary classification problem . Deciding whether to approve a new drug or to provide one of two medical treatments are binary classification problems . <p> For binary classification problems , only a single output is used , C=1 . This output represents the probability that the training case should be classified as " yes . " A common choice for the activation function of the output of a binary classification network is the logistic activation function , which always results in an output in the range 0 to 1 , regardless @ @ @ @ @ @ @ @ @ @ binary classification networks is to use sum-of-squared errors with the class value of yes patterns coded as a 1 and the no classes coded as a 0 , i.e. : <p> . <p> However , using either the sum-of-squared or Laplacian errors for training a network with these target values assumes that the noise in the training data are Gaussian . In binary classification , the zeros and ones are not Gaussian . They follow the Bernoulli distribution : <p> , <p> whereis equal to the probability that a randomly selected case belongs to the " yes " class . <p> Modeling the binary classes as Bernoulli observations leads to the use of the cross-entropy error function described by Hopfield ( 1987 ) and Bishop ( 1995 ) : <p> , <p> where N is the number of training patterns , is the target value for the ith case ( either 1 or 0 ) , and is the network output for the ith training pattern . This is equal to the neural networks estimate of the probability that the ith training pattern should be classified as " yes . @ @ @ @ @ @ @ @ @ @ a probability in the range , the value of the cross-entropy at the networks optimum is equal to : <p> Subtracting from gives an error term bounded below by zero , i.e. , <p> where : . <p> This adjusted cross-entropy , , is normally reported when training a binary classification network where . Otherwise , the unadjusted cross-entropy error , is used . For small values , i.e. values near zero , indicate that the training resulted in a network able to classify the training cases with a low error rate . <p> Using a multilayer feedforward neural network for binary classification is relatively straightforward . A network for binary classification only has a single output that estimates the probability that an input pattern belongs to the " yes " class , i.e. , . In classification problems with more than two mutually exclusive classes , the calculations and network configurations are not as simple . <p> One approach is to use multiple network outputs , one for each of the C classes . Using this approach , the jth output for the ith training pattern , , is @ @ @ @ @ @ @ @ @ @ jth class , denoted by . An easy way to estimate these probabilities is to use logistic activation for each output . This ensures that each output satisfies the univariate probability requirements , i.e. , . <p> However , since the classification categories are mutually exclusive , each pattern can only be assigned to one of the C classes , which means that the sum of these individual probabilities should always equal 1 . However , if each output is the estimated probability for that class , it is very unlikely that . In fact , the sum of the individual probability estimates can easily exceed 1 if logistic activation is applied to every output . <p> Support Vector Machine ( SVM ) neural networks use this approach with one modification . An SVM network classifies a pattern as belonging to the ith category if the activation calculation for that category exceeds a threshold and the other calculations do not exceed this value . That is , the ith pattern is assigned to the jth category if and only if and for all , where d is the threshold . @ @ @ @ @ @ @ @ @ @ marked as unclassified . <p> Another approach to multi-class classification problems is to use the softmax activation function developed by Bridle ( 1990 ) on the network outputs . This approach produces outputs that conform to the requirements of a multinomial distribution . That is <p> and <p> The softmax activation function estimates classification probabilities using the following softmax activation function : <p> , <p> where is the potential for the jth output perceptron , or category , using the ith pattern . <p> For this activation function , it is clear that : <p> for all , and <p> for all <p> Modeling the C network outputs as multinomial observations leads to the cross-entropy error function described by Hopfield ( 1987 ) and Bishop ( 1995 ) : <p> , <p> where N is the number of training patterns , is the target value for the jth class of ith pattern ( either 1 or 0 ) , and is the networks jth output for the ith pattern . is equal to the neural networks estimate of the probability that the ith pattern should be classified into the jth @ @ @ @ @ @ @ @ @ @ is a probability in the range , the value of the cross-entropy at the networks optimum is equal to : <p> Subtracting this from gives an error term bounded below by zero , i.e. , where : <p> This adjusted cross-entropy is normally reported when training a binary classification network where . Otherwise , the non-adjusted cross-entropy error , is used . That is , when 1-in-C encoding of the target variable is used , <p> Small values , values near zero , indicate that the training resulted in a network with a low error rate and that patterns are being classified correctly most of the time . <p> Sometimes a multilayer feedforward neural network is referred to incorrectly as a back-propagation network . The term back-propagation does not refer to the structure or architecture of a network . Back-propagation refers to the method used during network training . More specifically , back-propagation refers to a simple method for calculating the gradient of the network , that is the first derivative of the weights in the network . <p> The primary objective of network training is to estimate an appropriate @ @ @ @ @ @ @ @ @ @ Many ways have been researched for estimating these weights , but they all involve minimizing some error function . In forecasting the most commonly used error function is the sum-of-squared errors : <p> . <p> Training uses one of several possible optimization methods to minimize this error term . Some of the more common are : steepest descent , quasi-Newton , conjugant gradient and many various modifications of these optimization routines . <p> Back-propagation is a method for calculating the first derivative , or gradient , of the error function required by some optimization methods . It is certainly not the only method for estimating the gradient . However , it is the most efficient . In fact , some will argue that the development of this method by Werbos ( 1974 ) , Parker ( 1985 ) and Rumelhart , Hinton and Williams ( 1986 ) contributed to the popularity of neural network methods by significantly reducing the network training time and making it possible to train networks consisting of a large number of inputs and perceptrons . <p> Simply stated , back-propagation is a method for calculating the @ @ @ @ @ @ @ @ @ @ network weight . Bishop ( 1995 ) derives and describes these calculations for the two most common forecasting error functions the sum-of-squared errors and Laplacian error functions . Abe ( 2001 ) gives the description for the classification error function - the cross-entropy error function . For all of these error functions , the basic formula for the first derivative of the network weight at the ith perceptron applied to the output from the jth <p> perceptron is : <p> , <p> where is the output from the ith perceptron after activation , and is the derivative for a single output and a single training pattern . The overall estimate of the first derivative of is obtained by summing this calculation over all N training patterns and C network outputs . <p> The term back-propagation gets its name from the way the term in the back-propagation formula is calculated : <p> , <p> where the summation is over all perceptrons that use the activation from the jth perceptron , . <p> The derivative of the activation functions , , varies among these functions . See the following table : 
@@75677708 @4377708/ <h> 2.1 The Abstract X/Open DTP Model <p> This chapter provides a brief introduction to transaction processing in an XA-compliant environment , then describes the role that the DB XA Module plays in that environment . Here are definitions of some of the terms used in this chapter : <p> A transaction is a unit of work that consists of an application-specific sequence of operations . <p> A transaction processing system defines and coordinates interactions between multiple users and databases . The goal of a transaction processing system is to carry out transactions in an efficient , reliable and coordinated way . The success of a transaction is measured against four critical objectives known as the ACID ( Atomicity , Consistency , Isolation , Durability ) properties . <p> A distributed transaction processing ( DTP ) system is a form of transaction processing that supports transactions whose operations are distributed among different computers or among different databases from different vendors . A local transaction involves one service within a single server program , and accesses only one database . A global transaction involves several services , which might be @ @ @ @ @ @ @ @ @ @ also called a distributed transaction . <p> Figure 1 illustrates where the DB XA Module fits in an X/Open DTP environment . As shown in the figure , the X/Open DTP model consists of three main parts : <p> An application program ( AP ) that defines the boundaries of a transaction and specifies the actions that constitute a transaction . <p> A resource manager ( RM ) that provides access to shared data . Usually a resource manager is a database server or a file-access system . <p> A transaction monitor ( TM ) that manages the routing and transaction processing control of a service request . The TM manages global transactions and coordinates their resolution and any failure recovery . <p> A path of communication between any two parts of the X/Open DTP Model is called an interface . As shown in Figure 1 , the DTP model has the following interfaces : <p> The AP-RM interface : <p> The AP-RM interface allows an application program to call a resource manager directly , using the RM 's native API , when the transaction does not need to be @ @ @ @ @ @ @ @ @ @ AP to perform database connection management , transaction management , and database manipulation . <p> When the requested transaction must be managed by a TPM through the XA interface , however , the TPM becomes responsible for managing the database connections and transactions . To perform database manipulations under these circumstances , the AP requires the connection handles of the connections opened by TPM . The AP uses an XA-specific native API to fetch the database connection handles , and then uses these connection handles for data manipulation through the native API . <p> The AP-TM interface : <p> This is also known as the TX interface . It let 's the application program call the transaction monitor to request transaction management . X/Open defines an API for starting and ending transactions , directing the completion of a transaction , and obtaining status information about transactions . This interface must be supported by all X/Open-compliant TPMs . <p> The TM-RM interface : <p> This is also known as an XA interface . It allows two-way communication between the transaction monitor and the resource manager , and implements the two-phase commit between @ @ @ @ @ @ @ @ @ @ standard set of routines described in the XA specification . The transaction monitor uses these routines to manage global transactions . 50235 @qwx670235 
@@75677710 @4377710/ <p> The Tools.h++ Class Reference describes all the classes and functions in Tools.h++ . It does not provide a tutorial on how to program with the Tools.h++ class library . For information on how to write programs using Tools.h++ , consult the Tools.h++ User 's Guide . For information on building and using Tools.h++ , review the Tools.h++ Build Guide . <p> Immediately following this introduction is a class hierarchy diagram . The class hierarchy lists all the classes , and illustrates the relationships among them . You can refer to it for a bird's-eye view of the inheritance structure used in Tools.h++ . <p> The remainder of this reference is an alphabetical listing of classes . The entry for each class begins with an illustration showing the individual class 's inheritance hierarchy , followed by a synopsis that lists the header files(s) and the Smalltalk typedef ( if appropriate ) associated with the class . The synopsis also shows a declaration and definition of a class object , and any typedefs that are used . Following the synopsis is a brief description of the class , and a @ @ @ @ @ @ @ @ @ @ organized in categories according to their general use - for example , " constructors , " " global operators , " and " public member functions . " The categories , although somewhat arbitrary , provide a way of organizing the many functions . <p> All Rogue Wave class names start with the letters RW , as in RWCollectable . In some cases , we may refer to an instance of a class by an English name ; for example , " the string " instead of " the RWCString instance . " We do this to make it easier to read when the meaning should be clear from context , but we use the longer form if there is a possible ambiguity . <p> All function names begin with a lower case letter , with the first letter of subsequent words capitalized . Function names attempt to accurately describe what a function does . For example , RWCString : : toLower() changes all uppercase letters in itself to lowercase . Underline characters and abbreviations are not generally used in function names . <p> Function names , examples , operating @ @ @ @ @ @ @ @ @ @ in a courier font , as in &lt;rw/stream.h&gt; . Vertical ellipses are used in code examples to indicate that some part of the code is missing . <p> Throughout this documentation , there are frequent references to " self . " This should be read as " *this " . <p> Each class that inherits from another class ( or other classes ) includes an illustration that shows the inheritance hierarchy . For example , the following illustration indicates that class A inherits from class B : <p> When a class inherits from more than one class , or there are multiple levels of inheritance , all of the inheritance relationships are shown . For example , the following illustration indicates that A inherits from class B and from class C , which inherits from class D. <p> The notation system used in the inheritance hierarchies is based on the Object Modeling Technique ( OMT ) developed by Rumbaugh and others . 1 <p> Within their general categories , member functions for each class are listed alphabetically . Member functions fall into three general types : <p> Functions that are @ @ @ @ @ @ @ @ @ @ functions is presented in the class where they occur . An example is balance() , a member of the class RWBinaryTree . <p> Functions that are inherited from a base class without being redefined . The complete documentation for these functions is presented in the defining base class . An example is clearAndDestroy() , for class RWBinaryTree , which is inherited from class RWCollection . When a member function is inherited without being redefined , the member function appears in both places , and this guide refers you to the original definition . <p> Functions that are redefined in a derived class . These are usually virtual functions . The documentation for these functions usually directs you to the base class , but may also mention peculiarities that are relevant to the derived class . An example is apply() , for class RWBinaryTree . <p> The following list shows the public class hierarchy of the Tools.h++ classes . Note that this is the public class hierarchy--the implementation of a given class may use private inheritance . Additionally , some classes inherit from public , but undocumented , implementation classes . @ @ @ @ @ @ @ @ @ @ derived by multiple inheritance show their additional base(s) in italics to the right of the class name . 
@@75677711 @4377711/ <h> 2015 Ponemon survey of automakers and suppliers <p> Recent statistics about automobile safety are disconcerting , both for the automotive supply chain and for the consumer . Media attention has highlighted numerous security and safety issues for the connected car . But , as sensational as some of these headlines are , the problem is real . <p> The Ponemon Institute recently conducted a cybersecurity survey sponsored by Rogue Wave Software and Security Innovation of over 500 automotive developers , engineers , and executives , primarily from automotive OEMs and tier one suppliers . The results were eye opening : <p> 90 percent think that it is difficult to secure automotive applications <p> We 've analyzed the survey results in this complimentary report , and provided new insights to help automotive software suppliers understand the current mindset of their developers and build security and safety into their software . <p> Listen to this on-demand webinar with Walter Capitani , Product Manager from Rogue Wave Software , Pete Samson , Senior VP from Security Innovation , and Larry Ponemon , Ponemon Institute . They discuss the current state of automotive @ @ @ @ @ @ @ @ @ @ mean in the real world of automotive . <p> Referencing the survey conducted by Ponemon Institute , this infographic guides you through the potential challenges , and solutions on the path to application security , while providing insight into the current state of the automotive industry . 
@@75677712 @4377712/ <h> Format of the build specification file for Java projects <p> The Klocwork build specification for Java projects , called kwinject.out by default , is a semicolon-separated text file containing the following information about the Java source files in your Klocwork project : <p> the classpath and Java version for the javac invocation , identified in jconfig lines <p> the source Java files that were compiled , identified in jcompile lines <p> the jar files and their input files , identified in the jar lines <p> The first field of each line is a tag to identify the type of line . The possible tags are as follows : <p> Tag <p> Description <p> version <p> build specification format version <p> jconfig <p> used to define Java compiler options , such as Java version and classpath <p> jcompile <p> used to specify compiled source files <p> jar <p> used to specify jar files and their input files <h> version line <p> The version line is used to define the build specification format version . It must be the first line in the build specification . Only one version line @ @ @ @ @ @ @ @ @ @ line : <p> version ; 106 <p> Version 1.4 or later indicates that the build specification was generated using a source encoding of UTF-8 , allowing multibyte characters ( for example , Japanese ) . To ensure that kwbuildproject processes the build specification with UTF-8 encoding , the version must be version ; 104 or later . <h> jconfig line <p> The jconfig line is used to identify Java compiler options " the Java version and default classpath . <p> a list of separated compiler options listing the source version and LONG ... The classpath entries are separated by " : " on Unix machines , or " %3B " for Windows . 
@@75677713 @4377713/ <h> Types of Java Path checkers <p> Resource Leak ( RLK ) checkers locate the resource and detect the ways in which the resource can be lost . RLK ( Resource Leak ) issues are reported when some resources were allocated and not properly disposed after use . Failing to properly dispose a resource can lead to such problems as : <p> too many files being open <p> an application not being able to access a temporary file when it is needed <p> Note : When creating RLK checkers , you only need to identify the source(s) and not the sink . The sink is the point at which the resource is lost . <p> Commoncheckers track data from the time it appears in the code execution to when it is used by the program . 
@@75677714 @4377714/ <h> 4.2 Model Selection Viewed As Search <p> Understanding the behavior of model selection tools is easiest when the model selection techniques are viewed as search techniques . The search space consists of possible subsets of predictor variables . An evaluation criterion assigns each subset a numerical value , and the goal of the search is to find the subset with the highest numerical value . The only difference between techniques involves the choice of a starting subset and the specification of neighboring subsets in the search space . <p> As an example , Figure 4 illustrates one model selection technique , forward selection , using a connected graph . In this particular example , there are six possible predictor variables : . Nodes in the graph indicate predictor variable subsets ; each node is labeled with the subset , a bit representation of the subset , and the subset 's evaluation criterion . The current node in the search is shaded , while its neighboring nodes are not shaded . Graph edges indicate which subsets are considered neighbors in the search ; edges are labeled with the action @ @ @ @ @ @ @ @ @ @ continues along the path in the graph that leads to the greatest evaluation criterion , and stops when the evaluation criterion can no longer improve . In the graph in Figure 4 , forward selection adds the predictor variable because the resulting predictor variable subset has the highest evaluation criterion with a value of 6.04 . Then forward selection makes this subset the current one and continues by evaluating the new subset 's neighbors . The new neighbors are not shown in the figure . <p> In general , exhaustive search is the only technique guaranteed to find the predictor variable subset with the best evaluation criterion . It is often the ideal technique when the number of possible predictor variables is less than 20 ; note that this number depends to some degree on the computational complexity of evaluating a predictor variable subset . <p> The problem with exhaustive search is that it is often a computationally intractable technique for more than 20 possible predictor variables . As Figure 4 shows , every possible subset of N predictor variables has a unique bit representation that uses N bits . @ @ @ @ @ @ @ @ @ @ , excluding the empty set , and exhaustive search must check them all . For regression models with 25 predictor variables , exhaustive search must check 33,554,431 subsets , and this number doubles for each additional predictor variable considered . Clearly , exhaustive search is not always a practical technique , and other selection techniques may have to be considered . <p> Unlike exhaustive search , forward selection is always computationally tractable . Even in the worst case , it checks a much smaller number of subsets before finishing . This technique adds predictor variables and never deletes them . The starting subset in forward selection is the empty set . For a regression model with possible predictor variables , the first step involves evaluating predictor variable subsets , each consisting of a single predictor variable , and selecting the one with the highest evaluation criterion . The next step selects from among subsets , the next step from subsets , and so on . Even if all predictor variables are selected , at most subsets are evaluated before the search ends . <p> The problem with forward selection is @ @ @ @ @ @ @ @ @ @ to find the subset with the highest evaluation criterion . In practice , however , many researchers have reported good results with forward selection ( Miller , 1990 ) .1 This is not too surprising : it 's not hard to show that forward selection will find the subset with the highest evaluation criterion when predictor variables are statistically independent and the observation variable is modeled as a linear combination of predictor variables.2 While statistical independence of predictor variables may be too much to expect for the regression problem you are trying to improve , it may become more feasible with more study into the predictor variables . You may discover certain preprocessing steps that can be performed to predictor variable data such that the predictor variables become nearly statistically independent . <p> Backward selection has computational properties that are similar to forward selection . The starting subset in backward selection includes all possible predictor variables . Predictor variables are deleted one at a time as long as this results in a subset with a higher evaluation criterion . Again , in the worst case , at most subsets must @ @ @ @ @ @ @ @ @ @ , backward selection is not guaranteed to find the subset with the highest evaluation criterion . <p> Some researchers prefer backward selection to forward selection when the predictor variables are far from statistically independent . In this case , starting the search with all predictor variables included allows the model to take predictor variable interactions into account . Forward selection will not add two predictor variables that together can explain the variations in the observation variable if , individually , the predictor variables are not helpful in explaining the variation . Backward selection , on the other hand , would already include both of these variables and would realize that it is a bad idea to delete either one . <p> The disadvantage of backward selection is that one 's confidence in subset evaluation criterion values tends to be lower than with forward selection . This is especially true when the number of rows in the predictor matrix is close to the number of possible predictor variables . In such a case , there are very few points that the regression model can use in order to determine its parameter @ @ @ @ @ @ @ @ @ @ to small changes to the predictor matrix data . When the ratio of predictor matrix rows to predictor variables is small , it is usually a better idea to use forward selection than backward selection . <p> Stepwise selection has been proposed as a technique that combines advantages of forward and backward selection . At any point in the search , a single predictor variable may be added or deleted . Commonly , the starting subset is the empty set . When we think in terms of a predictor variable subset 's bit representation , stepwise selection allows one bit in the representation to be flipped at any point in the search . Therefore , since a subset 's bit representation has bits , each subset in the search graph for stepwise selection has neighbors . If no bit is flipped more than once , at most subsets are evaluated before stepwise selection ends . There are , however , no guarantees that each bit will be flipped at most one time . <p> No strong theoretical results exist for comparing the effectiveness of stepwise selection against forward or backward @ @ @ @ @ @ @ @ @ @ two techniques , so in practice it tends to produce better subsets ( Miller , 1990 ) .3 Of course , the price that stepwise selection pays for finding better subsets is reduced computational speed : usually more subsets must be evaluated before the search ends . 
@@75677715 @4377715/ <h> Stingray <h> Quickly build professional Windows GUIs <p> Develop complex GUI applications that are easy to build , maintain , and evolve as new technologies improve the look and feel of user interfaces . Controls in Stingray include many common items found in GUI applications : combo boxes , tool bars , frames , menus , tree controls , and much more . In addition to these basic controls , Stingray has embeddable components that provide a starting point for your application , similar to popular Microsoft applications such as Excel , Visio , Chart , Visual Studio , and Access . Easily extend and customize these base components to meet your development needs . <p> " By using Stingray Graphical User Interface components , USC developers brought RightDose to market faster , while using significantly less development resources than initially planned ... The cost and time investment of maintaining the user interface of the RightDose application ... has been minimal . " <p> Dr. Roger W. Jelliffe , PhD , Laboratory of Applied Pharmacokinetics , <p> founder and co-director <h> Comprehensive GUI development solutions <p> Created by @ @ @ @ @ @ @ @ @ @ flexible , comprehensive components , Stingray components handle the details of GUI functionality and allow developers to focus on end-user requirements and the business logic of an application . <h> Advanced look and feel <p> Stingray components provide rich interfaces that can be used to mimic the look and feel of Microsoft applications such as Excel , Chart , Visio , Visual Studio , and Outlook . The MFC extension libraries in Stingray work with other technologies , like ActiveX and the Microsoft . NET framework , in both 32-bit and 64-bit environments . 
@@75677716 @4377716/ <p> Policy Manager provides an enterprise-class UDDIv3 registry with a role-based JSR-168 compliant Web-based portal interface to ensure that different users have easy access to the features and capabilities they need and use the most . <p> Policy Manager provides comprehensive SOA Governance tools for all the different roles in the organization including ; service developer , consumer developer , architect , business stakeholder , IT operations , security operations , and more . It uses a role-based security model for authorization of policy-driven SOA Governance process control such as service publishing and provisioning process approvals , and to protect sensitive information . <p> Policy Manager defines , monitors , and manages Active Contracts between consumers and providers . These contracts are created through a negotiation process , supported by ad-hoc collaboration between vested constituents and can be enforced by a standards-based SOA run-time security and management solution like Service Manager . They define the specific policy sets that will be used and enforced , the SLAs and alerts the service commits to , and the access profile and capacity granted to the consumer . <p> Use metrics and @ @ @ @ @ @ @ @ @ @ comply with defined run-time policies <p> Capture performance and usage metrics according to policies <p> Statistically and algorithmically capture comprehensive message data <p> Track and manage security and other policy exceptions <p> Compare and reconcile collected metrics with policies for audit purposes <h> Contract Management <p> Policy Manager uses Active Contracts to : <p> Manage relationships between service consumers and providers <p> Provide a process allowing the negotiation of policies , SLAs , and capabilities between consumer and provider <p> Enforce a contract that tracks this relationship <p> Provide notifications on changes <p> Deliver consumer-led service and policy definition <p> Consumers can request a service ( WSDL ) with constraints and capabilities ( policy ) they would like to use , and allow organizations to fulfill this by negotiating and implementing the agreed policies and services <p> Manage the supply and demand equation for services with a contract-based provisioning process for : <p> Capacity planning <p> Version management <p> Service deprecation <p> Mapping relationships between services for impact and exception analysis and reporting <h> Value Management <p> Policy Manager provides SOA value management capabilities , it can : <p> Measure @ @ @ @ @ @ @ @ @ @ organization <p> Assign real or arbitrary value to service transactions for billing or tracking purposes <p> Monitor which parts of an organization are publishing services that have broad value to the business <p> Monitor which parts of an organization are reducing costs by consuming services provided by others <p> Monitor which parts of an organization need further encouragement to adopt SOA 
@@75677718 @4377718/ <h> 3.2 Multiple Linear Regression <p> In the late 1880s , Francis Galton was studying the inheritance of physical characteristics . In particular , he wondered if he could predict a boy 's adult height based on the height of his father . Galton hypothesized that the taller the father , the taller the son would be . He plotted the heights of fathers and the heights of their sons for a number of father-son pairs , then tried to fit a straight line through the data . If we denote the son 's height by and the father 's height by , we can say that in mathematical terms , Galton wanted to determine constants and such that : <p> . <p> This is an example of a simple linear regression problem with a single predictor variable , . The parameter is called the intercept parameter . In general , a regression problem may consist of several predictor variables . Thus the multiple linear regression problem may be stated as follows : <p> Let be a random variable that can be expressed in the form : <p> , @ @ @ @ @ @ @ @ @ @ error . The problem is to estimate the parameters . If the are varied and the values of are observed , then we write : <p> , <p> where is the ith value of . Writing these n equations in matrix form we have : <p> or : <p> , <p> where . <p> We call the matrix the regression matrix , the response variable , the response vector , and the predictor variable . <p> The critical value of the F statistic for a specified significance level , , is the value , , of the F statistic such that if the F statistic calculated for the multiple linear regression is greater than , we reject the hypothesis <p> The critical value of a parameter T statistic for a given level of significance is the value , such that if the absolute value of the T statistic calculated for a given parameter is greater than , we reject the hypothesis at the significance level . <p> Suppose that we have calculated parameter estimates for our linear regression problem . Suppose further that we have a vector of values , @ @ @ @ @ @ @ @ @ @ level confidence interval for the value , which is the value of the dependent of the observed variable predicted by our model , according to the formula : <p> , <p> where is the value at of the cumulative distribution function for a T distribution , is the estimated variance , and is the regression matrix . 
@@75677721 @4377721/ <h> Getting notified of changes in Klocwork <h> Getting notified of changes in Klocwork <p> Make sure you 're notified of changes that affect you . <p> Click the RSS button next to any feed to subscribe via RSS to updates to the feed . For instance , if you subscribe to notifications to your to do feed , you 'll always be alerted when you 're invited to a code review or when you 've been assigned an action . <p> You can also get email and visual notification of code review updates . <h> Editing a feed <p> You can edit your home feed or set up new feeds to ensure that you see only the information that you want to see . <p> With custom feeds , you can monitor any combination of users and directory paths , so for example , you can set up a single feed to monitor your entire team and all the modules your team is responsible for . You can also view reports for custom feeds . <p> Creating a custom feed <p> Click Feeds , if you 're not @ @ @ @ @ @ @ @ @ @ new feed on the far left to add a new feed , or click to edit an existing feed . <p> Click user to select a user . A user in this context is the person committing the revision or creating a pre-checkin code review . <p> Click components of the system to select the file path . A component points to both a Klocwork integration project and an absolute path . You can leave the path blank for projects without any common path prefixes . <p> Click tags to select a tag . If you have tagged your code reviews , specifying a tag here will allow you to filter your feed list by any specified tag(s) . <h> Getting email notification of updates <p> If your Klocwork Server is set up for email notification , you can receive emails to warn you when : <p> a comment is created for an issue <p> an action occurs for an issue , or the action state is changed <p> a code review invitation is received or a code review state is updated <p> By default , your Klocwork profile is @ @ @ @ @ @ @ @ @ @ you can turn emails on and off in your profile for actions , comments or code reviews . To make changes to your profile : <p> Access your profile by clicking your avatar menu in the upper right of the window and then clicking Profile . <p> Enable or disable email notifications by clicking the checkbox labeled <h> Getting visual notification of updates <p> Code Review contains a built-in dashboard that provides visual notifications for items that are relevant to you . The notification area provides visual cues when a comment is created , when an action occurs , when a code review invitation is sent , or when a code review state is updated . <p> The icons in the notification area represent comments , action items , and reviews : <p> Whenever one of your feeds is updated , a notification badge appears indicating that a new comment or action has been added , or review has been updated . To view the updated item , click the icon . <p> If your dashboard looks as follows : <p> This indicates that you have a review notification for @ @ @ @ @ @ @ @ @ @ permissions to see . To view these items , contact your Projects root admin to inquire about getting the proper permissions . 
@@75677723 @4377723/ <p> Start Worksheet dataData that is specific to the sheet goes here.This data often refers to the global table.Styles , for example , are stored in the global table and are referenced here by index.End Worksheet data <p> Start Next Worksheet data ... End Next Worksheet data <p> This is the structure of the documented stream . Excel has other streams . Some are not documented and some ( like summary information ) are . For our purposes we will only handle the data in the main stream , the WorkBook Stream . <p> Shown below is a typical Excel file ( written out by Objective Grid ) as seen in BiffView , a utility that ships with the Excel Software Development Kit ( SDK ) . The sequence of global and local records are detailed above . Note that the global records are grouped together and yet are discrete . This makes them conceptually similar to a table that is accessible by index . <p> The record length varies from record to record . This value is the size of the total record less the size of the @ @ @ @ @ @ @ @ @ @ the sum of the record identifier size and the record length size , i.e. 4 bytes with BIFF 8 . <p> For example , let us take the case of a sample record , the BOF ( beginning of file ) record , defined in the Excel SDK as follows : <p> The BOF record marks the beginning of the Book stream in the BIFF file . It also marks the beginning of record groups ( or " substreams " of the Book stream ) for sheets in the workbook . For BIFF2 through BIFF4 , you can determine the BIFF version from the high-order byte of the record number field , as shown in the following table . For BIFF5 , BIFF7 , and BIFF8 you must use the vers field at offset 4 to determine the BIFF version . <p> The SDK documentation describes each of the constituent parts of the Excel SDK in detail . For our purposes we will examine the binary dump of this field from a typical Excel File . This is shown below : <p> To study the general structure , we are @ @ @ @ @ @ @ @ @ @ above case these are : <p> 09 08 10 00 <p> The first two bytes in this byte sequence stand for the record type ( in this case typeBOF ) . According to the Excel SDK , we copy these declarations ( for the fields that we use ) into gxexhdr.h : <p> #define typeBOF 0x0809 <p> This is what we have considering that the byte sequence is reversed on Little Endian machines . The first two bytes are typeBOF . <p> Now let us look at the next two bytes . Taking byte swapping into account we have 0x0010 or in decimals 16 ( bytes ) . You can see that , apart from the fixed 4 byte header , 16 bytes form the body of the record . The interpretation of each of these bytes is given in the Excel SDK . Based on this we decipher these bytes and convey data to Objective Grid . When writing , the reverse occurs . <p> Let us examine the structure of the read mechanism first . When the grid reads in an Excel file it knows the basic structure @ @ @ @ @ @ @ @ @ @ ) . Once it reads the type and the length , it checks to see if it can handle this type . If it can be handled at all , each type can be handled by exactly one handler . Two different types of objects handle data . One object is called handler and the other is called table . Handlers are typically for local worksheet data and tables are for global data . <p> The Objective Grid Excel code looks in a map to see if there is a handler for the record type . If one exists , the stream is read and the data is retained and interpreted . If not , the grid performs a seek ( based on the record length that was read from the record header ) and goes on to look at the next entry . This continues until the file is read completely . <p> Two maps are defined in the application one for handlers and the other for tables . These maps are composed of macros in a manner that is very similar to that of CWnd message maps . @ @ @ @ @ @ @ @ @ @ below : <p> Each map macro entry has three values . The first is the type of record that this entry can handle . The second is the object type to be used when handling this entry . ( Remember that the map merely maps a record type to an object that can handle it ) . The third ( rather redundant ) value specifies the size of the record type data that is to be used for comparison . With the current version ( BIFF 8 ) this value can always be taken as two bytes . However , in anticipation of changes in future versions of Excel , we designed this product with flexibility and facility in mind . <p> If you were to add support for another table or handler , you would simply add another entry to this map . If you do not intend to add support for any additional fields you can use the maps from one of the samples . <p> The lookup sequence is very simple . Let us look at some code that shows this inside the grid : <p> // @ @ @ @ @ @ @ @ @ @ locate the handler . CGXExcelHandler* pHandler = **37;6800;TOOLONG ( wType ) ; CGXExcelTable* pTable = **42;6839;TOOLONG ; ASSERT ( ( pHandler &amp;&amp; pTable ) == FALSE ) ; // It has to be either a table or a regular record handler . // You ca n't have both kind of handlers simultaneously . <p> One advantage of having this structure is that it affords easy changes to the type of handlers that can be added . It makes it very easy to add support for fields that are not supported by the product out of the box . It also makes it easy to log details about fields that are not read in for debugging purposes . <p> Writing is slightly different since the writing code lays out the file structure and calls the correct handlers and tables to build the . xls file . Again a map controls the order in which the writing takes place . This map merely controls the sequence of the write and calls the same handlers as the write code to handle the actual write . Let us take a look at this map @ @ @ @ @ @ @ @ @ @ in CGXExcelReaderImpl . ( For more details on this class , please refer to the online help . ) <p> One rather confusing aspect of these maps requires mentioning . You can see from above that although there are two maps ( one for tables and one for handlers ) , they both contain handlers and tables . There is no essential difference between the two as there is with the read maps . The read maps contain tables or handlers . The reason for this is that while the global structure of an Excel file is largely composed of table structures , some fields are handler fields ( BOF and EOF , for example ) . Remember that this demarcation is something that we created for convenience and is not laid out in the Excel SDK . Therefore , these maps contain both types of objects . However , you can readily see that in each one , one type of object is more predominant than the other . <p> Another interesting aspect is that these maps can be used to write data in multiple passes . For example @ @ @ @ @ @ @ @ @ @ and then later write these out . The write code can check for pass one and do the actual write with pass two . Passes are more an implementation detail than anything else ; you will not have to use these directly in most cases . <p> In the event that you do have to use passes , please contact our support team for further assistance . The implementation details of passes are not documented and might change in a future version . 50236 @qwx670236 
@@75677724 @4377724/ <h> Customizing your view of the integration build analysis <p> This article explains how to set up views in Klocwork Static Code Analysis . <p> Note for users of previous versions : Scoping functionality has been removed in Klocwork Insight 9.5 . Now , you control what you see in Static Code Analysis issues and reports with views , as described in this article . If you 're confused , see Help - I 'm used to scoping in Klocwork Static Code Analysis . 
@@75677725 @4377725/ <h> Why Closed Source is Better Than Open Source <p> It might seem strange coming from the founder of OpenLogic , a company focused on helping others succeed with open source , but the fact is that closed source is better than open source in certain situations . <p> With closed source <p> 1 . You never have to fix components when something goes wrong <p> With open source , things occasionally go wrong . When this happens , you , or an engineer who owes you a favor , may need to spend time debugging the problem . This entails reading through code , working with an open source community , or your open source support provider , and applying a fix . With closed source , on the other hand , once you determine that the problem lies in your vendor 's code , you 're all done ! All you have to do is file a ticket and wait . Sure , you may have to wait a few months or years for the fix , and sometimes it never comes at all , but there @ @ @ @ @ @ @ @ @ @ back , relax , and hope for the best . <p> 2 . You do n't have to worry about contributing your changes back to a community <p> With open source , there 's an expectation that if you fix a bug or make an improvement , you 'll contribute your code back to the community that can help test and maintain it over time . With closed source , you never have to contribute anything to anybody . Of course , that 's because you ca n't change the code as you do n't have access to it , but you may create your own workarounds to problems you run into . Sure , you might have to keep working around the same issues version after version , but at least you never have to work with the community to make the solution better for others . <p> 3 . You do n't have to think about open source licensing terms and compliance issues <p> With open source , you have to comply with the license terms specified by the components you 're using . It can take some @ @ @ @ @ @ @ @ @ @ versus a General Public License ( GPL ) , for example . Depending on which open source components you use and how you use them ( e.g. , distributing to third parties or using only for internal purposes ) , different license terms may apply ( e.g. , attributing the open source component in your documentation ) . Companies like OpenLogic make it easy to understand and comply with open source licensing terms , but with closed source , you do n't have to worry about any of this ! Your vendor 's license agreement takes away all of your rights to the software and makes it nearly impossible to consider any usage not explicitly approved by your corporate attorneys , so you do n't even have to think about it . Sure , you have to deal with license counting , surprise software compliance audits , terms that worsen over time , and nearly incomprehensible legalese , but at least you do n't have to understand how you 're using open source components . <p> 4 . You do n't have to choose among dozens of options for every @ @ @ @ @ @ @ @ @ @ a database , web server , application server , programming language , GUI framework , and the like . In practically every category , you can find robust offerings built in a variety of languages with different architectural approaches . It 's also very common to find similar tools that are optimized for different use cases ( e.g. , performance versus scalability versus simplicity ) . To make sure a tool will work best for your particular use case , download it and give it a try . With closed source , you do n't have to contend with so many options . You only have to explore two or three large vendors in each market , which saves a lot of time . You can save even more time if the vendors do n't offer free trials , or make it hard to get started by forcing you to pay for a trial or sign trial agreements up front . Sure , you might get a one-size-fits-all solution that does n't quite fit , but the vendor will certainly make it better in the next version . <p> 5 @ @ @ @ @ @ @ @ @ @ shows <p> With open source , it can take some time to find conference presentations , architectural diagrams , screenshots , and other documentation . You might have to read wikis , forums , and email lists to get the information you need about a particular component . With closed source , you 're never more than a phone call away from a nice PowerPoint presentation delivered right in the comfort of your office by professional salespeople in nice suits . Sure , you 'll have to provide your contact information up front and the salespeople will never stop calling you , but at least you do n't have to search the web for glossy slides with beautiful graphics . <p> 6 . You do n't have to look around for technical support <p> You can get open source support from a community , your own engineers , or professional open source support organizations . It can take some time to decide whether you want Service Level Agreement ( SLA ) support with guaranteed response times like you can get from OpenLogic , or if you feel comfortable posting issues @ @ @ @ @ @ @ @ @ @ closed source , you never have to worry about where you 're going to get support . It will come from your vendor 's junior customer representative in a call center in Elbonia . Sure , you might not ever get to speak to an actual engineer , but at least you always know who to call . <p> 7 . You can just throw in the towel <p> With open source , there 's always a way to get something fixed , patched , improved , enhanced , refactored , upgraded , or rewritten . There 's no easy way to throw up your arms and walk away like there is with closed source . Sure , you can curse the community that developed the open source component causing you problems , but you can usually work around the issue , get help from the community or a support organization , or even fix the issue yourself . It 's just not nearly as satisfying as cursing a commercial vendor and calling it a day . <p> So there you have it . Seven good reasons why closed source @ @ @ @ @ @ @ @ @ @ you 'd like to share ? 
@@75677726 @4377726/ <h> 3.3 Logistic Regression <p> Logistic regression is used to model the relationship between a binary response variable and one or more predictor variables , which may be either discrete or continuous . Binary outcome data is common in medical applications . For example , the binary response variable might be whether or not a patient is alive five years after treatment for cancer or whether the patient has an adverse reaction to a new drug . As in multiple regression , we are interested in finding an appropriate combination of predictor variables to help explain the binary outcome . <p> Let be a dichotomous random variable denoting the outcome of some experiment , and let be a collection of predictor variables . Denote the conditional probability that the outcome is present by , where has the form : <p> . <p> If the are varied and the values of are observed , we write : <p> . <p> The logistic regression problem is then to obtain an estimate of the vector : <p> . <p> As with multiple linear regression , the matrix : <p> , <p> is @ @ @ @ @ @ @ @ @ @ containing only the data for the predictor variables ( matrix X without the leading column of 1s ) , is called the predictor data matrix . <p> In practice , several different measures exist for determining the significance , or goodness of fit , of a logistic regression model . These measures include the G statistic , Pearson statistic , and Hosmer-Lemeshowstatistic . In a theoretical sense , all three measures are equivalent . To be more precise , as the number of rows in the predictor matrix goes to infinity , all three measures converge to the same estimate of model significance . However , for any practical regression problem with a finite number of rows in the predictor matrix , each measure produces a different estimate . <p> Commonly a regression model designer refers to more than one measure . If any single measure indicates a low goodness of fit , or if the measures differ greatly in their assessments of significance , the designer goes back and makes improvements to the regression model . <p> Perhaps the most straightforward measure of a goodness of fit is the @ @ @ @ @ @ @ @ @ @ statistic for linear regression . Both the F statistic and the G statistic measure a difference in deviance between two models . For logistic regression , the deviance of a model is defined as : <p> . <p> To determine the overall significance for a model using the G statistic , the deviance for the model and the deviance for the intercept-only model are subtracted . The larger the difference , the greater the evidence that the model is significant . The G statistic follows a chi-squared distribution with p - 1 degrees of freedom , where p is the number of parameters in the model . Significance tests based on this distribution are supported in Analytics.h++ . <p> The Pearson statistic is a model significance measure based more directly on residual prediction errors . In the most straightforward implementation of the Pearson statistic , the predictor matrix rows are placed into J groups such that identical rows are placed in the same group . Then the Pearson statistic is obtained by summing over all J groups : <p> , <p> where is the number of positive observations for group @ @ @ @ @ @ @ @ @ @ is the number of identical rows . The Pearson statistic follows a chi-squared distribution with degrees of freedom , where p is the number of parameters in the model . Significance tests based on this distribution are supported in Analytics.h++ . <p> Because the accuracy of this statistic is poor when predictor variable data are continuous-valued , 2 the statistic in our implementation is obtained by grouping the predictor variable data . In other words , the data values for each predictor variable are replaced with integer values , the logistic regression parameters are recalculated , and the statistic is obtained from the resulting model . This tends to make the value of J much smaller , and the Pearson statistic becomes more accurate . In Analytics.h++ , the default number of groups for each predictor variable is 2 . <p> The Hosmer-Lemeshow statistic takes an alternative approach to grouping : it groups the predictions of a logistic regression model rather than the model 's predictor variable data , which is the Pearson statistic 's approach . In the implementation found in Analytics.h++ , model predictions are split into G @ @ @ @ @ @ @ @ @ @ statistic is computed as : <p> , <p> where is the number of positive observations in group j , is the model 's average predicted value in group j , and is the size of the group . The Hosmer-Lemeshow statistic follows a chi-squared distribution with G - 2 degrees of freedom . In Analytics.h++ , the default value for G is 10 . <p> The p-value for each parameter estimate is the probability of seeing the value of the calculated parameter using the above formula , or something more extreme , if the hypothesis is true . Note that in general the sample size must be large in order for the p-value to be accurate . <p> The critical values , , for the parameter estimates are the levels at which , if the absolute value of the Wald chi-square statistic calculated for a given is greater than , we reject the hypothesis at the specified significance level . 
@@75677727 @4377727/ <h> Getting email notification of new issues <p> If your Klocwork Server is set up for email notifcation , you can receive emails to warn you when a new issue appears after a system build or when another Klocwork user assigns you an issue . In the former case , you must be the file owner to receive notifications after a system build . For more information on ownership , see Tracking issues by owner . <p> By default , your Static Code Analysis profile is configured to receive email notification , but you can turn emails on and off in your profile , and you can also change your default email address . To make changes to your profile : 
@@75677728 @4377728/ <h> Microservices <p> Service Oriented Architecture remains a solid foundation for enterprises , and has diverged to include APIs and microservices . APIs help with the consumption and distribution of business capabilities as sharable services , and now the emergence of the microservices paradigm delivers flexibility and scalability to the development and deployment of service-based applications . <p> Akana helps enterprises to build web-scale , distributed and decoupled applications that are composed of microservices . Akana enables policy based DevOps automation and a runtime platform that provides service discovery , registry , security enforcement , scaling , routing and auditing of microservices on a variety of containerization and/or cloud platforms . <h> Componentization <p> Akana helps enterprises deliver applications as a series of microservices ( components ) that operate independently from each other . <p> Identify appropriate components for delivery as microservices <p> Manage the versions and lifecycle of each microservice independently <p> Manage the application topology as a set of related blueprints to understand dependencies <h> Scalability &amp; Resilience <p> Scale your applications up and down on demand to meet the rapidly growing and changing nature of your @ @ @ @ @ @ @ @ @ @ real-time usage needs <p> Provide high-availability with load-balancing over just enough redundant instances to support load should one instance fail <p> Automate the registration and discovery of microservices instances with container configuration tasks <h> DevOps <p> One of the core tenets of microservices is that Developers are responsible for deploying and operating their own code . In this environment , it is even more critical than ever to provide effective control and auditing over the complete SDLC including the deployment blueprint . <p> Manage the development lifecycle and assets , including the application topology and deployment blueprints <p> Maintain an audited approval process to control changes to key assets <h> Monitoring &amp; Analytics <p> Understand the health , performance , and usage of a distributed application is never easy . Breaking an application up into completely independent microservices further complicates this challenge . <p> Operate and manage each microservice independently while retaining central visibility into performance and behavior <p> Audit and track transactions through the entire system for optimization and root cause analysis <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security @ @ @ @ @ @ @ @ @ @ large organizations succeed in API security . 
@@75677729 @4377729/ <h> 8.2 Features of Docking Windows <p> The Objective Toolkit docking windows architecture adds a host of features to the existing MFC control bar architecture . When docked , you can resize dockable windows using splitter bars that are along the window 's edge . The following figure shows how docking windows appear when docked . <p> Another significant feature added by the extended control bar architecture is the ability to float a control bar as an MDI child window and then turn it back into a docking control bar . When it is floating , a dockable window can be resized horizontally , vertically , and diagonally . <p> When it is floating as an MDI child , the docking window is clipped to the MDI application frame . Docking windows floating outside of the main frame are not constrained . <p> Each dockable window stretches automatically when resized . You can implement your own , alternate form of resize handling . In addition , each dockable window has a default context menu that you can access by right-clicking . The default context menu contains Hide and Allow @ @ @ @ @ @ @ @ @ @ remove menu items from the context menu . 50236 @qwx670236 
@@75677730 @4377730/ <h> Life Sciences &amp; Healthcare Solutions <p> For over 40 years , IMSL Numerical Libraries and PV-WAVE Family of products have been key components of high performance data analysis and visualization solutions in a broad range of industries . Individual programmers , major corporations , academic institutions and research labs around the world trust the accuracy , reliability and the power of our solutions to perform sophisticated data analysis and turn data into meaningful information . <p> For customers that are developing or using applications for data and visualization analysis in Life Science and Medical industries , we have the components , the tools and the consulting expertise to reduce development time , save costs , accelerate time to market and , most importantly achieve accurate , reliable results . 
@@75677731 @4377731/ <p> You see a list of projects for which you have permissions on the current Klocwork Server host and port . <p> For any project in the list , click the New or Open issues link . <h> Understanding the issue list <p> Here 's an issue list for the open-source project CVS : <p> What you see is controlled by : <p> the current view , shown beside the project name . Any constraints on the list are noted to the right of the view name . Our example uses the default view , which in this example has no constraints . <p> what appears in the Search field . In our example , because we clicked Open issues , the Search field reads : status : +Analyze , +Fix . If the build is not specified , issues from the most recent build are shown . See Searching in Static Code Analysis for more information on search syntax . 
@@75677734 @4377734/ <h> 14.2 Types of SOAP Handlers <p> HydraExpress supports four categories of handlers : <p> transport handlers <p> request handlers <p> response handlers <p> fault handlers <p> It is important to understand how each type of handler is processed in the Agent in order to select the best handler for your needs . Figure 8 illustrates how handlers are invoked in a client application and in the Agent . How each handler is affected by this invocation is discussed in the following sections . <p> This diagram is based on a request-response message pattern . For a one-way request , the client sends the request but the Agent does not send a return message , so the response handlers are not invoked ; conversely , for a notification pattern , the request originates in the Agent and the client does not send back a response . For solicit-response , the Agent sends the request , and the client does respond , so the order is simply reversed . <p> The transport handlers are those closest to the actual transport , hence the name . <p> On the client side @ @ @ @ @ @ @ @ @ @ last handlers run before the request is sent . If there is a response from the server , the same transport handlers are invoked in reverse order , to process and transform the response message . <p> On the server side , transport handlers are the first handlers invoked after an incoming request is received . If a response is needed , the transport handlers are invoked in reverse order before the response message is sent back to the calling client <p> The HydraExpress framework guarantees that the transport handlers are invoked on both incoming and outgoing messages ( whether the message is a request or response ) . This is true even when message handling is interrupted , as described in Section 14.4.2.3 , " Aborting Handler Processing . " <p> Since the SOAP message is treated as a simple string payload when a transport handler is run , transport handlers are most suitable for tasks that have to be performed on the entire message . This includes tasks such as encryption/decryption , **25;6883;TOOLONG , etc . For tasks that need to access specific parts of a SOAP message @ @ @ @ @ @ @ @ @ @ response handler . <p> On the server , request handlers are invoked on incoming requests immediately after all of the transport handlers have been invoked ; on the client , they are invoked immediately before the transport handlers are invoked . See Figure 8 . <p> On the server , the first request handler to get invoked is always the SOAP message handler generated by HydraExpress . This handler parses the SOAP message and makes parts of the message available through methods of the rwsf : : CallInfo object associated with the request . You can create additional handlers , as described later in this chapter . <p> On the server , response handlers are invoked on outgoing responses immediately before the transport handlers are invoked ; on the client , they are invoked immediately after the transport handlers have been invoked . See Figure 8 . <p> On the server , the SOAP message handler generated by HydraExpress is always invoked on the outgoing message as the last response handler before the transport handlers . This is true even though it does not appear in the **25;6910;TOOLONG element of @ @ @ @ @ @ @ @ @ @ server-side handlers and discussed in Section 14.5.2 ) . <p> A single SOAP message handler can function either as a request message handler , a response message handler , or both . The rwsf : : CallInfo interface provides methods for determining whether the message is a request or response . <p> The rwsf : : CallInfo : : isRequest() method returns true for a request message , causing the SOAP message handler to parse the message as an incoming request . This method returns false for a response message , causing the SOAP message handler to construct the SOAP response message . You , too , can use this method to create a handler that serves as both a request and a response handler , but note that such custom handlers must be configured in both the &lt;request-handlers&gt; and **25;6977;TOOLONG elements of **38;7004;TOOLONG , discussed in Section 14.5.2 . <p> In fact , rwsf : : CallInfo also has an isClient() method that returns true on the client side and false on the server side . With this method , a single handler could be used for both request @ @ @ @ @ @ @ @ @ @ . <p> Fault handlers are invoked in cases where an exception is thrown during message processing . They can be used to provide custom message handling in such cases . The exception message is stored in the rwsf : : CallInfo object as a string property named rwsf:FaultMessage , and can be accessed by invoking getStringProperty ( " rwsf:FaultMessage " ) on the rwsf : : CallInfo object . <p> Fault handlers behave differently on the client and server sides . <p> On the client side , after the fault handler is invoked the exception is rethrown . <p> On the server side , before the fault handler is invoked the response is set to a rwsf : : ServerFault , which contains the exception message . Then the fault handler is invoked , giving you the option of changing the response as needed . After the fault handler completes processing , no other handlers , including transport handlers , are invoked before the response is sent back to the client . <p> The Rogue Wave name and logo are registered trademarks of Rogue Wave Software , and HydraExpress is @ @ @ @ @ @ @ @ @ @ are the property of their respective owners.Contact Rogue Wave about documentation or support issues . 
@@75677735 @4377735/ <h> Format of the build specification file for C# projects <p> The Klocwork build specification for C# projects , named &lt;input-file&gt;.out by default , is a text file in semicolon-separated format . <p> The build specification is divided into compilation units , each containing a " cscompile " and " csconfig " line . Each of these compilation units has a unique identifier of the form CS&lt;number&gt; , for example , CS1 , CS2 , etc . <p> The first field is a tag to identify the type of line . The possible tags are as follows : <p> Tag <p> Description <p> version <p> build specification format version <p> csconfig <p> user compiler configuration <p> cscompile <p> used to track compiler execution <h> version line <p> The version line is used to define the build specification format version . It must be the first line in the build specification . Only one version line may appear in a build specification . <p> Example version line : <p> version ; 105 <p> The three-digit integer is used to encode the version . The first ( left-most ) digit encodes @ @ @ @ @ @ @ @ @ @ ) ; the last two digits encode the minor version ( " 05 " in above example , resulting in the " 1.5 " full version code ) . <h> csconfig line <p> The csconfig line is used to record the configuration used by the native compiler . 
@@75677736 @4377736/ <h> IBM APIs and SOA <p> Akana provides ready-to-use API Management and SOA Governance Automation for IBM WebSphere . This provides for automation of API and SOA framework . Starting with API conception , the Akana solution ensures the easy and uniform application of patterns and policies all the way to API consumption throughout the entire IBM software stack . With Akana , enterprises can install and configure a comprehensive API Management and SOA Governance solution without having to integrate a broad array of components through custom development or professional services . <h> Ready-to-use API Management Automation <p> Akanas solution creates an end-to-end API framework from Rational , Tivoli and WebSphere products without requiring labor-intensive integrations . Akanas products maximize use of IBM stack by automating the entire lifecycle of planning , building , running , and sharing services . It is ready-to-use right out of the box : <h> API and SOA Unification <p> Akana delivers a unified end-to-end solution that addresses the needs of all the constituents of an API ecosystem , including architects , developers and engineers . It provides a unified governance solution that fuses @ @ @ @ @ @ @ @ @ @ environment : <p> Federation of business services and business organizations through a unified API Governance system . <p> Functional and organizational collaboration through all phases of the API lifecycle . <h> Flexible API Management for API <p> Akana offers flexibility for IBM customers and their API Management deployments . Customers may chose to have IBM WebSphere DataPower as a hardened appliance in the DMZ but deploy a software gateway both in the cloud and internally that can quickly adopt new web standards such as JWT and OpenId to provide more robust orchestration . Akanas API Management solution enables management of a service or API as it is deployed across each gateway , providing the flexibility to choose where to deploy the service or API configuration , all through a single console . <h> Leverage IBM WebSphere DataPower Investment <p> Akana simplifies the management of Datapower appliances by providing centralized policy definition and service monitoring . Provides easy management of API configurations across several Datapower appliances , federate the management of the APIs on the Datapower appliance out to line of businesses , and reduce the operational bottleneck while still maintaining @ @ @ @ @ @ @ @ @ @ as a single entity . <p> Create new APIs without requiring new service development or re-configuring existing backend systems <p> Centrally define policies and apply them to APIs distributed across multiple DataPower appliances <h> Analytics and Monitoring <p> Akanas API Management solution provides in depth monitoring and analytic capabilities . Datapower customers have single view of an APIs operational monitoring logs across all Datapower appliances in a cluster . In addition , it provides a single view of an API consumption data and will gain instant insights into the business and optimize the delivery and value of APIs : <p> Gain visibility into API and appliance performance , individual messages , and business transactions from a single administration console <p> Monitor and enforce service level agreements ( SLAs ) for services distributed across a cluster of appliances , generating alerts for faults , performance issues and security violations . <h> Secure Bridge to IBM Bluemix <p> The allure of mobile-borne customer interactions and cloud development can lead business into ad-hoc integration and security woes when exposing enterprise data . Akana offers a platform for an API-based hybrid cloud development model @ @ @ @ @ @ @ @ @ @ oversight that makes app development sustainable . <p> Publish all relevant data on premise and in the cloud as APIs . <p> Easily browse , search and locate data needed for app development . <p> Secure the data , grant and revoke access to the data with the ability to monitor and perform compliances checks . 
@@75677737 @4377737/ <p> The class RWCSubString allows some subsection of an RWCString to be addressed by defining a starting position and an extent . For example the 7th through the 11th elements , inclusive , would have a starting position of 7 and an extent of 5 . The specification of a starting position and extent can also be done in your behalf by such functions as RWCString : : strip() or the overloaded function call operator taking a regular expression as an argument . There are no public constructors -- RWCSubStrings are constructed by various functions of the RWCString class and then destroyed immediately . <p> A zero length substring is one with a defined starting position and an extent of zero . It can be thought of as starting just before the indicated character , but not including it . It can be used as an lvalue . A null substring is also legal and is frequently used to indicate that a requested substring , perhaps through a search , does not exist . A null substring can be detected with member function isNull() . However , it can @ @ @ @ @ @ @ @ @ @ a 's data into the substring b(2,3) . The number of elements need not match : if they differ , b will be resized appropriately . Sets self 's extent to be the length of the assigned RWCString . If self is the null substring , then the statement has no effect . Returns a reference to self . <p> RWCSubString&amp; operator= ( const RWCSubString&amp; ) ; <p> Assignment from an RWCSubString . The statements : <p> RWCString a ; RWCString b ; ... b ( 2 , 3 ) = a(5,5) ; <p> will copy 5 characters of a 's data into the substring b(2,3) . The number of elements need not match : if they differ , b will be resized appropriately . Sets self 's extent to be the extent of the assigned RWCSubString . If self is the null substring , then the statement has no effect . Returns a reference to self . <p> Note that the number of characters selected need not match : if they differ , str will be resized appropriately . Sets self 's extent to be the strlen() of the @ @ @ @ @ @ @ @ @ @ , then the statement has no effect . Returns a reference to self . <p> Returns the ith character of the substring . The first variant can be used as anlvalue , the second can not . The index i must be between zero and the length of the substring , less one . Bounds checking is performed : if the index is out of range , then an exception of type RWBoundsErr will occur . <p> char&amp; operator() ( sizet i ) ; char operator() ( sizet i ) const ; <p> Returns the ith character of the substring . The first variant can be used as anlvalue , the second can not . The index i must be between zero and the length of the substring , less one . Bounds checking is enabled by defining the pre-processor macro RWBOUNDSCHECK before including &lt;rw/cstring.h&gt; . In this case , if the index is out of range , then an exception of type RWBoundsErr will occur . 
@@75677739 @4377739/ <p> This is a complete example of a direct subtype of the IlvManagerViewInteractor class . It allows the user to move a graphic object to another location by dragging it with the mouse . Here is the declaration of this class ( it can also be found in the header file **34;7044;TOOLONG ) : <p> class IlvMoveInteractor <p> : public IlvManagerViewInteractor <p> <p> public : <p> **29;7080;TOOLONG manager , <p> IlvView* view ) <p> : **32;7111;TOOLONG , view ) , <p> move(0) <p> virtual IlBoolean **25;7145;TOOLONG event ) ; <p> virtual void handleExpose ( IlvRegion* clip = 0 ) ; <p> virtual void drawGhost() ; <p> void drawGhost ( const IlvRect&amp; , <p> IlvRegion* clip = 0 ) ; <p> void drawGhost ( IlvGraphic* , IlvRegion* clip = 0 ) ; <p> virtual void doIt ( const IlvPoint&amp; ) ; <p> const IlvRect&amp; getRectangle() const return xorrectangle ; <p> protected : <p> IlvPos deltax , deltay ; <p> IlvRect bbox ; <p> IlvGraphic* move ; <p> IlvRect xorrectangle ; <p> IlBoolean wasSelected ; <p> void handleButtonDown ( const IlvPoint&amp; ) ; <p> void **25;7172;TOOLONG IlvPoint&amp; ) ; <p> void @ @ @ @ @ @ @ @ @ @ interactor let 's you select and deselect objects by clicking on them with the left mouse button and the Shift key pressed . You can move an object or a set of selected objects but you can not resize them . <p> The following protected fields are used in this class : <p> deltax , deltay - Stores the distance between the mouse and the top-left corner of the objects being moved . <p> bbox - Stores the bounding box of the objects being moved . <p> move - Keeps a pointer to the object being moved . <p> xorrectangle - Stores the rectangle dragged to mark a region . <p> wasSelected - Keeps a Boolean value indicating whether the designated object was selected before it was moved . This information is required because the object is selected when you start to move it . There are two different cases in this interactor , depending on whether one or more object is being moved . If more than one object is moved , a moving rectangle that encloses the bounding boxes of these objects is displayed . Otherwise , the moving @ @ @ @ @ @ @ @ @ @ on mouse events . All other events are dispatched to accelerators by a call to IlvManager : : shortCut , but only if an object is not being moved at this point . This is because some accelerators might remove the object being worked on , which can be dangerous . The handleEvent() function returns IlTrue if it has consumed the event and IlFalse otherwise . <p> IlBoolean <p> IlvMoveInteractor : : **25;7199;TOOLONG event ) <p> <p> IlBoolean consumed = IlFalse ; <p> switch ( event.type() ) <p> case IlvButtonDown : <p> xorrectangle.w(0) ; <p> move = 0 ; <p> if ( event.modifiers() &amp; ( IlvLockModifier IlvNumModifier ) ) <p> consumed = IlTrue ; <p> **40;7226;TOOLONG ; <p> return consumed ; <p> <p> if ( event.button() ! = IlvLeftButton ) <p> consumed = **31;7268;TOOLONG , getView() ) ; <p> return consumed ; <p> <p> if ( ! event.modifiers() ) <p> consumed = IlTrue ; <p> **25;7301;TOOLONG ( event.x() , event.y() ) ) ; <p> else <p> IlvManager* manager = getManager() ; <p> if ( event.modifiers() &amp; IlvShiftModifier ) <p> consumed = IlTrue ; <p> IlvPoint p ( event.x ( ) @ @ @ @ @ @ @ @ @ @ p , getView() ) ; <p> IlvDrawSelection* sel = 0 ; <p> if ( obj ) sel = getSelection(obj) ; <p> if ( ! sel &amp;&amp; obj &amp;&amp; **31;7328;TOOLONG ) <p> LONG ... <p> <p> else <p> consumed = **26;7361;TOOLONG , getView() ) ; <p> <p> break ; <p> case IlvButtonUp : <p> if ( event.button() == IlvLeftButton ) <p> consumed = IlTrue ; <p> handleButtonUp ( IlvPoint ( event.x() , event.y() ) ) ; <p> else <p> consumed = **31;7389;TOOLONG , getView() ) ; <p> <p> break ; <p> case IlvButtonDragged : <p> if ( event.modifiers() == IlvLeftButton ) <p> consumed = IlTrue ; <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> handleButtonDragged(p) ; <p> <p> break ; <p> default : <p> if ( ! move ) <p> consumed = **31;7422;TOOLONG , getView() ) ; <p> break ; <p> <p> return consumed ; <p> <p> The following types of events are handled by the handleEvent member function : <p> Only the left button is handled . If the event involves another mouse button , the event is ignored and dispatched to manager accelerators : <p> @ @ @ @ @ @ @ @ @ @ **31;7455;TOOLONG , getView() ) ; <p> return consumed ; <p> <p> The handleButtonDown member function is called if there is no event modifier : <p> if ( ! event.modifiers() ) <p> consumed = IlTrue ; <p> **25;7488;TOOLONG ( event.x() , event.y() ) ) ; <p> <p> If the Shift modifier is set , the selection state of the object pointed to by the mouse is toggled : <p> if ( event.modifiers() &amp; IlvShiftModifier ) <p> consumed = IlTrue ; <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> IlvGraphic* obj = **26;7515;TOOLONG , getView() ) ; <p> IlvDrawSelection* sel = 0 ; <p> if ( obj ) sel = getSelection(obj) ; <p> if ( ! sel &amp;&amp; obj &amp;&amp; **31;7543;TOOLONG ) <p> LONG ... <p> <p> <p> Button-Up Events <p> If the event comes from the left button , handleButtonUp is called . Otherwise , the event is dispatched to accelerators . <p> case IlvButtonUp : <p> if ( event.button() == IlvLeftButton ) <p> consumed = IlTrue ; <p> handleButtonUp ( IlvPoint ( event.x() , event.y() ) ) ; <p> else <p> consumed = **31;7576;TOOLONG , getView() @ @ @ @ @ @ @ @ @ @ The handleButtonDragged member function is called , but only if the event comes from the left button . <p> case IlvButtonDragged : <p> if ( event.modifiers() == IlvLeftButton ) <p> consumed = IlTrue ; <p> IlvPoint p ( event.x ( ) , event.y() ) ; <p> handleButtonDragged(p) ; <p> <p> break ; <p> drawGhost Member Function <p> This member function is split in three parts : the common part , which is the entry point from the member function handleEvent , and two others , depending on the type of translation being done . <p> If there is only one selected object , a specific drawGhost is called for this object . Otherwise , another drawGhost function that handles a rectangle is called : <p> void <p> IlvMoveInteractor : : drawGhost() <p> <p> if ( ! xorrectangle.w() ) return ; <p> if ( **34;7609;TOOLONG == 1 ) <p> drawGhost(move) ; <p> else <p> drawGhost(xorrectangle) ; <p> drawGhost for a Rectangle <p> This member function is called if there is more than one selected object . It displays the bounding box of all the selected objects being moved in the view @ @ @ @ @ @ @ @ @ @ <p> void <p> IlvMoveInteractor : : drawGhost ( const IlvRect&amp; rect , IlvRegion* clip ) <p> <p> if ( ! rect.w() ) return ; <p> IlvManager* manager = getManager() ; <p> if ( clip ) **36;7645;TOOLONG ( clip ) ; <p> LONG ... <p> if ( clip ) **36;7683;TOOLONG ( ) ; <p> <p> drawGhost for an Object <p> This member function is called if there is only one selected object . It displays the object at its new coordinates by calling the draw member function after its palette has been set to XOR mode . The new coordinates are computed from the difference between the coordinates of the rectangle being dragged and the coordinates of the original bounding box of the object : <p> void <p> IlvMoveInteractor : : drawGhost ( IlvGraphic* obj , IlvRegion* clip ) <p> <p> if ( ! **32;7721;TOOLONG ! xorrectangle.w() ) <p> return ; <p> IlvPos tempdx , tempdy ; <p> if ( getTransformer() ) <p> IlvRect r1(xorrectangle) ; <p> IlvRect r2(bbox) ; <p> **32;7755;TOOLONG ; <p> **32;7789;TOOLONG ; <p> tempdx = r1.x() - r2.x() ; <p> tempdy = r1.y() - r2.y() ; <p> @ @ @ @ @ @ @ @ @ @ = xorrectangle.y() - bbox.y() ; <p> <p> obj-&gt;translate ( tempdx , tempdy ) ; <p> **27;7823;TOOLONG ; <p> obj-&gt;draw ( getView ( ) , getTransformer() , clip ) ; <p> **27;7852;TOOLONG ; <p> **25;7881;TOOLONG , -tempdy ) ; <p> <p> doIt Member Function <p> The doIt member function must apply the translation to all selected objects . The delta parameter gives the translation vector expressed in the view coordinate system so it must be converted to the object coordinate system . Then the objects must be translated . This can not be done by calling the IlvGraphic member functions directly ; it must be done by the manager . Here , IlvManager : : applyToSelections calls TranslateObject for each selected object : <p> void <p> **27;7908;TOOLONG object , IlAny argDelta ) <p> <p> IlvPoint* delta = ( IlvPoint* ) argDelta ; <p> **28;7937;TOOLONG ( ) , delta.y() ) ; <p> <p> void <p> IlvMoveInteractor : : doIt ( const IlvPoint&amp; delta ) <p> <p> IlvPoint origin ( 0 , 0 ) , <p> tdelta(delta) ; <p> if ( getTransformer() ) <p> **36;7967;TOOLONG ; <p> **36;8005;TOOLONG ; <p> <p> IlvPoint dp @ @ @ @ @ @ @ @ @ @ <p> LONG ... &amp;dp ) ; <p> <p> handleButtonDown Member Function <p> The handleButtonDown member function selects the object to be moved , storing its previous state in wasSelected . Then , it computes the bbox field by means of a call to the ComputeBBoxSelections function . This function returns in bbox the bounding box of all the selected objects : <p> The first part initializes the result to the empty rectangle , and then queries the manager for all the selected objects . nbselections is the number of selected objects in the array objs : <p> bbox.resize ( 0 , 0 ) ; <p> IlUInt nbselections ; <p> IlvGraphic** objs = **39;8043;TOOLONG ; <p> The next part starts a loop to scan every object : <p> IlvRect rect ; <p> for ( IlUInt i=0 ; i &lt; nbselections ; i++ ) <p> This next part reads the bounding box of each object , transformed in the view coordinate system , and adds it to the result : <p> **26;8084;TOOLONG , t ) ; <p> for ( IlUInt i=0 ; i &lt; nbselections ; i++ ) <p> **26;8112;TOOLONG , t @ @ @ @ @ @ @ @ @ @ <p> If there is a moving object and if it is moveable , the dragging position is snapped to the manager grid ( if one exists ) and a new xorrectangle is computed . Then , the member function ensureVisible makes sure that the point the user drags will remain on the visible part of the view : <p> void <p> IlvMoveInteractor : : **25;8140;TOOLONG IlvPoint&amp; point ) <p> <p> if ( ! move ) return ; <p> IlvPoint p = point ; <p> IlvRect rect ; <p> if ( **33;8167;TOOLONG ) <p> if ( xorrectangle.w() ) drawGhost() ; <p> p.translate ( deltax , deltay ) ; <p> **35;8202;TOOLONG ( ) , p ) ; <p> p.translate ( -deltax , -deltay ) ; <p> xorrectangle.move ( p.x ( ) + deltax , p.y() + deltay ) ; <p> **26;8239;TOOLONG ( ) , bbox.h() ) ; <p> ensureVisible(p) ; <p> drawGhost() ; <p> <p> <p> handleButtonUp Member Function <p> If there are objects to move , they are translated by calling the member function doIt . Otherwise , the last designated object is deselected : 
@@75677740 @4377740/ <p> Like RWDBInserter , RWDBBulkInserter is a class designed to insert data into database tables . The main difference between RWDBBulkInserter and RWDBInserter is that arrays of values are shifted into RWDBBulkInserter for each column in the table , while scalar values are shifted into RWDBInserter . These arrays are passed by reference and need to stay in scope for the duration of the inserter . The classes RWDBVector&lt;T&gt; , RWDBDateVector , RWDBStringVector , and RWDBBinaryVector are used for inserting simple numeric types , dates , strings , and binary data respectively . <p> RWDBBulkInserter is designed around the Interface/Implementation paradigm . An RWDBBulkInserter instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBBulkInserter implementation is a base class from which a family of database-specific implementations is derived . <p> Default constructor . Creates an RWDBBulkInserter whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience ; for example , for declaring an array of RWDBBulkInserters . Usable RWDBBulkInserters are obtained from valid RWDBTables . <p> RWDBBulkInserter ( const RWDBBulkInserter&amp; @ @ @ @ @ @ @ @ @ @ shares an implementation with ins. 
@@75677742 @4377742/ <h> Constructor &amp; Destructor Documentation <p> Initializes a new instance of the IlvMenuBar class . The size of the object is computed by calling the IlvGadget : : fitToContents method . If you want the menu bar to have a specific size , use a constructor that takes an IlvRect reference instead of an IlvPoint object as parameter . The labels are copied . <p> Initializes a new instance of the IlvMenuBar class . The size of the object is computed by calling the IlvGadget : : fitToContents method . If you want to give the menu bar a specific size , use a constructor that takes an IlvRect reference instead of an IlvPoint object as parameter . The items are copied . <p> Uses rect to return the internal bounding box of the bar when the object is computed with the transformer t . The internal bounding box delimits the area within which the bar items are drawn . You can override this member function in a subclass to change the internal bounding box . 
@@75677743 @4377743/ <p> This callback is invoked just before the allocation of database- specific environment/context handle . It is defined as a no-op . To implement preEnvAllocate callback , you will need to derive from this class and redefine this method . <p> virtual void postEnvAllocate() ; <p> This callback is invoked after the allocation of database **28;8267;TOOLONG handle . It is defined as a no-op . To implement postEnvAllocate callback , you will need to derive from this class and redefine this method . <p> virtual void preEnvDestroy() ; <p> This callback is invoked just before the deallocation of environment/context handle . It is defined as a no-op . To implement preEnvDestroy callback , you will need to derive from this class and redefine this method . This callback will typically be called from the destructor of the RWDBDatabase object and , hence , you should refrain from throwing an exception <p> virtual RWDBConnCallback produceConnCallback() ; <p> This method must produce a new instance of a connection callback implementation . This method is invoked by an RWDBDatabase object while producing a new RWDBConnection object . The RWDBConnCallback object produced by @ @ @ @ @ @ @ @ @ @ . <p> This method produces an uninitialized connection callback object with all connection callbacks as no-ops . To produce custom connection callbacks , you will need to derive from this class and redefine this method to produce new instances of connection callbacks using the macro **26;8297;TOOLONG . <p> Sets an error on self . Optionally , invalidates the RWDBDatabase object to which self is associated . <p> Parameters code , message , vendorMessage1 , vendorMessage2 , vendorError1 , vendorError2 and isTerminal are RWDBStatus attributes used to set the error on self 's RWDBStatus object . <p> The parameter invokeErrorHandler indicates if the associated error handler should be invoked . <p> The parameter invalidateDatabase indicates if the RWDBDatabase object to which self is associtaed should be invalidated . If invalidated , the RWDBDatabase object will have an error code of RWDBStatus : : applicationError. 
@@75677744 @4377744/ <h> Which type of checker to create : KAST or Path ? <p> Klocwork supports two different types of custom checker : those written against the Klocwork abstract syntax tree ( KAST ) and those written against the intermediate representation ( Path ) . <p> KAST checkers are useful for finding syntax-related oddities or idioms that you wish to control , for example as part of a style or coding guideline . KAST checkers operate against the abstract syntax tree that the Klocwork compiler generates from a source module , and work by searching that tree in a hierarchical fashion to locate code constructs that are to be reported . KAST is an XPath-like domain specific language that provides operators and functions that support the construction of declarative statements identifying the appropriate part of the syntax tree . Klocwork 's Checker Studio can be used to prototype KAST expressions and provides a fast way of creating pure KAST checkers . <p> If a KAST checker requires conditions that are n't available through Klocwork 's standard built-in functions , you can create custom functions using a simple C API . @ @ @ @ @ @ @ @ @ @ in your KAST expression and specify in your checker definition the name of the library that contains the function . ( For a list of built-in functions , launch Checker Studio , and go to Help &gt; Help topics &gt; KAST reference &gt; C/C++ KAST built-in functions reference . ) <p> Path checkers search for control-flow and data-flow issues , including interprocedural flows . Path checkers operate against an intermediate representation of the code that is called MIR . This structure is like a flowchart , in which each function in the source is represented by a control-flow graph composed of MIR nodes , each node encoding an operation in first order logic and a potential set of incoming and outgoing edges . Path checkers must be written in C++ , and follow the control-flow paths through the MIR , searching for the defect you 've identified . A typical Path checker tracks a value from a source ( a starting point for analysis ) to a sink ( the end point where the defect is detected ) , using the source and sink ' trigger ' points you specify . 
@@75677748 @4377748/ 50231 @qwx670231 <p> Dockable container class . <p> Library : ilvadvgdt <p> The IlvDockableMainWindow class is a subclass of IlvDockableContainer for managing the main window of a standard application that use docking panes . An IlvDockableMainWindow object is a vertical dockable container that defines a default layout that makes it possible to add docking panes by specifying a position relative to other docking panes . Using this class , you do n't have to know the complete hierarchy of the dockable containers , which can be complex to understand and manage . Instead , you can think of your application main window as a simple list of docking panes . <h> Member Function Documentation <p> Adds the specified pane to the dockable container using a position relative to another pane . <p> This methods use relativePaneName and relativePanePosition to find the dockable container and the index in this container where pane must be added . Then it calls IlvDockableContainer : : addDockingPane on this container . 50234 @qwx670234 <p> pane <p> The pane to be added . <p> relativePaneName <p> The name of the pane to which pane will @ @ @ @ @ @ @ @ @ @ pane compared to the pane whose name is given by relativePaneName . Valid values are : IlvLeft , IlvRight , IlvBottom , IlvTop. 
@@75677749 @4377749/ <h> 2.2 Interface and Implementation Classes <p> The design of DBTools.h++ uses the Interface/Implementation paradigm . Interface classes model objects in the application domain . Each interface class has an associated implementation class , which is used to implement the semantics defined by the interface class . <p> NOTE : Interface classes are public , and model objects in the application domain . Implementation classes are private , and implement the semantics of their associated interface classes . <p> This paradigm is familiar to most C++ programmers . For example , many beginning texts present examples of simple classes like string that follow the paradigm . A typical string class might be designed as an interface class that defines the semantics of the class and contains a pointer to a reference-counted implementation class , which provides the services of data storage , memory management , and so on . <p> The public class hierarchy of DBTools.h++ consists of a set of interface classes that are concrete , as opposed to abstract . These concrete classes function as is without requiring further derivation . As interface classes , they do @ @ @ @ @ @ @ @ @ @ each interface class instance consists of a pointer to an implementation class instance , and forwards all function calls to it . The implementation classes are not part of the public hierarchy . Only the interface classes are visible to the application programmer . <p> The interface classes are divided into classes that contain a pointer to a database-dependent implementation and those that do not . In general , classes that model database concepts , like RWDBTable and RWDBSelector , have pointers to database-dependent implementations , while classes that model database-independent concepts , like RWDBDateTime and RWDBExpr , do not . Figure 2 shows the class hierarchy of the public DBTools.h++ classes . <p> Note that all DBTools.h++ implementation classes can be considered abstract classes , containing virtual functions . These virtual functions will be overridden in the derived classes that make up the database-dependent access libraries . <p> For example , class RWDBDatabase is an abstraction that represents a database . It offers a rich set of semantics : you have access to database objects like tables , views , and stored procedures ; you can manage multiple connections @ @ @ @ @ @ @ @ @ @ ) constructs , among other things . <p> These semantic elements represent features common to all databases . However , the way a feature is implemented for any particular database depends heavily upon the API provided by the database manufacturer . Consequently , RWDBDatabaseImp , the implementation class associated with RWDBDatabase , is an abstract base class for a family of database-dependent implementation classes-one implementation class for each database manufacturer that DBTools.h++ supports . These database-dependent implementation classes make up the access library for the particular database . Figure 3 shows this relationship . <p> Notice also from Figure3 that classes RWDBDatabase and RWDBDatabaseImp reside in the DBTools.h++ core library , while RWDBSybDbLibDatabaseImp and RWDBOracleDatabaseImp reside in separate DBTools.h++ access libraries . This is the key to database portability in DBTools.h++ . The core library--and therefore , your application--does n't care which databases it works with . The core library serves as a software backplane for plugging in different access libraries interchangeably . When using shared libraries or DLLs , you can even plug in access libraries at runtime without relinking your application . 
@@75677751 @4377751/ <h> Tutorial 1 : Creating a view for a group of developers <p> Say you 're a development manager and you want to monitor the activity of the group of developers you manage . <p> Note : This tutorial assumes that you : <p> have set up access control <p> assign issues to owners <p> First you create a user group for your developers . This is n't mandatory , because you can specify as many individual owners as you like in a view , but specifying a group just makes the view easier to maintain . <h> Create a user group <p> Go to User Management by clicking Users at the top left . <p> If you do n't see Users , you likely do n't have permissions to create accounts , so you 'll need to contact your Klocwork administrator for this step . <p> Click Create a new account or group next to Accounts . <p> Make sure group is selected , enter a name for your group , and click OK . <p> We 'll call our new group Dev Team 2 . <p> Enter @ @ @ @ @ @ @ @ @ @ Add . Suggestions will appear when you start typing . <h> Create a view for this group <p> Go back to the Projects list by clicking Projects at the top left . <p> Click the project you want to create a view for . The project details appear on the right . 
@@75677753 @4377753/ <h> 17.5 The Debug Version of Tools.h++ <p> You can build the Tools.h++ library in a debug mode , and gain a very powerful tool for uncovering and correcting internal errors in your code . <p> To build a debug version of the library , you must compile the entire library with the preprocessor flag RWDEBUG defined . You must compile the entire library and application with a single setting of the flag -- either defined or not defined . The resultant library and program will be slightly larger and slightly slower . See the appropriate makefile for additional directions . <p> The flag RWDEBUG activates a set of PRECONDITION and POSTCONDITION clauses at the beginning and end of critical functions . These pre- and postconditions are implemented with asserts . A failure will cause the program to halt after first printing out the offending condition , along with the file and line number where it occurred . <p> In his landmark book Object-oriented Software Construction , Bertrand Meyer suggests regarding functions as a contract between a caller and a callee . If the caller agrees to abide by @ @ @ @ @ @ @ @ @ @ results that satisfy a set of postconditions . The following comparison shows the usefulness of Meyer 's paradigm in Tools.h++ . Let 's look first at a bounds error in C : <p> char buff20 ; char j = buff20 ; // Bounds error ! <p> Such a bounds error is extremely tough to detect in C , but easy in C++ , as shown below : <p> RWCString buff(20) ; char j = buff20 ; // Detectable bounds error <p> The bounds error is easy to detect in C++ because the operator can be overloaded to perform an explicit bounds check . In other words , when the flag RWDEBUG is set , operator also executes the PRECONDITION clause , as below : <p> In this example , the job of the function insert() is to insert the object pointed to by the argument into a linked list of pointers to objects of type T. The only precondition for the function to work is that the pointer obj not be null . If this condition is satisfied , then the function guarantees to successfully insert the object . The @ @ @ @ @ @ @ @ @ @ macros RWPRECONDITION and RWPOSTCONDITION are defined in &lt;rw/defs.h&gt; and compile out to no-ops , so long as the preprocessor macro RWDEBUG is not defined . Here 's what appears in the makefile : 
@@75677756 @4377756/ <h> 4.3 Transforms of Even and Odd Sequences <p> If the original sequence is an even or odd sequence , there is an additional symmetry that can be exploited . Consider a cosine wave : <p> V(j) = cos(2pj/N) , j=0 , 1 , ... , N1 <p> This is an example of an even sequence , V(j) = V(j) = V(Nj) . It is possible to transform an N-point even or odd real sequence as an N/4-point complex sequence . This is the approach DoubleCosineServer takes . Instead of feeding the server the full N-point real sequence , you give the DoubleCosineServer only the lower half of it , V(j) , j=0 , ... , N/2 , a total of only N/2+1 points . <p> Note that the results are real : the transform of a real even ( or odd ) sequence is a real even ( or odd ) sequence . Also note that the DoubleCosineServer returns only the lower half of that sequence . The global function expandEven() could be used to expand it into the full real sequence . See the RWMathVec description in the SourcePro C++ API Reference Guide . 50235 @qwx670235 
@@75677757 @4377757/ <h> 10.2 Benefits of MDI Alternatives <p> With the release of Windows 95 , Microsoft made it known in The Windows Interface Guidelines for Software Design that they are moving away from MDI in their Office products ; however Microsoft has not provided Windows operating-system-level support or MFC support for any of the MDI alternatives described in their design guide . Currently , MFC only supports the Multiple Document Interface ( MDI ) and Single-Document Interface ( SDI ) , which are waning in popularity . Objective Toolkit proves you with three additional alternatives : MTI , FDI , and WDI . <p> MTI is a combination of SDI and MDI . As in SDI , each top-level window manipulates one document . As in MDI , the user can have multiple documents open simultaneously . MTI creates a new top-level window for each new document . MTI departs from the MDI model in which one parent frame owns and contains every document window . <p> From the user 's standpoint , an MTI application most closely resembles an SDI application because he can only associate one document with @ @ @ @ @ @ @ @ @ @ float freely on the desktop . This approach is common in other GUI operating systems such as the OSF/Motif windowing system for UNIX . It has also become a popular Windows interface . For example , you can easily activate MTI windows from the Windows 98 taskbar . <p> Replace the base class of each existing MDI child frame ( CMDIChildWnd ) with SECToplevelFrame . This ensures that the MDI child windows retain all of their previous capabilities and can float freely on the desktop instead of being confined to the MDI frame window . <p> Remove the CMainFrame class and all references to it from your application . Because MTI has no equivalent to an MDI frame window , your CMainFrame class has no role in a MTI implementation . If you have a significant amount of code in your CMainFrame class , you need to consider moving the code to a new location . <p> The next step is to modify the OnInitInstance() method of your CWinApp-derived class . The OnInitInstance() method typically includes code to instantiate a document template and the MDI frame window . You must @ @ @ @ @ @ @ @ @ @ references to it from the application . <p> In most cases , it is not necessary to modify the code in OnInitInstance() method which instantiates the document template . The CMultiDocTemplate is still used by MTI because it does not include anything that is MDI-specific . It manages multiple documents ( document/view documents , not MDI documents ) and , in that capacity , remains useful for MTI without modification . <p> Override the OnCreate() method of your SECToplevelFrame-derived class or classes and create your control bars ( toolbars , status bars , and more ) . CFrameWnd : : OnCreate() is the method that usually creates these objects and SECToplevelFrame-derived classes are no exception . <p> By default , MTI-based applications behave the same way as MDI apps . For example , when you open a MTI application one top-level frame window containing an empty , untitled document appears . If you select Open from the File menu and select a file , a new top-level window is created , and the document is displayed therein . When you open a file , you are actually opening two windows @ @ @ @ @ @ @ @ @ @ the document of interest . This is exactly the same behavior MDI applications exhibit . In some applications , it is preferable to load the document into the initial empty frame rather than create a new one . <p> Derive a class from CMultiDocTemplate and override its OpenDocumentFile() method . <p> You may also want to change the standard call to the OnFileNew() method in CYourApp : : InitInstance() to OnFileOpen() so your application will display an open file instead of an empty document in the first top-level frame when you start it . <p> There are a couple of key MTI data members that you need to consider if you 're setting up message dispatching for your MTI application : <p> SECToplevelFrame : : stlfList . A static list of open top-level frame windows . You may need to dispatch a message or member function call to every top-level frame window on the desktop . Only those owned by the MTI application in question are accessible . Iterate over the top-level frames in this list and dispatch messages to them individually . <p> If you are using MTI in @ @ @ @ @ @ @ @ @ @ . <p> theApp.mpMainWnd . In SDI and MDI applications , only one main frame window is allowed by definition . Consequently , mpMainWnd is initialized at startup and remains constant until the application exits . With MTI , the mpMainWnd is constantly changing to reflect the top-level frame that currently has focus . If you need to dispatch a message or member function call to the active top-level frame , reference this variable . <p> The SECToplevelFrame class can act as more than a MDI alternative in your application . Because SECToplevelFrame is only varies slightly from CFrameWnd , you can use it anywhere you would have used CFrameWnd as a base class . SECToplevelFrame contains nothing that binds it to the document/view architecture , so you can use it in applications that do not adhere to doc/view architecture . When you use this class as a specialized frame window instead of an MDI alternative , SECToplevelFrame gives you the capability to create a top-level frame with any arbitrary client . The top-level frame is given its own entry in the Windows 98 task bar , and it can remain @ @ @ @ @ @ @ @ @ @ is like MDI except in FDI the MDI children can float freely on the desktop . In MDI , the MDI children are confined to the MDI parent window . As with MDI , you can have multiple open documents in FDI . FDI creates a new floating child window for each new document . Each FDI child window appears as a top-level window and manipulates one document . Optionally , each FDI child window can include a menu bar containing menu items specific to that window . <p> As for the main window , all menu items need to apply at the application level or to all FDI children ; otherwise , focus becomes an issue . For example , if you activate an FDI child and then pick a menu item from the main application window , the FDI child loses activation and consequently its menu pick . FDI-based applications have a look-and-feel that is similar to Microsoft Visual Basic . <p> Because FDI allows you to place document windows on the desktop , its interface is somewhat similar to MTI . In MTI , no main window @ @ @ @ @ @ @ @ @ @ , the concept of a main frame window remains to serve as a menu strip or primary application window . Because MTI document windows are root-level windows , they are given their own Windows 98 task bar entries . FDI document windows are not root-level windows . You can iconify MTI document windows independently of all other windows . In FDI , when the main application window is iconified , all the FDI children are iconified as well . <p> The SECFDIChildWnd class is a document window that is similar to a MDI child window , except it can float freely on the desktop whereas a MDI child window is tied to its parent frame . FDI applications derive from SECFDIChildWnd . MDI applications derive from CMDIChildWnd . <p> The SECFDIFrameWnd class is a main frame window that adds support for the Window menu and the Windows dialog . FDI applications derive from SECFDIFrameWnd . MDI application would derive from CMDIFrameWnd . <p> Replace CMDIChildWnd , the base class of all existing MDI child frames , with SECFDIChildWnd so that the MDI child windows retain all of their previous capabilities @ @ @ @ @ @ @ @ @ @ to the MDI frame window . <p> Replace CMDIFrameWnd , the base class of your main frame class , with SECFDIFrameWnd . <p> If you want your main frame window to serve as a menu strip , override SECFDIFrameWnd : : PreCreateWindow() and then specify the initial window size and position . <p> Override the OnCreate() method of your SECFDIChildWnd-derived class or classes and create your control bars ( toolbars , status bars , and more ) . <p> The WDI classes enhance MDI by allowing the user to place every document in a tabbed window . This reduces MDI modality . All of the documents are part of a workbook of worksheets . The user can open a specific worksheet by clicking a tab instead of selecting the Window menu and searching for it . <p> Because WDI adds an optional Workbook View to MDI , there is no cost associated with converting your MDI application to WDI . WDI enhances your MDI application without losing any functionality or fundamentally changing the MDI user interface . In other words , a WDI application with workbook viewing mode deactivated is @ @ @ @ @ @ @ @ @ @ drawing has been added to the 3D tab control window . In order to enable flat style drawing , you need to set the TWSFLATSTYLE window style while creating the tab control window . Alternatively , you can enable flat style drawing at a later time by calling the SetTabStyle function ( a member of the SEC3DTabWnd class ) . <p> To view sample code which shows how to enable flat style drawing for tabbed control windows during creation time , please see the ProjectWorkspaceWnd : : OnCreate function implementation in PRJBAR.cpp fo the Viz sample : <p> The SECWorkbookWnd class is derived from SECMDIFrameWnd . It adds the workbook interface ( WDI ) enhancements . Derive your main frame window class from SECWorkbookWnd if you want the workbook interface enhancements . <p> The SECWorksheetWnd class is derived from SECMDIChildWnd . It adds the workbook interface ( WDI ) enhancements . Derive your MDI child windows from SECWorksheetWnd if you want to implement the workbook interface enhancements . <p> The SECWorkbookClientWnd subclasses the MDI client window and is implemented as a part of the workbook interface . SECWorkbookClientWnd allows the @ @ @ @ @ @ @ @ @ @ and specify a client area that allots space for drawing the border and tabs . <p> Override the AddSheet() and RemoveSheet() member functions . These members are expected to assign values to SECWorksheetWnd : : mnPosition for every worksheet in your workbook . In your override , you can assign any tab position to newly created worksheets . <p> A summary of the key methods and data members that you can use to customize the WDI is presented in the table below . <h> Table 29 : Key Methods and Data Members for WDI <p> Member <p> Description <p> SECWorksheetWnd : : mnPosition <p> A data member that specifies the position of the tab associated with this worksheet within the row of tabs in the workbook . By default , the application display the tabs by order of creation . You can change the order by assigning a value to this member . <p> SECWorkbookWnd : : AddSheet() <p> A virtual method that is called whenever a new MDI child window is created . This member creates a new tab associated with the new MDI child and assigns it a @ @ @ @ @ @ @ @ @ @ order in which tabs are displayed , override the AddSheet() member and set the SECWorksheetWnd : : mnPosition member . <p> SECWorkbookWnd : : RemoveSheet() <p> A virtual method called whenever an MDI child window is destroyed . Override this member if you require additional work to occur whenever a sheet is removed from the workbook . <p> SECWorkbookWnd : : GetTabLabel() <p> A virtual method that returns the label to be drawn on the tab . By default , this label is the title of the MDI child 's active document . If this label is not appropriate for your application , override this member and return the label you need . <p> SECWorkbookWnd : : GetTabIcon() <p> A virtual method that returns the icon to be drawn on the tab . If NULL is returned , no icon is drawn . By default , this icon is the one associated with the MDI child frame via the resource file . If you prefer a different icon , override this member and return a different icon . <p> SECWorkbookWnd : : OnDrawTab() <p> A virtual method that draws a @ @ @ @ @ @ @ @ @ @ specified by SECWorksheetWnd : : mnPosition . By default , the tab has a 3D look . If you want to change the look of the tab , override this member and draw the tab with the look you prefer . <p> SECWorkbookWnd : : OnDrawTabIconAndLabel() <p> A virtual method that renders the icon and tab label on top of the blank tab drawn by SECWorkbookWnd : : OnDrawTab() . Override this member if you require the tab 's inscription to be rendered differently . 50236 @qwx670236 
@@75677759 @4377759/ <h> 2.8 Threading Package <p> Runnable objects in the Threading package are implemented by using the handle-body idiom . Figure 13 illustrates the runnable and thread pool class hierarchy in this package . For complete information about the Threading package , see Chapter 3 of the Threads.h++ User 's Guide . <p> Figure 15 shows the IOU class hierarchy , in which the majority of the classes belong to the Interthread Communication package . The hierarchy is duplicated here because the piece that makes IOUs usable is RWTThreadEscrowImp , from the Threading package . This class has the mechanisms for synchronizing multithread access to the result and blocking threads that have attempted to redeem the result before it has been supplied . 
@@75677761 @4377761/ <h> Declaration and Initialization of Auto Pointers <p> You attach an autoptr object to a pointer either by using one of the constructors for autoptr , by assigning one autoptr object to another , or by using the reset member function . Only one autoptr " owns " a particular pointer at any one time , except for the NULL pointer ( which all autoptrs own by default ) . Any use of autoptr 's copy constructor or assignment operator transfers ownership from one autoptr object to another . For instance , suppose we create autoptra like this : <p> autoptr&lt;string&gt; a ( new string ) ; <p> The autoptr object a now " owns " the newly created pointer . When a is destroyed ( such as when it goes out of scope ) the pointer will be deleted . But , if we assign a to b , using the assignment operator : <p> autoptr&lt;string&gt; b = a ; <p> b now owns the pointer . Use of the assignment operator causes a to release ownership of the pointer . Now if a goes out of scope @ @ @ @ @ @ @ @ @ @ pointer will be deleted when b goes out of scope . <p> The use of new within the constructor for a may seem a little odd . Normally we avoid constructs like this since it puts the responsibility for deletion on a different entity than the one responsible for allocation . But in this case , the autoptr 's sole responsibility is to manage the deletion . This syntax is actually preferable since it prevents us from accidentally deleting the pointer ourselves . <p> Use operator* , operator-&gt; , or the member function get() to access the pointer held by an autoptr . For instance , we can use any of the three following statements to assign " What 's up Doc " to the string now pointed to by the autoptrb . <p> autoptr also provides a release member function that releases ownership of a pointer . Any autoptr that does not own a specific pointer is assumed to point to the NULL pointer , so calling release on an autoptr will set it to the NULL pointer . In the example above , when a is assigned to @ @ @ @ @ @ @ @ @ @ a is set to the NULL pointer . 
@@75677762 @4377762/ <h> 3.7 Adding the Servlet to the web.xml file <p> Each servlet must appear in a web.xml file within a context directory . To add a servlet to an existing context , add a servlet and servlet-mapping element to the context . The sample below shows a complete web.xml file for the HelloWorldExample servlet : <p> The deployment descriptor above creates an instance of the HelloWorldExample servlet and names that instance HelloWorld . Because the servlet is located in the examples context , the url-pattern element maps the servlet to **28;8325;TOOLONG . That is , the container forwards all requests that begin with **28;8355;TOOLONG to the HelloWorld instance . This servlet configuration is identical to the configuration for HelloWorldExample in the web.xml file for the examples context . <p> Chapter 4 explains the context web.xml file and describes how to deploy and configure servlets , filters , and listeners . 
@@75677767 @4377767/ <p> ANOVA stands for analysis of variance . For the Analytics.h++ class RWLinearRegressionANOVA , the analyzed variance is the variance of residual errors in a linear regression model , also known as the regression 's goodness of fit . <p> Once an instance of RWLinearRegressionANOVA is constructed with a linear regression model , it can be queried for values related to goodness of fit , including the residual sum of squares , the coefficient of determination , and the F statistic . 
@@75677768 @4377768/ <p> RWDBStatus encapsulates the error state of an object or operation . A valid object or a successful operation is represented by RWDBStatus : : ok . An RWDBStatus that is not valid contains an error code , an error message , and often some supplemental information provided by a database vendor 's API . <p> Each RWDBStatus object contains a callback routine that can be changed by an application . If an RWDBStatus changes state to anything but RWDBStatus : : ok , the installed handler is called with self as an argument . <p> In the DBTools.h++ error model , the use of exceptions is optional , and is under the application 's control . The raise() method of RWDBStatus throws an exception of type RWExternalErr . Thus , an application may choose to enforce a terminating or nonterminating model of error handling by installing an appropriate error handler . <p> When DBTools.h++ objects are produced by other objects , the produced object 's status is copied from the producer . Consequently , an application can control error handling at any level it chooses . A handler @ @ @ @ @ @ @ @ @ @ in the application ; one installed in an RWDBDatabase is propagated to each object produced by that RWDBDatabase , and so on down to the level of individual objects . <p> RWDBStatus is designed around the Interface/Implementation paradigm . An RWDBStatus instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . <p> Returns self 's error code . The code errorCode() ! = ok can be interpreted as an abnormal condition . <p> ErrorHandler errorHandler() const ; <p> Returns self 's installed error handler , if any . <p> RWBoolean isTerminal() const ; <p> Returns TRUE if the error that occurred will terminate the application . <p> RWBoolean isValid() const ; <p> Returns TRUE if errorCode() == ok , otherwise returns FALSE . <p> RWCString message() const ; <p> Returns the error message associated with the current error code . Returns an empty string if the current error code is ok . <p> void raise() const ; <p> If exceptions are not supported according to the Tools.h++ macro RWNOEXCEPTIONS , aborts via a call to exit(ok) . Otherwise @ @ @ @ @ @ @ @ @ @ RWTHROW() , passing the error message associated with self . <p> void **26;8385;TOOLONG : : ErrorHandler handler ) ; <p> Installs handler as self 's error handler . The supplied handler is inherited by all objects produced by self . By default , an RWDBStatus error handler is inherited from the object that produced it ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : <p> The following methods return database-specific error information . If a status object has an error code of serverError , serverMessage , or vendorLib , these methods may provide additional information , as documented in the DBTools.h++ access library guides . Otherwise , these methods return 0 or the empty string , as appropriate . <p> long vendorError1() const ; <p> Returns a code supplied by the database vendor , or 0 if not relevant . <p> long vendorError2() const ; <p> Returns a code supplied by the database vendor , or 0 if not relevant . <p> RWCString vendorMessage1() const ; <p> Returns a string supplied by the database vendor , or an empty string @ @ @ @ @ @ @ @ @ @ Returns a string supplied by the database vendor , or an empty string if not relevant . 
@@75677770 @4377770/ <h> 7.1 The Problem of Diverse Data Types <p> Now that we have seen how to use SourcePro DB , let 's see what makes it work . A unique feature of SourcePro DB is how it deals with diverse data types . One of the traditional obstacles to writing portable database applications is the diverse representation of data by database manufacturers . Certainly each vendor provides something that behaves like an integer , something that behaves like a floating point number , and so on . But significant differences exist , based on these issues : <p> How are structured data types like string , date , time , or money represented ? Typically , a database vendor provides a representation for each data type that can be stored in its database , and a collection of routines to manipulate that representation . Different vendors supply different representations . <p> How are NULL values represented ? Relational databases support the notion of missing or unknown values called NULLs , but this concept is not directly supported in languages like C or C++ . Database APIs can represent the @ @ @ @ @ @ @ @ @ @ a null indicator variable , or they can indicate a null value with a NULLpointer . Different techniques lead to different implementations at the application level . <p> How is data delivered to an application program ? In general , either the application supplies a pointer to an area of memory to be populated by the database API , or the database API provides a pointer to volatile memory from which the application can copy data . The technique chosen tends to permeate the application design . <p> How does an application program put data into the database ? It may be necessary to supply a pointer to program memory , or to copy data into a buffer supplied by the database API . Perhaps data is automatically converted to the native database types , perhaps not . <p> In each of these cases , the mechanism chosen to represent or to deliver data has a substantial effect on the nature of your application . Your design problems are compounded if you use multiple databases . 
@@75677771 @4377771/ <h> 2.17 Contents of RWDBEnvironmentHandle <p> The DB Access Module for Microsoft SQL Server returns an environment handle that has the type **29;8413;TOOLONG . This handle provides methods that an application can use to set or retrieve certain connect time and configuration parameters . <p> Please note that some connect time parameters are set only when a connection is established with the SQL server . When the method returns a valid RWDBStatus for these parameters , it does not necessarily mean that the connection parameter has been accepted by the server . Appropriate error messages will be fielded to the application only when a connection is established . <p> The timeout() method defines the length of time in seconds that Microsoft SQL Server waits for an SQL statement to execute before returning to the application . Two methods are available : <p> SQLUINTEGER timeout() const ; RWDBStatus timeout ( SQLUINTEGER value ) ; <p> In the Microsoft SQL Server library manual , the default is an infinite timeout period . The application can set this value at any time . It takes effect for all open connections immediately upon @ @ @ @ @ @ @ @ @ @ driver manager writes each ODBC function call to the trace file ; Section 2.17.5 explains how to specify a trace file name . <p> If tracing is enabled with the Trace keyword in the ODBC section of the ODBC.INI file ( or registry ) it will take precedence and the above methods will have no effect . If you need complete control of tracing capabilities through class **29;8444;TOOLONG , you must disable tracing in the ODBC.INI file ( or registry ) <p> The trace file name is an RWCString containing the name of the trace file . If tracing is not enabled , this file name is ignored . If tracing is enabled , the driver writes to this file each time a driver call is made . If no trace file is specified and tracing is enabled , the driver manager writes to SQL.LOG . <p> The maxBlobSize() method sets the maximum length in bytes for blobs that can be read . If the size of the blob data column being fetched is greater than the maxBlobSize() setting then an attempt is made to fetch the data in parts @ @ @ @ @ @ @ @ @ @ is truncated to the length maxBlobSize() . The default is 128000 . Two methods are defined : <p> The maxStringSize() method sets the maximum size in code units for strings that can be read.If the size of the string data column being fetched is greater than the maxStringSize() then an attempt is made to fetch the data in parts . If this is not possible , then the data is truncated to the length maxStringSize() . The default is 128000 . Two methods are defined : <p> In Microsoft SQL Server , national language is set for a particular connection using the SQLDriverConnect() connection string keyword LANGUAGE . For this setting to take effect , it must be called before an RWDBConnection is obtained . Please see the Microsoft SQL Server documentation for the semantics of setting the national language . <p> **29;8475;TOOLONG includes the secureLogin method , which allows Windows users to use SQL Server 's secure login feature . Enabling secureLogin tells SQL Server to use the user 's Windows login to establish a connection . The user and password fields supplied to RWDBManager : : database() will @ @ @ @ @ @ @ @ @ @ following example shows how to gain access to class **29;8506;TOOLONG . Note that the application must be compiled with an include path to the Microsoft SQL Server library include files . 
@@75677772 @4377772/ <h> 9.3 Architecture of the Notification Classes <p> The implementation of a notification operation requires the client to take on additional functionality that is more typically server-like , while the server must take on additional functionality that is more typically client-like . The client must now have the ability to listen for an incoming message ; the server , on the other hand , must be able to initiate a message . <p> In this way , notification blurs the traditional distinction between a client and a server . Clients become servers ; servers become clients . <p> The following two diagrams illustrate the architecture of the generated client and server-side notification code . <p> At the top of the figure are the general client-side classes that are always generated for any message pattern . Below are the notification-specific classes . Note that the notification classes look like server-side classes , yet they are for use on the client . These classes give the client the required functionality to set up a listener to receive notification . <p> Additionally , two specialized configuration files are generated : <p> client-handlers.xml @ @ @ @ @ @ @ @ @ @ client . These are the message handlers for incoming notification messages . ( For clients without services , this file is still generated but contains only a logger . ) <p> client-objects.xml , the configuration file for named objects used on the server side . This file is required for notification in order to set up a listener on the client side . For information on how to configure a named objects file , see Section 8.3.11.4 . For more information on named objects in general , see Chapter 16 , " Named Objects . " <p> At the top of the figure are the classes normally generated on the server side . Below is a special NotificationProxy class that is used to send a message to the client . No special configuration files are required on the server side . 
@@75677773 @4377773/ <h> 4.3 Solving Several Systems of Equations <p> In this section , a slightly more complicated example program is given . This program reads a matrix A from the input stream , continues to read in right-side vectors , b , and solves the system of equations Ax=b until an end of file is reached . To make it more complex , we assume that the matrix A is positive definite symmetric . Such a matrix can be constructed for test purposes , if you 'd like to try this program , by choosing a nonsingular matrix X and forming A=XTX . <p> The header files for the input/output stream classes and the positive-definite factorization class are included . <p> //2 <p> The double precision symmetric matrix A is defined and then read in from standard input . <p> //3 <p> Here a positive-definite factorization of the matrix A is constructed and given the name fact . For this to work , the matrix A must be , in fact , positive-definite . If not , the results ( fact ) are invalid . <p> //4 <p> Here we @ @ @ @ @ @ @ @ @ @ , then ... <p> //5 <p> We define a vector b ... <p> //6 <p> We keep reading vectors from standard input until an end-of-file is encountered , and then ... <p> //7 <p> We use the factorization to solve each set of equations Ax=b . <p> This program can be written without constructing the factorization explicitly by replacing //7 with : <p> RWMathVec&lt;double&gt; x = solve ( A , b ) ; <p> This is not advisable because the factorization must be computed every time through the loop even though it is not changing . Because constructing the factorization is typically the most expensive part of solving a set of equations , the result is a much slower program . 
@@75677774 @4377774/ <h> SOA Governance - Harness the Power of Technology <p> In order for SOA initiatives to succeed they need to follow sound Enterprise Architecture practices . Companies realizing the most success are those that have built an Integrated SOA Governance infrastructure that governs a wide range of assets and artifacts through their entire lifecycle . <p> Integrated SOA Governance helps enterprises : <p> Ensure that services they identify , design and build are relevant and consumable across all distributed and mainframe platforms like Microsoft , SAP and IBM . <p> Make services they expose from applications running on any platform visible to and compliant with enterprise policies defined , enforced and audited across other platforms <p> Promote , ensure and formalize consistent alignment between demand from service consumers and the supply of services through Consumer Contract Provisioning . <p> In a nutshell SOA Governance is about making sure that the enterprise builds the right things , builds them right , and makes sure that what it has built is behaving right . This breaks down into distinct areas ; Planning Governance is about making sure that you are building @ @ @ @ @ @ @ @ @ @ you 're building them right , and Operational Governance is about ensuring that what you 've built is behaving right . <p> Integrated SOA governance ensures the applicability , integrity and usability of a wide range of assets through all their lifecycle stages from asset identification through deprecation . The full lifecycle is split into planning governance , development governance , and operational governance , with a cross-cutting policy governance theme . <p> Planning Governance - Planning Governance includes the identification analysis and modeling of candidate services , policies , profiles , processes and information . An effective planning governance tool with manage an organizations SOA portfolio to examine existing and planned applications and determine which capabilities should be exposed as services , and where applications would benefit from consuming shared services . <p> Development Governance - Development Governance marshals an asset through the typical design through deprecation phases of its lifecycle . It typically includes a workflow mechanism to approve migration , policy compliance validation , and a clear separation ( logically , physically , or both ) between lifecycle stages . Development Governance is the realm that most registry vendors @ @ @ @ @ @ @ @ @ @ provide a comprehensive registry/repository solution for SOA asset lifecycle management . Using this solution architects , developers , security administrators , and operations managers can define and govern policies that are applied to services throughout the appropriate stages of their lifecycle . These policies are automatically implemented and enforced by Akanas industry-leading Service Manager , and other standards-based SOA runtime products . Service Manager generates usage , performance and policy compliance metrics that it delivers back to Policy Manager so that it can audit that its policies are being enforced in a closed-loop process . <p> The alternative to a closed-loop solution is a set of stand-alone applications for governance , management and security . These solutions may offer loose integration , but we have yet to identify a single organization that has successfully integrated stand-alone solutions in a production environment . <p> On one hand , stand-alone run-time solutions do n't deliver higher value design-time , or governance capabilities . They require central policy management , do n't  offer developer or architect services , and have no understanding of the relationship between a provider and a consumer . <p> @ @ @ @ @ @ @ @ @ @ can only deliver value when they are built on a runtime foundation . They require a run-time solution to enforce policies ; they need the run-time to provide statistics and metrics for demand , capacity , and value monitoring ; and they also need the run-time to provide an audit trail to ensure that messages comply with defined policies . <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75677775 @4377775/ <h> 4.2 Transforms of Real Sequences <p> It is worth discussing the difference between DComplexFFTServer and DoubleFFTServer . Say you want to transform a real sequence of N points V(j) , j=0 , ... , N -- 1 . Note that the transform of a real sequence is a complex conjugate-even sequence , that is , a sequence where C(j) = conj ( C ( -- j ) ) = conj ( C ( N -- j ) ) . How can you calculate the transform ? In general , you have two choices : <p> Convert the real sequence to a complex sequence with imaginary parts set to 0 and transform that ; <p> Take advantage of the fact that the imaginary parts of the sequence are 0 and transform the N-point real sequence as an N/2-point complex sequence . <p> The DoubleFFTServer uses the second approach . Because the result is a complex conjugate-even sequence , the DoubleFFTServer returns only the lower half of the sequence , which saves considerable time . Here is an example illustrating the two approaches : <p> A close inspection shows that @ @ @ @ @ @ @ @ @ @ even . The second approach , using the DoubleFFTServer , returns only the lower half of that sequence . The global function expandConjugateEven() can be used to expand it into the full N-point conjugate-even sequence . See Part III , " Global Function Reference , " in the Essential Math Module Reference Guide for more information . 
@@75677776 @4377776/ <h> 2.16 Contents of RWDBSystemHandle <p> The RWDBConnection : : systemHandle() method returns a pointer to a base class from which a family of implementation-specific classes are derived . To use the database API directly , an application downcasts this pointer to the appropriate type , and uses its implementation-specific features . Naturally , this usage reduces an application 's portability . <p> For the DB Access Module for Oracle OCI , the implementation-specific system handle has the data type RWDBOCISystemHandle . It contains the OCI handles associated with the RWDBConnection . The following methods may be used to retrieve these components : <p> When fetching or sending large character or binary data ( LONG , LONG RAW , CLOB , BLOB or SYS.XMLTYPE ) , data is sent or received in chunks of piecewiseSize() bytes at a time . Size can be reset and retrieved through piecewise size accessor and mutator . The mutator returns previously used piecewise size . The size is specified in bytes . The default piecewise size is 32768 bytes ( 32kb ) . <p> Prefetch rows size is used by the DB Access @ @ @ @ @ @ @ @ @ @ for every query execution . This attribute controls the number of rows an Oracle client prefetches from an Oracle server for the result set produced by the query exeution . It affects the number of server round trips and hence , performance . The default prefetch rows size used by DB Access Module for Oracle OCI is 10 . <p> The following accessor and mutator are available from RWDBOCISystemHandle : <p> ub4 prefetchSize() const ; <p> Returns the current prefetch rows size used by the DB Access Module for Oracle OCI . <p> ub4 prefetchSize ( ub4 newSize ) ; <p> Resets the prefetch rows size used by the DB Access Module for Oracle OCI to newSize . Returns the previously used prefetch rows size . <p> Please refer to Oracle Call Interface documentation for more information on OCIATTRPREFETCHROWS attribute . 
@@75677777 @4377777/ <h> Viewing a diff of your file in Visual Studio <p> When submitting a code review , you can look at a diff of the file(s) to see what changes have been made since your last commit . To see the diff , you must first configure the Klocwork plug-in to use your preferred diff tool . <p> Prerequisites : <p> The Klocwork Server must be running <p> Your SCM must be integrated and you must have a cloned SCM repository on local storage <p> An external diff tool must be installed on your local machine <p> To configure your diff tool with Visual Studio : <p> Go to Klocwork &gt; Options &gt; Klocwork &gt; General . <p> Click the Diff Viewer tab . <p> In the Command field , browse to the path of your diff tool . For example , C : Program Files ( x86 ) WinMergeWinMergeU.exe . <p> OPTIONAL : If your diff tool requires additional macros for the original file and modified file , add them to the Arguments field . If no arguments are provided , it uses " $ ( BasePath ) @ @ @ @ @ @ @ @ @ @ . <p> Note : The file path may contain spaces , so it 's good practice to include quotes around the macros when defining the arguments . <p> Viewing the diff from Visual Studio <p> To view the diff for your code review , right-click the file and open the Create Code Review dialog . In the Changes field , click on a node and select Diff . <p> Tip : You can also right-click and select Diff file or double-click on a node to view the diff . <p> The diff tool you configured with Visual Studio will open showing you the original file and the modified file . <p> Note : If the node you are trying to view has any associated children nodes , all of them will be diffed. 
@@75677778 @4377778/ <h> 2.2 Types of Streams <p> At its lowest level , the streams architecture handles streams of various character types , such as ASCII , 8-bit binary , wide character , and Unicode . The next level handles the streaming of data . Data in this case means C++ primitive types such as int . The highest level handles object serialization . <p> Object serialization differs from other types of data streaming in that it must preserve not only the data , but relationships between parts of the data . These relationships include : <p> Polymorphic typing , guaranteeing that when an object of a particular type is streamed , it is correctly set to the same type when restored <p> Object identity , guaranteeing that references between objects are properly maintained <p> The streams architecture supplies macros for building serialization capability into your classes , and for serializing objects over which you have no control , such as third-party components . <p> For a detailed description of the Rogue Wave streams architecture , see the Advanced Tools Module User 's Guide . For concrete examples of how to @ @ @ @ @ @ @ @ @ @ this manual . 
@@75677780 @4377780/ <p> Class RWFileManager allocates and deallocates storage in a disk file , much like a " freestore " manager . It does this by maintaining a linked list of free space within the file . Note : Class RWFileManager inherits class RWFile as a public base class ; hence all the public member functions of RWFile are visible to RWFileManager . They are not listed here . <p> If a file is managed by an RWFileManager then reading or writing to unallocated space in the file will have undefined results . In particular , overwriting the end of allocated space is a common problem which usually results in corrupted data . One way to encounter this problem is to use binaryStoreSize() to discover the amount of space needed to store an RWCollection . For most purposes , the storage size of an RWCollection is found using the RWCollectable method recursiveStoreSize() . <p> Constructs an RWFileManager for the file with path name filename using mode mode . The mode is as given by the Standard C library function fopen() . If mode is zero ( the default ) then the @ @ @ @ @ @ @ @ @ @ given filename for update ( mode " rb+ " ) . If this is not possible , then it will attempt to create a new file with the given filename ( mode " wb+ " ) . If the file exists and is not empty , then the constructor assumes it contains an existing file manager ; other contents will cause an exception of type RWExternalErr to be thrown . If no file exists or if an existing file is empty , then the constructor will attempt to create the file ( if necessary ) and initialize it with a new file manager . The resultant object should be checked for validity using function isValid() . A possible exception that could occur is RWFileErr . <p> Allocates s bytes of storage in the file . Returns the offset to the start of the storage location . The very first allocation for the file is considered " special " and can be returned at any later time by the function start() . A possible exception that could occur is RWFileErr . <p> void deallocate ( RWoffset t ) ; <p> Deallocates @ @ @ @ @ @ @ @ @ @ . This space must have been previously allocated by a call to allocate() . The very first allocation ever made in the file is considered " special " and can not be deallocated . A possible exception that could occur is RWFileErr . <p> RWoffset endData() ; <p> Returns an offset just past the end of the file . <p> RWoffset start() ; <p> Returns the offset of the first space ever allocated for data in this file . If no space has ever been allocated , returns RWNIL . This is typically used to " get started " and find the rest of the data in the file . 
@@75677783 @4377783/ <p> This chapter describes the interfaces and classes that make up the API of the JavaTM data-source mapping feature of Rogue Wave- Server . This API enables you to represent objects and relations from the server model as Swing or Rogue Wave JViews gadgets . See Overview of Java Data Sourcesfor a presentation of Java data sources and of the mapping mechanism . <p> This chapter is divided as follows : <p> Overview consists in a table that lists the contents of the various packages . <p> Base Classes and Interfaces describes the contents of the ilog.server.jsds package , which is the top package of the Server/Java mapping API. 
@@75677784 @4377784/ <h> 14.2 List of Tutorials <p> Table 13 contains a list of the advanced tutorials , their related files , and a description of their content . Filenames containing the word out give the output of the tutorial program ; filenames containing the word err contain error messages . All the DBTools.h++ files are located in the Rogue Wave directory LONG ... <p> If you are reading this manual online , you can click on the name of the tutorial to take you to its documentation . 
@@75677785 @4377785/ <h> 2.15 Contents of RWDBSystemHandle <p> The RWDBConnection : : systemHandle() method returns a pointer to a base class from which a family of implementation-specific classes is derived . To use the database API directly , an application can downcast this pointer to the appropriate type , and use its implementation-specific features . Naturally , this usage reduces an application 's portability . <p> For a PostgreSQL connection , the implementation-specific system handle has the data type RWDBPGSSystemHandle . It contains the PGconn* used by the RWDBConnection . The following method may be used to retrieve this component : 
@@75677787 @4377787/ <p> The California Department of Water Resources ( DWR ) operates the largest state-built multipurpose project in the United States . The agency is moving from application silos to the SOA paradigm where IT functionality can be shared within the entire enterprise . DWR chose to combine best-of-breed products into a comprehensive SOA Platform : JBoss Enterprise SOA Platform ; Akana Policy Manager for registry/repository , policy management , consumer contract provision , and lifecycle management ; and Akana Network Director for service virtualization. 
@@75677791 @4377791/ <h> 6.1 The Problem of Diverse Datatypes <p> Now that we have seen how to use DBTools.h++ , let 's discuss in more detail what makes it work . A unique feature of DBTools.h++ is how it deals with diverse datatypes . One of the traditional obstacles to writing portable database applications is the diverse representation of data by database manufacturers . Certainly each vendor provides something that behaves like an integer , something that behaves like a floating point number , and so on . But significant differences exist , based on the following issues : <p> How are structured datatypes like string , date , time , or money represented ? Typically , a database vendor provides a representation for each datatype that can be stored in its database , along with a collection of routines for manipulating that representation . Different vendors supply different representations . <p> How areNULLvalues represented ? Relational databases support the notion of missing or unknown values called NULLS , but this concept is not directly supported in languages like C or C++ . Database APIs can represent the nullness of a @ @ @ @ @ @ @ @ @ @ variable , or they can indicate a null value with a NULLpointer . Different techniques lead to different implementations at the application level . <p> How is data delivered to an application program ? In general , either the application supplies a pointer to an area of memory to be populated by the database API , or the API provides a pointer to volatile memory from which the application can copy data . The technique chosen tends to permeate the application design . <p> How does an application program put data into the database ? It may be necessary to supply a pointer to program memory , or to copy data into a buffer supplied by the API . Perhaps data is automatically converted to the native database types , perhaps not . <p> In each of these cases , the mechanism chosen to represent or to deliver data has a substantial effect on the nature of your application . Your design problems are compounded if you use multiple databases . 
@@75677792 @4377792/ <p> The CLI standard defines descriptors at implementation- and application- levels . <p> At implementation level " that is , from the database server point of view " the descriptors are called IRD ( Implementation Row Descriptor ) and IPD ( Implementation Parameter Descriptor ) . <p> At application level , the descriptors are called ARD ( Application Row Descriptor ) and APD ( Application Parameter Descriptor ) . <p> Likewise , Rogue Wave DB Link also differentiates between implementation level and application level , but refers to row descriptors as column descriptors and uses the same classes for column and parameter descriptors . <p> Implementation Within Rogue Wave DB Link <p> Rogue Wave DB Link uses two classes to describe the properties of a column or parameter : <p> IldDescriptor : Declared in the file ildent.h , this class is used to describe a column or parameter type on the server side . <p> IldAppDescriptor : A subclass of IldDescriptor declared in the file ildtuple.h , this class is used to hold the type descriptor and the column or parameter values and indicators on the application side . @ @ @ @ @ @ @ @ @ @ capability of describing the parameters of a query , the contents of the IldDescriptor object for a parameter are undefined until it is bound using the member function IldRequest : : bindParam . <p> Type Codes <p> SQL data type codes are defined as constants in the section Type Codes of the ildconst.h header file . Most of them have a name that is very similar to their CLI name but a few of them differ . The names are prefixed with IldSQL . <p> Their values are the ones defined in the CLI standard . <p> The CLI specification has been extended to negative values so as to provide support for all types of all supported RDBMSs . <p> The member function IldAppDescriptor : : isExtValue let 's you know whether the value buffer was allocated by Rogue Wave DB Link or is bound to some application memory space . This function returns IlFalse in the first case or IlTrue in the second . <p> The member function IldAppDescriptor : : isExtNulls let 's you know whether the null-indicator buffer was allocated by Rogue Wave DB Link or is bound to @ @ @ @ @ @ @ @ @ @ the first case or IlTrue in the second . <p> Simple IldDescriptor objects exist only for user-defined data-type attribute descriptors of type IldADTDescriptor . All other accesses to descriptors return instances of derived classes : 
@@75677793 @4377793/ <h> 1.1 Overview and Features of Tools.h++ <p> Tools.h++ is a rich , robust , and versatile C++ foundation class library : a set of software parts you can use to build virtually any application . <p> Tools.h++ is an industry standard . It is shipped by a wide variety of compiler vendors with every copy of their compilers . Preferred by thousands of users world wide , it is ported to numerous compilers and operating systems . Tools.h++ is available on almost any development platform you choose . <p> This new version of Tools.h++ is built on the Standard C++ Library . To aid your transition into this technology , Tools.h++ provides a familiar object-oriented interface , and a reliable upward migration path . You can count on Tools.h++ to track and incorporate revisions of the Standard C++ Library as they are approved . <p> Your new Tools.h++ package includes : <p> Powerful single , multibyte , and wide character support <p> You can manipulate single and multibyte strings with class RWCString 's full suite of operators and functions , or choose class RWWString for wide character strings @ @ @ @ @ @ @ @ @ @ comparison , indexing ( with optional bounds checking ) , I/O , case changes , stripping , and many other functions . In addition , classes RWCSubString and RWWSubString allow extraction and assignment to substrings ; classes RWCRegexp and RWCRExpr support regular expression pattern searches ; and classes RWCTokenizer and RWWTokenizer break single and wide character strings , respectively , into separate tokens . <p> Extended regular expressions <p> Here 's a richer set of pattern matching tools you can use to search for information in strings . The new Tools.h++ extended regular expression features are a subset of those found in the ANSI/ISO standard POSIX.2 ( Portable Operating System Interface ) , and require the presence of the Standard C++ Library . <p> Time and date handling classes <p> You can calculate the number of days between two dates , or the day of the week a date represents . Read and write days or times in arbitrary formats , or whatever you need to do . Tools.h++ helps you master time . <p> Internationalization support <p> You can internationalize your software with the convenient and easy-to-use framework of @ @ @ @ @ @ @ @ @ @ zones and daylight-saving time . The entire library is eight-bit clean , so you can use it with any eight-bit character set . Embedded nulls are fully supported . <p> Endian streams <p> You can transfer information between operating systems with the efficiency of a binary stream . The endian streams mechanism , which keeps a record of the operating environment where information originates , allows the stream to be read on any system regardless of its native size or byte order . <p> Multithread safe <p> You can count on multithread safety . When compiled with a multithread option , the library uses multithread safe system facilities , with enough internal locking to maintain its internal integrity . See the release notes for your compiler . <p> Persistent store <p> This new version of Tools.h++ enhances an already powerful and sophisticated store facility . Isomorphic persistence , which maintains an object 's pointer relationships , is now supported for most Tools.h++ collections , including the template-based collections . You can also implement isomorphic persistence on your own classes . Objects that inherit from RWCollectable have polymorphic persistence , which @ @ @ @ @ @ @ @ @ @ restore objects without knowing their types . <p> Template based classes <p> Twenty-eight new or re-engineered class templates based on the Standard C++ Library container classes . You can use the full interface to these classes if your development environment supports the Standard C++ Library . If you do n't have the Standard C++ Library , Tools.h++ supplies template-based classes with a subset of the same interfaces . <p> Generic collection classes <p> If your compiler does not yet support templates , Tools.h++ includes a set of template-like classes that use the C++ preprocessor and &lt;generic.h&gt; , a header file included with most compilers . The interface to these generic classes is similar to the template-based classes , so you can make an easy transition . <p> Smalltalk-like collection classes <p> You get a complete library of collection classes , modeled after the Smalltalk-80 programming environment , including Set , Bag , Queue , Stack , OrderedCollection , SortedCollection , Dictionary , and more . 
@@75677795 @4377795/ <p> A frame is usually composed of 36 subframes . This method returns 0 when all the features are read . 50234 @qwx670234 <p> status <p> The function sets an error code to this parameter . It can either be IlvMaps : : NoError() if the feature could be read properly , or an error status such as InitError if the reader had an initialization error and if this function is called , or FormatError , or an error of the IlvMapInput class . 
@@75677799 @4377799/ <h> 11.11 Migration Guide : For Users of Previous Versions of Tools.h++ <p> As we explained in the introduction to this manual , one of our primary goals for this version of Tools.h++ is to protect your investment in existing code based on previous versions of the library . As you can see from this chapter , we have significantly re-engineered the collection class templates in order to bring them up to date with the Standard C++ Library . The following classes were re-engineered : <p> You have seen that you can now use all of these classes either with or without the Standard C++ Library . Used without the Standard C++ Library , they have the same interfaces and implementations as in the previous version of Tools.h++ , updated with some bug fixes . These minor enhancements should not cause any source incompatibilities with existing code . <p> You may need to make a few changes to existing source code when using the above classeswith the Standard C++ Library . The adjustments required for specific classes are outlined below . <p> Existing code using these templates will not @ @ @ @ @ @ @ @ @ @ of Tools.h++ when used with the Standard C++ Library . The solution to this problem is to use the macros discussed in Section 11.10.1 . Using the macros described there will satisfy the compiler and preserve the semantics of your existing code . <p> If you have existing code that makes use of any of the inheritance relationships among the collection class templates , that code will not compile with this version of Tools.h++ when used with the Standard C++ Library . There are no inheritance relationships among the standard library-based implementations of the collection class templates . For example , in the previous version of Tools.h++ , RWTPtrHashSet inherited from RWTPtrHashTable , RWTValOrderedVector inherited from RWTValVector , and RWTValSortedVector inherited from RWTValOrderedVector . The pointer-based versions of these templates followed a similar pattern . These relationships do not hold in the new version of Tools.h++ . If you have code based on this inheritance , you will need to modify it . <p> The solution to this particular problem is found in the new class RWTPtrHashSetIterator . Wherever you find code which constructs an RWTValHashTableIterator from an RWTValHashSet , @ @ @ @ @ @ @ @ @ @ whether or not the Standard C++ Library is available , so you can modify your code now in anticipation of migrating your code to the standard library-based implementations . <p> As mentioned above , some compilers will require that the expression ( t1 &lt; t2 ) be defined for two instances of your element type . This is due to the inclusion of convenient member functions , such as sort() and minelement() , combined with certain compilers that instantiate all member functions whether used or not . You might have existing code that instantiates one of these templates on a type T for which no operator&lt; ( ) is defined . If that is the case , you will have to define one . <p> The best thing would be to define it in a way you can really use , if you ever use those member functions which really do require it . The quick and dirty approach would be to globally define a dummy operator&lt; ( ) whose only purpose is to appease the compiler . Our experience is that code written " just to appease the compiler @ @ @ @ @ @ @ @ @ @ at all possible . 
@@75677800 @4377800/ <h> 17.2 Overview of This Tutorial <p> The video store needs to print mailing labels for all its customers . To accomplish this , two classes are used : VVContact and VVContactRepository . <p> The first class , VVContact , encapsulates one database record . In other words , each instance of the class VVContact represents one customer . Why was n't the class named VVCustomer instead ? Because this class will be reused later for something other than customers . VVContact consists of seven components that represent the various fields important for storing customer information , such as name , I 'd number , address , and so on . In addition to the data , there are several member functions that carry out actions associated with customers . The important member function for this tutorial is called mailingLabel() . An instance of VVContact , when given an appropriate output stream , is able to print a mailing label for itself . <p> The second class , VVContactRepository , encapsulates the set of all customers in the database . Through an instance of this class , all customer records @ @ @ @ @ @ @ @ @ @ A VVContactRepository instance consists of references to the database and the table in which the customer data resides . This class also includes a number of member functions to assist in manipulating the set of all customer records . <p> Most of the functionality used in this example is encapsulated in these two classes . These classes hide the details of the DB Interface Module code in the same manner that the DB Interface Module code hides the details of the underlying database API. 
@@75677801 @4377801/ <h> 18.2 Overview of This Tutorial <p> Some of the customers of the video store are delinquent in returning their videos . The management of the video store wants to send gentle reminders to these irresponsible customers . It is possible to join the customer table with the rental table to produce mailing labels for only those customers who are more than a week overdue . <p> Like Tutorial One , this tutorial uses the VVContact and VVContactRepository classes . In addition , this tutorial uses a pair of classes representing rental transactions and the rentals table : VVRentalTransaction and **29;8537;TOOLONG . These two classes relate to each other like VVContact and VVContactRepository relate to each other . VVRentalTransaction represents one record from the rentals table , while **29;8568;TOOLONG encapsulates the set of all rental transactions in the form of a table in the database . <p> The overdue customer records are retrieved by setting up a criterion for their selection . This is done with RWDBColumn objects to produce a predicate using C++ syntax . In SQL syntax , the predicate would be the WHERE clause of a @ @ @ @ @ @ @ @ @ @ example is encapsulated in the four classes mentioned above . These classes hide the details of the DB Interface Module code the same way that the DB Interface Module code hides the details of the underlying database API. 
@@75677803 @4377803/ <p> Class RWGSortedVector(val) represents a vector of elements of val val , sorted using an insertion sort . The elements can be retrieved using an index or a search . Duplicates are allowed . Objects of val RWGSortedVector(val) are declared with macros defined in the standard C++ header file &lt;generic.h&gt; . <p> Note that it is a value-based collection : items are copied in and out of the collection . <p> For each val of RWGSortedVector you must include one ( and only one ) call to the macro implement somewhere in your code for both the RWGSortedVector itself and for its base class RWGVector . <p> Insertions and retrievals are done using a binary search . Note that the constructor of an RWGSortedVector(val) requires a pointer to a " comparison function . " This function should have protoval : <p> int comparisonFunction ( const val* a , const val* b ) ; <p> and should return an int less than , greater than , or equal to zero , depending on whether the item pointed to by a is less than , greater than , or equal to @ @ @ @ @ @ @ @ @ @ collection will appear as a , the key as b . <p> Construct a sorted vector of elements of val val , using the comparison function pointed to by f . The initial capacity of the vector will be set by the value RWDEFAULTCAPACITY . The capacity will automatically be increased should too many items be inserted . <p> RWGSortedVector(val) ( int ( *f ) ( const val* , const val* ) , sizet N ) ; <p> Construct a sorted vector of elements of val val , using the comparison function pointed to by f . The initial capacity of the vector will be N. The capacity will automatically be increased should too many items be inserted . <p> Return the ith value in the vector . The index i must be between 0 and the length of the vector less one . No bounds checking is performed . <p> valoperator ( sizet i ) const ; <p> Return the ith value in the vector . The index i must be between 0 and the length of the vector less one . Bounds checking is performed . <p> sizet @ @ @ @ @ @ @ @ @ @ in the collection . <p> sizet index ( val v ) ; <p> Return the index of the item with value v. The value " RWNPOS " is returned if the value does not occur in the vector . A binary search , using the comparison function , is done to find the value . If duplicates are present , the index of the first instance is returned . <p> RWBoolean insert ( val v ) ; <p> Insert the new value v into the vector . A binary search , using the comparison function , is performed to determine where to insert the value . The item will be inserted after any duplicates . If the insertion causes the vector to exceed its capacity , it will automatically be resized by an amount given by RWDEFAULTRESIZE . <p> void removeAt ( sizet indx ) ; <p> Remove the item at position indx from the collection . The value of indx must be between zero and the length of the collection less one . No bounds checking is performed . Old items from index indx+1 will be shifted to lower @ @ @ @ @ @ @ @ @ @ be moved to position indx , etc .. <p> void resize ( sizet newCapacity ) ; <p> Change the capacity of the collection to newCapacity , which must be at least as large as the present number of items in the collection . Note that the actual number of items in the collection does not change , just the capacity . 
@@75677804 @4377804/ <p> **25;8599;TOOLONG , V&gt; is a dictionary of keys of type K and values of type V , implemented using a hash table . While duplicates of values are allowed , duplicates of keys are not . <p> It is a pointer based collection : pointers to the keys and values are copied in and out of the hash buckets . <p> Parameters K and V represent the type of the key and the type of the value , respectively , to be inserted into the table . These can be either classes or fundamental types . Class K must have <p> well-defined equality semantics ( K : : operator== ( const K&amp; ) ) . <p> Class V can be of any type . <p> A user-supplied hashing function for type K must be supplied to the constructor when creating a new table . If K is a Rogue Wave class , then this requirement is usually trivial because most Rogue Wave objects know how to return a hashing value . In fact , classes RWCString , RWDate , RWTime , and RWWString contain static member functions called @ @ @ @ @ @ @ @ @ @ . The function must have prototype : <p> unsigned hFun ( const K&amp; a ) ; <p> and should return a suitable hash value for the object a . <p> To find a value , the key is first hashed to determine in which bucket the key and value can be found . The bucket is then searched for an object that is equal ( as determined by the equality operator ) to the key . <p> The initial number of buckets in the table is set by the constructor . There is a default value . If the number of ( key/value ) pairs in the collection greatly exceeds the number of buckets then efficiency will sag because each bucket must be searched linearly . The number of buckets can be changed by calling member function resize() . This is relatively expensive because all of the keys must be rehashed . <p> If you wish for this to be done automatically , then you can subclass from this class and implement your own special insert() and remove() functions which perform a resize() as necessary . <p> Constructs an empty @ @ @ @ @ @ @ @ @ @ a user-defined hashing function for items of type K ( the key ) . The table will initally have buckets buckets although this can be changed with member function resize() . <p> **25;8626;TOOLONG , V&gt; ( const **25;8653;TOOLONG , V&gt;&amp; c ) ; <p> Constructs a new hash dictionary as a shallow copy of c . After construction , pointers will be shared between the two collections . The new object will use the same hashing function and have the same number of buckets as c . Hence , the keys will not be rehashed . <p> Sets self to a shallow copy of c . Afterwards , pointers will be shared between the two collections . Self will use the same hashing function and have the number of buckets as c . Hence , the keys will not be rehashed . <p> V*&amp; operator ( K* key ) ; <p> Look up the key key and return a reference to the pointer of its associated value . If the key is not in the dictionary , then it is added to the dictionary . In this case , the @ @ @ @ @ @ @ @ @ @ this , if there is a possibility that a key will not be in the dictionary , then this operator can only be used as an lvalue . <p> Applies the user-defined function pointed to by applyFun to every key-value pair in the dictionary . This function must have prototype : <p> void yourFun ( K* key , V*&amp; value , void* d ) ; <p> This function will be called for each key value pair in the dictionary , with a pointer to the key as the first argument and a reference to a pointer to the value as the second argument . The key should not be changed or touched . A new value can be substituted , or the old value can be changed . Client data may be passed through as parameter d . <p> void clear() ; <p> Removes all key value pairs from the collection . <p> void clearAndDestroy() ; <p> Removes all key value pairs from the collection and deletes both the keys and the values . Do not use this method if multiple pointers to the same object are stored . <p> @ @ @ @ @ @ @ @ @ @ Returns TRUE if the dictionary contains a key which is equal to the key pointed to by key . Returns FALSE otherwise . Equality is measured by the class-defined equality operator for type K. <p> sizet entries() const ; <p> Returns the number of key-value pairs currently in the dictionary . <p> K* find ( const K* key ) const ; <p> Returns a pointer to the key which is equal to the key pointed to by key , or nil if no such item could be found . Equality is measured by the class-defined equality operator for type K. <p> V* findValue ( const K* key ) const ; <p> Returns a pointer to the value associated with the key pointed to by key , or nil if no such item could be found . Equality is measured by the class-defined equality operator for type K. <p> K* findKeyAndValue ( const K* key , V*&amp; retVal ) const ; <p> Returns a pointer to the key associated with the key pointed to by key , or nil if no such item could be found . If a key is @ @ @ @ @ @ @ @ @ @ in retVal . Equality is measured by the class-defined equality operator for type K. <p> void insertKeyAndValue ( K* key , V* value ) ; <p> If the key pointed to by key is in the dictionary , then its associated value is changed to value . Otherwise , a new key value pair is inserted into the dictionary . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if the dictionary has no items in it , FALSE otherwise . <p> K* remove ( const K* key ) ; <p> Removes the key and value pair where the key is equal to the key pointed to by key . Returns the key or nil if no match was found . Equality is measured by the class-defined equality operator for type K. <p> void resize ( sizet N ) ; <p> Changes the number of buckets to N. This will result in all of the keys being rehashed. 
@@75677805 @4377805/ <p> Conducts Bartlett 's and Levene 's tests of the homogeneity of variance assumption in analysis of variance . <p> Usage <p> result = HOMOGENEITY ( ntreatment , treatment , y ) <p> Input Parameters <p> ntreatment " Number of treatments . ntreatment must be greater than one . <p> treatment " Array of length n , where n is the number of observations , containing the treatment identifiers for each observation in y . Each level of the treatment must be assigned a different integer . HOMOGENEITY verifies that the number of unique treatment identifiers is equal to ntreatment . <p> y " Array of length n , where n is the number of observations , containing the experimental observations and any missing values . Missing values can not be omitted . They are indicated by placing a NaN ( Not a Number ) at the appropriate positions in y . NaN can be defined by calling the MACHINE function . For example : <p> Residuals " Array of length n containing the residuals for non-missing observations . The ordering of the values in this array corresponds to @ @ @ @ @ @ @ @ @ @ values in treatment . <p> Studentizedresiduals " Array of length n containing the studentized residuals for non-missing observations . The ordering of the values in this array corresponds to the ordering of values in y and identified by the values in treatment . <p> Traditional analysis of variance assumes that variances within treatments are equal . This is referred to as homogeneity of variance . HOMOGENEITY conducts both the Bartlett 's and Levene 's tests for this assumption : <p> versus : <p> for at least one pair ( iG j ) , where t = ntreatments . <p> Bartlett 's test , Bartlett ( 1937 ) , uses the test statistic : <p> where : <p> and is the variance of the non-missing observations in the ith treatment . is referred to as the pooled variance , and it is also known as the error mean squares from a 1-way analysis of variance . <p> If the usual assumptions associated with the analysis of variance are valid , then Bartlett 's test statistic is a chi-squared random variable with degrees of freedom equal to t " 1 . <p> @ @ @ @ @ @ @ @ @ @ the mean for the ith treatment . Conover , Johnson , and Johnson ( 1981 ) compared over 50 similar tests for homogeneity and concluded that one of the best tests was Levene 's test when the treatment mean , is replaced with the treatment median , . This version of Levene 's test can be requested by setting the Medianlevenes keyword . In either case , Levene 's test statistic is treated as a F random variable with numerator degrees of freedom equal to ( t " 1 ) and denominator degrees of freedom ( N " t ) . <p> The residual for the jth observation within the ith treatment , , returned from Residuals is unstandarized , i.e. . For investigating problems of homogeneity of variance , the studentized residuals returned by Studentizedresiduals are recommended since they are standardized by the standard deviation of the residual . The formula for calculating the studentized residual is : <p> where the coefficient of variation , returned from cv , is also calculated using the pooled variance and the grand mean : <p> Example <p> This example applies Bartlett 's @ @ @ @ @ @ @ @ @ @ a one-way analysis of variance . There are eight treatments , each with 3 replicates for a total of 24 observations . The estimated treatment standard deviations range from 5.35 to 13.17 . <p> In this case , Bartlett 's test is not statistically significant for a stated significance level of 0.05 ; whereas Levene 's test is significant with p = 0.006. 
@@75677806 @4377806/ <h> SourcePro Features &amp; Benefits <p> SourcePro Core is a highly optimized layer , taking advantage of each operating system and compiler features . It provides maximum performance and security while minimizing your application maintenance cost . <p> A flexible and intuitive non-intrusive streaming mechanism for complex stream transformations and object serializations , making it possible to stream nearly any C++ class with minimal code changes . Its flexible thread-safety alternatives allow control for each stream within an application . <p> A complete framework for internationalization and localization . The modules extensive support for Unicode string processing , locale-sensitive handling of regular expressions , searching , collation , boundary analysis , normalization , and tokenizing provides the foundation for all application internationalization needs . With the Internationalization Module , a single application can meet the needs of multiple cultures with the ability to process times , dates , strings and currency in native format . <p> A complete set of C++ components designed for the quick creation of high-performance multithreaded applications . The module provides a higher-level , object-oriented API that hides many of the complexities of multithreading in @ @ @ @ @ @ @ @ @ @ , manipulating , synchronizing and deleting threads . <h> SourcePro Core Features <p> Features <p> Benefits <p> Consistent and intuitive API across supported platforms <p> Applications run on multiple operating systems , with no code changes . The same API philosophy across all classes , to minimize internal training cost . <p> Higher-level , object-oriented interface to complex underlying APIs <p> Simplifies the effort of building and managing powerful applications by providing ready-made APIs that do a lot of the heavy lifting . <p> Extends the ANSI Standard C++ Library with additional functionality <p> Easier for developers to manipulate features like dates and times in their applications . <p> Complete set of string processing classes <p> An easier and less error-prone way to work with single , multibyte , and wide character strings . <p> Multiple , extensive sets of collection classes <p> Developers have the flexibility to select the classes that best meet their specific needs . 
@@75677807 @4377807/ <h> Members <h> Non-Members <p> The class RWCConstSubString allows some subsection of an RWCString to be addressed by defining a starting position and an extent . For example , the 7th through the 11th elements , inclusive , would have a starting position of 7 and an extent of 5 . The specification of a starting position and extent is also done on your behalf by such functions as RWCString : : strip() . There are no public constructors other than one that creates an RWCConstSubString from an existing RWCSubString . In general , RWCConstSubStrings are constructed by various functions of the RWCConstSubString class and then destroyed immediately . <p> A zero length substring is one with a defined starting position and an extent of zero . It can be thought of as starting just before the indicated character , but not including it . It can be used as an lvalue . A null substring is also legal and is frequently used to indicate that a requested substring , perhaps through a search , does not exist . A null substring can be detected with member function isNull() @ @ @ @ @ @ @ @ @ @ lvalue . <p> Note that RWCConstSubString is only available with the alternate implementation of RWCString . When building on top of a compliant standard library , RWCString uses an alternate implementation that is a thin wrapper on top of std : : string . The RWCString interface remains the same , with the addition of this method for easy conversion : <p> std : : string std() ; <p> and other overloads on std : : string . For applications doing many RWCString-&gt;std : : string conversions , significant speed improvements might be obtained by using the RWCString standard library implementation . <p> Return the ith character of the substring . The index i must be between zero and the length of the substring , less one . Bounds checking is performed : if the index is out of range , then an exception of type RWBoundsErr will occur . <p> char operator() ( sizet i ) const ; <p> Return the ith character of the substring . The index i must be between zero and the length of the substring , less one . Optional bounds checking is enabled @ @ @ @ @ @ @ @ @ @ In this case , if the index is out of range , then an exception of type RWBoundsErr will occur . 
@@75677808 @4377808/ <h> 9.2 Levels of Multithread Support <p> Different DBTools.h++ classes provide different levels of multithread support . Application programs must ensure that DBTools.h++ classes are used appropriately , based on the safety level they provide . The multithread support levels available in DBTools.h++ are : <p> MT-safe level 2 . This is the highest level of multithread support . When an object provides MT-safe level 2 support , application programs can share the object among threads without performing explicit locking around operations . MT-safe level 2 classes contain enough internal locking to maintain their own internal integrity and use appropriate multithread-safe system calls . RWDBDatabase is the only class in DBTools.h++ that provides MT-safe level 2 support . <p> MT-safe level 1 . This is the medium level of multithread support . When an object provides MT-safe level 1 support , application programs can share the object among threads , but they need to perform explicit locking around operations . <p> Currently RWDBConnection is the only database-dependent class in DBTools.h++ that provides MT Safe level 1 support . <p> In addition to RWDBConnection , all the database-independent classes that @ @ @ @ @ @ @ @ @ @ SQL phrases , and debugging classes can be used as MT-safe level 1 classes . A list of these classes appears in Table 11 , and they are discussed in Section 9.5 . <p> MT-safe level 0 . This is the lowest level of multithread support . MT-safe level 0 classes can not be shared among threads . All the classes in Tools.h++ and DBTools.h++ other than the ones shown in Table 11 should be considered MT-safe level 0 classes . <p> The DBTools.h++ classes that fall into each level are summarized below . Table 11 lists all MT-safe level 1 and level 2 classes . If a class does not appear there , you should assume that its multithreading support level is MT-safe level 0 . <p> You will find the acquire() and release() functions normally associated with multithreading in the APIs of many MT-safe level 0 classes . Do not use these functions at this time because they slow down performance . We have included the acquire() and release() functions only for the purpose of making classes multithread-ready . These functions will be available if and when the @ @ @ @ @ @ @ @ @ @ will provide information on classes that are promoted to a higher multithread-safety level . 
@@75677810 @4377810/ <p> Localized message databases are located in a subdirectory under the locale directory . This subdirectory is named after the corresponding language and the encoding method used . The subdirectory name has the following format : <p> &lt;llTT.encoding&gt; <p> For example , on a UNIX system , the French message database files are found in the subdirectory frFr.ISO-8859-1 under the locale directory . See the section Rogue Wave Views Locale Names for more information on the Rogue Wave Views locale naming conventions from which the subdirectory name is derived . <p> On UNIX Systems <p> French message database files can be LONG ... <p> LONG ... /prstudio.dbm <p> LONG ... <p> LONG ... <p> LONG ... <p> On Microsoft Windows Systems <p> French message database files can be found in the following directories : <p> You can run the following program to help you find the location of your message database files . <p> #include &lt;ilviews/ilv.h&gt; <p> #include &lt;ilog/pathname.h&gt; <p> #include &lt;stdlib.h&gt; <p> int @ @ @ @ @ @ @ @ @ @ if ( ! IlvSetLocale() ) <p> exit(1) ; <p> <p> IlPathName pname ( " " ) ; <p> pname.localize() ; <p> IlvPrint ( " nLooking under directories : ... /%snn " , <p> **28;8680;TOOLONG ) ; <p> return 0 ; <p> <p> Note : The C locale ( that is , the Rogue Wave Views locale enUS ) , which is considered the standard , is an exception to the above mentioned rule . Rogue Wave Views . dbm files are located in the directory of the library that uses them . For example , views.dbm can be found in the LONG ... You do not need to create the enUS.US-ASCII directory . Rogue Wave Views will automatically fall back to the regular data directory . <p> For example , on an HP-UX system with your LANG set to frFR.iso88591 or on a Solaris system with your LANG set to fr , you get the following result : 
@@75677812 @4377812/ <p> Class RWDate represents a date , stored as a Julian day number . The member function isValid() can be used to determine whether an RWDate is a valid date . For example , isValid() would return FALSE for the date 29 February 1991 because 1991 is not a leap year . See " Using Class RWDate " in the Tools.h++ User 's Guide . <p> RWDate 's can be converted to and from RWTime 's , and to and from the Standard C library type structtm defined in &lt;time.h&gt; . <p> Note that using a 2-digit year specifier in your code may lead to less-than-perfect behavior at the turn of the century . We urge you to create programs that are " millenially correct " by using 4-digit year specifiers . <p> Note that because the default constructor for this class creates an instance holding the current date , constructing a large array of RWDate may be slow . <p> RWDate v5000 ; // Figures out the current date 5000 times <p> Those with access to the Standard C++ Library-based versions of the Tools.h++ template collections should consider @ @ @ @ @ @ @ @ @ @ just once : **33;8710;TOOLONG v ( 5000 , RWDate() ) ; <p> Thanks to the smart allocation scheme of the standard collections , the above declaration will result in only one call to the default constructor followed by 5000 invocations of the copy constructor . In the case of RWDate , the copy constructor amounts to an assignment of one long to another , resulting in faster creation than the simple array . <p> Constructs an RWDate with a given day of the year and a given year . The member function isValid() can be used to test whether the results are a valid date . <p> RWDate ( unsigned day , unsigned month , unsigned year ) ; <p> Constructs an RWDate with the given day of the month , month of the year , and year . Days should be 1-31 , months should be 1-12 , and the year may be specified as ( for example ) 1990 , or 90 . The member function isValid() can be used to test whether the results are a valid date . <p> Constructs an RWDate with the given day @ @ @ @ @ @ @ @ @ @ argument is used to convert the month name . Days should be 1-31 , months may be specified as ( for example ) : January , JAN , or Jan , and the year may be specified as ( for example ) 1990 , or 90 . The member function isValid() can be used to test whether the results are a valid date . <p> RWDate ( istream&amp; s , const RWLocale&amp; locale = RWLocale : : global() ) ; <p> A full line is read , and converted to a date by the locale argument . The member function isValid() must be used to test whether the results are a valid date . Because RWLocale can not rigorously check date input , dates created in this way should also be reconfirmed by the user . <p> The string str is converted to a date . The member function isValid() must be used to test whether the results are a valid date . Because RWLocale can not rigorously check date input , dates created in this way should also be reconfirmed by the user . <p> RWDate ( const RWTime&amp; @ @ @ @ @ @ @ @ @ @ ) ; <p> Constructs an RWDate from an RWTime . The time zone used defaults to local . The member function isValid() must be used to test whether the results are a valid date . <p> RWDate ( const struct tm* ) ; <p> Constructs an RWDate from the contents of the struct tm argument members tmyear , tmmon , and tmmday . Note that the numbering of months and years used in structtm differs from that used for RWDate and RWTime operations . structtm is declared in the standard include file &lt;time.h&gt; . <p> RWDate ( unsigned long jd ) ; <p> Construct a date from the Julian Day number jd . Note that it is possible to construct a valid RWDate which represents a day previous to the beginning of the Gregorian calendar for some locality . Rogue Wave does n't know the specifics for your locality , so will not enforce an arbitrary cutoff for " validity . " <p> Returns the date as a string , formatted by the RWLocale argument . Formats are as defined in the standard C library function strftime() . <p> RWBoolean @ @ @ @ @ @ @ @ @ @ const ; <p> Returns TRUE if this RWDate is between a and b , inclusive . <p> sizet binaryStoreSize() const ; <p> Returns the number of bytes necessary to store the object using the global function <p> RWFile&amp; operator&lt;&lt; ( RWFile&amp; , const RWDate&amp; ) ; <p> int compareTo ( const RWDate* d ) const ; <p> Compares self to the RWDate pointed to by d and returns : <p> 0 if self == *d ; <p> 1 if self &gt; *d ; <p> -1 if self &lt; *d . <p> unsigned day() const ; <p> Returns the day of the year ( 1-366 ) for this date . <p> unsigned dayOfMonth() const ; <p> Returns the day of the month ( 1-31 ) for this date . <p> void extract ( struct tm* ) const ; <p> Returns with the struct tm argument filled out completely , with the time members set to 0 and tmisdst set to -1 . Note that the encoding for months and days of the week used in structtm differs from that used elsewhere in RWDate . If the date is invalid , all @ @ @ @ @ @ @ @ @ @ ; <p> Returns the day of the year ( 1-366 ) corresponding to the first day of this RWDate 's month and year . <p> unsigned firstDayOfMonth ( unsigned month ) const ; <p> Returns the day of the year ( 1-366 ) corresponding to the first day of the month month ( 1-12 ) in this RWDate 's year . <p> unsigned hash() const ; <p> Returns a suitable hashing value . <p> RWBoolean isValid() const ; <p> Returns TRUE if this is a valid date , FALSE otherwise . <p> The following two functions are provided as a service to users who need to manipulate the date representation directly . The julian day number is not the Julian date ! . The julian day number is calculated using Algorithm 199 from Communications of the ACM , Volume 6 , No. 8 , ( Aug. 1963 ) , p. 444 and is valid for any valid Gregorian date in the Gregorian calendar . The Gregorian calendar was first introduced on Sep . 14 , 1752 , and was adopted at various times in various places . <p> unsigned long @ @ @ @ @ @ @ @ @ @ day number .. <p> void julian ( unsigned long j ) ; <p> Changes the value of the julian day number to j . <p> RWBoolean leap() const ; <p> Returns TRUE if the year of this RWDate is a leap year . <p> RWDate max ( const RWDate&amp; t ) const ; <p> Returns the later date of self or t . <p> RWDate min ( const RWDate&amp; t ) const ; <p> Returns the earlier date of self or t . <p> unsigned month() const ; <p> Returns the month ( 1-12 ) for this date . <p> RWCString monthName ( const RWLocale&amp; = RWLocale : : global() ) const ; <p> Returns the name of the month for this date , according to the optional RWLocale argument . <p> RWDate next ( unsigned dayNum ) const ; <p> Returns the date of the next numbered day of the week , where Monday = 1 , ... , Sunday = 7 . The variable dayNum must be between 1 and 7 , inclusive . <p> If d1&gt;d2 , returns the number of days between d1 and d2 . @ @ @ @ @ @ @ @ @ @ operator- ( const RWDate&amp; d , unsigned long s ) ; <p> Returns the date s days in the past from d . <p> ostream&amp; operator&lt;&lt; ( ostream&amp; s , const RWDate&amp; d ) ; <p> Outputs the date d on ostream s , according to the locale imbued in the stream ( see class RWLocale ) , or by RWLocale : : global() if none . <p> istream&amp; operator&gt;&gt; ( istream&amp; s , RWDate&amp; t ) ; <p> Reads t from istreams . One full line is read , and the string contained is converted according to the locale imbued in the stream ( see class RWLocale ) , or by RWLocale : : global() if none . The function RWDate : : isValid() must be used to test whether the results are a valid date . 
@@75677815 @4377815/ <p> Class RWGOrderedVector(val) represents an ordered collection of objects of val val . Objects are ordered by the order of insertion and are accessible by index . Duplicates are allowed . RWGOrderedVector(val) is implemented as a vector , using macros defined in the standard C++ header file &lt;generic.h&gt; . <p> Note that it is a value-based collection : items are copied in and out of the collection . <p> Construct an ordered vector of elements of val val . The initial capacity of the vector will be capac whose default value is RWDEFAULTCAPACITY . The capacity will be automatically increased as necessary should too many items be inserted , a relatively expensive process because each item must be copied into the new storage . <p> Return the ith value in the vector . The index i must be between 0 and one less than the number of items in the vector . No bounds checking is performed . The second variant can be used as an lvalue , the first can not . <p> val operator ( sizet i ) const ; val&amp; operator ( sizet i ) ; @ @ @ @ @ @ @ @ @ @ index i must be between 0 and one less than the number of items in the vector . Bounds checking will be performed . The second variant can be used as an lvalue , the first can not . <p> void clear() ; <p> Remove all items from the collection . <p> const val* data() const ; <p> Returns a pointer to the raw data of self . Should be used with care . <p> sizet entries() const ; <p> Return the number of items currently in the collection . <p> sizet index ( val item ) const ; <p> Perform a linear search of the collection returning the index of the first item that isEqual to the argument item . If no item is found , then it returns RWNPOS . <p> void insert ( val item ) ; <p> Add the new value item to the end of the collection . <p> void insertAt ( sizet indx , val item ) ; <p> Add the new value item to the collection at position indx . The value of indx must be between zero and the length of the @ @ @ @ @ @ @ @ @ @ from index indx upwards will be shifted to higher indices . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if the collection has no entries . FALSE otherwise . <p> void sizetlength() const ; <p> Synonym for entries() . <p> valpop() ; <p> Removes and returns the last item in the vector . <p> void push(val) ; <p> Synonym for insert() . <p> removeAt ( sizet indx ) ; <p> Removes the item at position indx from the collection . The value of indx must be between zero and one less than the length of the collection . No bounds checking is performed . Old items from index indx+1 will be shifted to lower indices . E.g. , the item at index indx+1 will be moved to position indx , etc . <p> void resize ( sizet newCapacity ) ; <p> Change the capacity of the collection to newCapacity , which must be at least as large as the present number of items in the collection . Note that the actual number of items in the collection does not change , just the capacity . 
@@75677816 @4377816/ <p> For applications requiring only small integers , these classes may be used for high efficiency and compactness . They are also very useful for storing and manipulating graphical images and 8-bit data streams from A/D converters , digitizers , and so on . This makes it easy to take a 2-dimensional Fourier transform of a graphical image , for example : <p> Notice that we use the integer representations of the elements for input/output of vectors of signed or unsigned chars , not the literal character constants . This can differ from the behavior of your compiler when a single element is printed on an output stream . For example , the code : <p> char a = ' $ ' ; cout &lt;&lt; a ; <p> prints $with most compilers . However , the code : <p> RWMathVec&lt;SChar&gt; a ( 3 , ' $ ' ) ; cout &lt;&lt; a ; <p> always prints 36 36 36 with the Essential Math Module . This is because the vector classes are primarily a tool for manipulating numbers , not strings . The Essential Tools Module class RWCString should be used for manipulating strings . 50235 @qwx670235 
@@75677817 @4377817/ <h> 5.2 Expressions , Criterions , and Assignments <p> One of the great advantages of a client/server environment is the ability of the client to defer computation to the server . When a complicated query is requested , the client does not have to execute the query itself ; the server does the work . This is illustrated by SQL statements like this : <p> The WHERE clause , which is specified by the client but executed by the server , contains a type of expression that is encapsulated in the DB Interface Module by the classes RWDBExpr , RWDBCriterion , and RWDBAssignment . These classes represent the following expressions : <p> RWDBCriterion is used in the context of a boolean expression , as in the WHERE clause above . <p> RWDBAssignment is used in assigning new values to columns , as in the SET clause for updating rows . <p> The various databases have minor differences in their expression syntax . For example , the Sybase database has a modulus operator , while the Oracle database uses a function call instead . The DB Interface Module reconciles these @ @ @ @ @ @ @ @ @ @ literals , and function invocations to encapsulate expressions . The Access module then translates expressions into forms appropriate for the database in use . These translations are described in the guides for the Access Modules . <p> Instances of the RWDBExpr , RWDBCriterion , and RWDBAssignment classes are usually created anonymously . The following sections show how objects of these classes originate and interact . <p> The RWDBSelector instance on //2 is explained in Section 5.3 of this manual . For now , look at //3 . The where() member function of RWDBSelector accepts an RWDBCriterion instance as an argument . A C++ expression involving an RWDBColumn instance column1 , the operator== , and a literal 17 are passed to it . Through automatic type conversions and overloading of the relational operator== , an RWDBCriterion instance is provided . Here 's what happens : <p> First , the compiler tries to apply the == operator to the instance of the RWDBColumn and the literal integer 17 . <p> Since there is no operator to accomplish this , it tries to cast the column and integer into objects on which it @ @ @ @ @ @ @ @ @ @ can take is to cast the RWDBColumn instance into an RWDBExpr . <p> The compiler then does the same thing for the literal integer . <p> Once these are cast , the compiler can apply the operator== for the two instances of RWDBExpr . Since operator== for two RWDBExpr instances returns an instance of RWDBCriterion , the where() member function is satisfied . <p> Internally , RWDBExpr instances are data structures in the form of trees . The RWDBCriterion class derives from RWDBExpr and , therefore , is similarly structured . The example in Section 5.2.1 results in an RWDBCriterion instance containing a three-node binary tree . The root node represents the dyadic expression of the operator== . The two leaf nodes represent the column and the literal integer 17 . <p> It is important to note that evaluation of RWDBExpr instances is done by the library at the time of the execution . Expressions that produce RWDBExpr or RWDBCriterion instances might look like any other C++ expression , but their evaluation is deferred to the access library module . <p> Here is another example , which constructs a more @ @ @ @ @ @ @ @ @ @ exists : <p> aSelector.where ( ( col1 % 5 == 0 ) col2.isNull() ) ; <p> The underlying access library module evaluates this expression according to its own syntax . For the Oracle database , the expression would be evaluated as : <p> WHERE ( MOD ( COL1 , 5 ) = 0 ) OR COL2 IS NULL <p> For Sybase it would be slightly different : <p> WHERE ( COL1 % 5 = 0 ) OR COL2 IS NULL <p> This difference arises because the Oracle database has a modulus function , while the Sybase database has a modulus operator . <p> RWDBAssignment also derives from RWDBExpr . It is used in assigning new values to columns in tables , in other words , updating . The only way to create an instance of class RWDBAssignment is through the invocation of the RWDBColumn : : assign() method . An RWDBAssignment is an encapsulation of the SQL phrase : <p> SET column = expression <p> where column refers to the RWDBColumn instance whose assign() method produced the RWDBAssignment , and expression refers to its argument . Here is an example @ @ @ @ @ @ @ @ @ @ RWDBAssignment serve as encapsulations of expressions to be evaluated by the DB Interface Module and executed at the database . They allow the use of the familiar C++ expression syntax , while offering the advantage of database portability . 
@@75677818 @4377818/ <p> Class RWTPtrVector&lt;T&gt; is a simple parameterized vector of pointers to objects of type T. It is most useful when you know precisely how many pointers must be held in the collection . If the intention is to " insert " an unknown number of objects into a collection , then class **28;8745;TOOLONG may be a better choice . <p> Sets self to a shallow copy of v. Afterwards , the two vectors will have the same length and pointersheld by the two vectors will point to the same items . <p> **26;8775;TOOLONG operator= ( T* p ) ; <p> Sets all elements in self to point to the item *p . <p> T*&amp; operator() ( sizet i ) ; T* operator() ( sizet i ) const ; <p> Returns the ith value in the vector . The first variant can be used as an l-value , the second can not . The index i must be between zero and the length of the vector , less one . No bounds checking is performed . <p> T*&amp; operator ( sizet i ) ; T* operator ( sizet i ) @ @ @ @ @ @ @ @ @ @ . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the length of the vector , less one ; or an exception of type TOOLINDEX will be thrown . 
@@75677819 @4377819/ <h> Application and Transaction Management <p> SOA is used to build real-world business applications , delivering real business value and solving real business problems . Faults and performance problems in a Web service might not appear to be a huge problem , but they may lead to a failure to respond to a customer , a misplaced order , or a failure to invoice or collect on a service or product that has been delivered . <p> The distributed nature of service-oriented applications makes it difficult to identify and diagnose problems . For example , an unacceptable delay when a customer clicks a button on a commerce site might be caused by a connection timeout in an unrelated database that provides a logging function to a Web service that is indirectly invoked by another application called by the portal . <p> Application support and operations teams must be alerted to these issues and must be able to identify their root cause , debug , and fix them in near real-time . These teams are often measured against Mean-Time-To-Repair , so seeing problems before they occur , and quickly finding @ @ @ @ @ @ @ @ @ @ mile , first-mile and network monitoring of messages to collect real-time performance , usage , fault and message data for any service deployed on any platform . Akanas Service Manager monitors services from the perspective of the consumer to ensure that consumer specific SLAs and usage criteria are not polluted by traffic from other consumers . <p> Transaction tracking Using standards like WS-Addressing , Service Manager can track the path of a transaction across multiple messages between different consumers , services , applications , and platforms . This allows customers to identify root cause for individual transactions as well as to build a map of a whole application and all the consumers and services it is made up of . <p> Service Level Agreement Management Service Manager provides comprehensive SLA capabilities with the ability to manage and monitor SLAs for consumer contracts . This unique ability ensures accurate monitoring of services from the perspective of their different consumers one application might make more complex and larger requests that take an average of 200ms to process , where the average response time for the whole service is only 50ms . In @ @ @ @ @ @ @ @ @ @ monitored from the perspective of the consumer , in order to provide an accurate assessment of service level . <p> Dynamic Management Service Manager implements a comprehensive dynamic management model that can automatically adjust the infrastructure to address exceptions and service-level issues . Using the monitoring and SLA management capabilities described above , Service Manager can identify potential problems and can reroute traffic , throttle low-priority requests , or even deploy new service instances to ensure continuous operation of service-oriented applications . <p> Akanas products are used by Fortune 500 companies to ensure continuous operation of their service-oriented applications providing a state of the art application and transaction management solution . 
@@75677820 @4377820/ <p> The following figure shows the inheritance tree of predefined business classes . <p> Inheritance tree of predefined business classes <p> All predefined business object classes can be retrieved using the method GetIlpClass , which is declared in each one of these classes ; for example , GetIlpClass . Every business class contains specific attributes that you can set using their particular API , for example , **34;8803;TOOLONG , or the generic IlpObject API , for example , LONG ... . See Business model API . <p> Instances of predefined business classes hold two types of data : structural data and states and alarms . <p> Structural data remains constant while the application is running . It includes : <p> Characteristics of the element ( for example , its name , Toronto-C10 ) . <p> The key properties of the element that have an impact on its own representation , regardless of its states or alarms . The network element function and family ( such as , ATM , OC192 ) are examples of structural data that can be displayed permanently . <p> State and alarm data describes the @ @ @ @ @ @ @ @ @ @ . A state can have several different aspects that depend on the type of network management used . For example , in the OSI state system , there are three categories of states : operational states , usage states , and administrative states . On top of these values , a set of statuses can further qualify the managed object . In other standards , such as Bellcore , all states are either primary or secondary states . 
@@75677821 @4377821/ <p> This constant represents the false value for an IlBoolean value . It is equivalent to false for compilers that support the internal bool type . <p> #define IlMax <p> ( <p> v1 , <p> v2 <p> ) <p> Returns the maximum of two values . <p> This is defined as a macro for the types int , long , short , float and double . v1 and v2 must have the same type ( or be able to cast themselves to the type of the other ) . 50234 @qwx670234 <p> v1 <p> The first input value . <p> v2 <p> The second input value . <p> Returns : <p> The maximum value of v1 and v2 that is , v1 if v1 is greater than v2 , and v2 if v2 is greater than v1 . <p> #define IlMin <p> ( <p> v1 , <p> v2 <p> ) <p> Returns the minimum of two values . <p> This is defined as a macro for the types int , unsigned int , long , unsigned long , short , unsigned short , float and double.v1 and v2 must @ @ @ @ @ @ @ @ @ @ themselves to the type of the other ) . 50234 @qwx670234 <p> v1 <p> The first input value . <p> v2 <p> The second input value . <p> Returns : <p> The minimum value of v1 and v2 that is , v1 if v2 is greater than v1 , and v2 if v1 is greater than v2 . <h> Typedef Documentation <p> The type IlBoolean deals with Boolean entities . Boolean values within Rogue Wave Views are always handled by means of IlBoolean objects . A value is considered to be true when set to IlTrue , and false when set to IlFalse . Note that this is equivalent to the internal bool type of compilers that support it . 
@@75677823 @4377823/ <h> Work together to eliminate defects <p> Klocwork code review brings all of our safety , reliability , and coding standards defects into a collaborative problem-solving environment , so your teams can fix them faster . With all the features of a standard code review tool , such as smart diffs and integration into your source code management system , Klocwork is already on top of your review game . Adding in social notifications , threaded discussions , and an infinite activity wall , developers are always informed and instantly able to help solve the latest defects and create better code . <h> Faster reviews at the desktop <p> Developers can start , participate in , or follow reviews with just one click - for any type of code or text file . The review space can be designed and customized to suit individual needs by monitoring relevant projects , creating interest areas , and getting notified of only the things that matter . With analysis results and issues integrated right into the review space , developers work together in real-time to trace , comment , and fix issues @ @ @ @ @ @ @ @ @ @ easily checked in with support for several SCMs , including Git , Perforce , Subversion , ClearCase , and CVS . <h> Less time spent on fixes <p> Klocwork brings social collaboration to solving coding issues , combining skillsets and sharing this learning across teams . Here 's just a few of the ways in which Klocwork speeds up code reviews : <p> Every developer has real-time notifications and a customizable activity wall , instantly seeing when and where they can help out <p> Personal backlogs , to-do lists , and a rich search grammar , allow anyone to quickly determine the current state of their defect-reduction activities <p> Relevant actions can be assigned to authors , other reviewers , or even unrelated parties to focus work better <p> WHITE PAPER : Modernizing the Peer Code Review Process The value of peer code review is undeniable however they are difficult to implement consistently , the review is often left incomplete , and let 's be honest , developers generally do n't like doing them . Learn specific recommendations on how organizations can implement a simple , effective code review process @ @ @ @ @ @ @ @ @ @ Learn more . 
@@75677824 @4377824/ <h> 2.5 Smart Pointer Package <p> The Threads.h++ Smart Pointer package includes a generic singleton template class , a simple pointer wrapper , and two varieties of thread-safe reference-counted pointers . The classes that provide these features are shown in Figure 8 . The Smart Pointer package also provides Threads.h++ with the base classes for handle-body implementation , as shown in Figure 9 . <p> A typedef that implements an unsafe counter that can be used for reference counting where multithread safety is not required . This typedef can be used as the counter template parameter for RWTCountingPointer. 
@@75677825 @4377825/ <h> Standard C++ Library Class Reference <h> Version 1.2 <p> This reference guide is an alphabetical listing of all of the classes , algorithms , and function objects provided by this release of Rogue Wave 's Standard C++ Library . The gray band on the first page of each entry indicates the category ( e.g. , Algorithms , Containers , etc. ) that the entry belongs to . The table below lists the contents organized by category . <p> For each class , the reference begins with a brief summary of the class ; a synopsis , which indicates the header file(s) ; and the signature of a class object . The reference continues with a text description of the class followed by the C++ code that describes the class interface . Next , all methods associated with a class , including constructors , operators , member functions , etc. are grouped in categories according to their general use and described . The categories are not a part of the C++ language , but do provide a way of organizing the methods . Following the member function descriptions , @ @ @ @ @ @ @ @ @ @ warnings associated with using the class are described . <p> Throughout the documentation , there are frequent references to " self , " which should be understood to mean " *this " . 
@@75677826 @4377826/ <p> Application requirements and environments are constantly evolving , creating challenges in architecture , scale , security , and code maintenance . Thorough analysis , strategic planning , and platform knowledge are key to moving legacy code to new environments and processes . Development teams tend to focus on the now , utilizing their expertise on new product features , and often lack the time or experience required to modernize applications . <p> Our code migration and modernization services move you to the most secure , supported , and best-performing open source runtimes , frameworks , and platforms to maximize performance and security . Our consultants focus on identifying key application requirements and needed code changes during a migration effort . They work closely with your developers , guiding them through implementation of the code modifications and environment upgrades . These services cover : <p> RHEL or other Linux to CentOS migration <p> PHP modernization <p> IBM i modernization <p> Java modernization <p> ActiveMQ migration <p> Zend Framework modernization <p> API enablement <p> Open source software modernization and upgrades <p> Developers spend a lot of time , perhaps most @ @ @ @ @ @ @ @ @ @ meets requirements - but what about ensuring that their code is more maintainable and extensible ? <p> Klocwork refactoring uses the deep semantic code knowledge provided by static code analysis to drive intelligent refactoring of C/C++ code within common IDEs , improving the design and structure of the application . Through sophisticated clone detection and inspection of all function invocations , Klocwork is able to automatically : <p> Abstract code into reusable segments <p> Remove duplication <p> Make variable names more meaningful <p> Generate a usability model to quickly measure the state of your code and improve its design within the IDE itself <p> Klocwork refactoring is all in service of making code easier to maintain and extend . 
@@75677827 @4377827/ <h> Member Function Documentation <p> A number indicating the relevant mouse button . Its value is meaningful only when the event has something to do with a mouse-button event ( that is , when the member function type returns either IlvButtonDown , IlvButtonUp , or IlvButtonDragged ) . Several mouse buttons are envisaged and can be combined for multiple button situations : IlvLeftButton , IlvMiddleButton , IlvRightButton and others values that are rarely used . <p> You can check whether any of the pointing device buttons is pressed by masking the getButton value with IlvAnyButton . If the result of an AND operation between those two values is not 0 , then a button has been pressed . <p> The code of a keyboard key that may have been pressed . It is relevant only when the member function type of your IlvEvent object has returned IlvKeyUp or IlvKeyDown . The value returned by this member function is either the ASCII code of the key that was pressed or a special code corresponding to one of the many keys available on the majority of keyboards. ( see IlvDeleteKey , @ @ @ @ @ @ @ @ @ @ Not every kind of keyboard will be able to produce each of these key codes . The values IlvUpKey , IlvDownKey , IlvLeftKey and IlvRightKey identify the arrow-pad keys . States of modifier keys such as Shift , Control and CAPS LOCK are managed internally . To ensure portability , do not define any other keyboard keys . <p> The current state of the modifier keys : IlvShiftModifier , IlvCtrlModifier , IlvAltModifier , IlvMetaModifier , IlvNumModifier , IlvLockModifier , IlvAltGModifier . <p> You can check for the presence of any of these modifiers by masking the modifiers value with IlvAnyModifier . <p> These values can be combined with a mouse-button code by means of an OR operation . Consequently , your programs can detect the combined effect of mouse-button and modifier-key states for any event . <p> Because typing a letter key combined with a Shift or Control key returns a different result depending on the system used , all letter-derived events lose their Shift/Control modifiers . It therefore becomes much easier to simply check the ASCII code of the key . For example , the ASCII code for Ctrl-A @ @ @ @ @ @ @ @ @ @ is 1 . <p> Other examples When you press Ctrl-Shift-A , you do not lose the Shift modifier and the event has the following fields : 
@@75677828 @4377828/ <h> Enumeration Type Documentation <p> Type used to indicate the different sources of input in the event loop . It is possible to use OR combinations of IlvInputEvent , IlvInputTimer , and IlvInputExternal to specify several types of input . For this reason , IlvInputMask is defined in such a way that : IlvInputNone == 0 and IlvInputAll == ( IlvInputEvent IlvInputTimer IlvInputExternal ) . <p> Enumerator : <p> IlvInputNone <p> No input . <p> Indicates no source of input . <p> IlvInputEvent <p> Events . <p> Indicates windowing system events , that is , IlvEvent as source of input . <p> This global function starts the main Rogue Wave Views event loop . It gives control of your application to the event loop . It then waits for incoming events from all the created instances of IlvDisplay and dispatches the event to the appropriate handlers . This function does not return . The only way to stop a Rogue Wave Views application is to exit the program , using IlvExit , in one of the application callbacks . You can replace this function with system-specific function calls that @ @ @ @ @ @ @ @ @ @ The IlvMainLoop function is equivalent to the following code : <p> You can replace the call to IlvMainLoop by any other code directly written with Windows function calls , provided that you do not use any Rogue Wave Views top windows . If you do use top windows and need to rewrite the Windows event loop , you can either use the member function IlvEventLoop : : nextEvent instead of GetMessage , or explicitly call the member function IlvAbstractView : : show of your top window after it has been created . <p> On Unix : The function IlvMainLoop is equivalent to the following code : 
@@75677829 @4377829/ <h> 4.1 Software Parts Manager Build Types <p> Builds of Rogue Wave libraries through Software Parts Manager are based on sixteen standard build types . The build options that determine these twelve types are described in the next section , followed by a summary table . <p> The Rogue Wave build types are based on four build options . Each of these is described below . <p> Each option description concludes with some remarks on the implications for the compiler command line invocation needed to build applications that depend on Rogue Wave libraries . Note , however , that these remarks do not necessarily cover all command line requirements . <p> The four variables are : <p> Does the library depend on the Standard C++ Library ? <p> Tools.h++ can be built as either Standard C++ Library-dependent or not . If Tools.h++ is built as dependent , any libraries built on Tools.h++ must also be built as Standard C++ Library-dependent . <p> Rogue Wave offers an implementation of the Standard C++ Library , but you are free to use other implementations . <p> Command line implications : For MSVC @ @ @ @ @ @ @ @ @ @ C++ Library is not in use ( RWNOSTL ) ; the Rogue Wave implementation of the Standard C++ Library is being used ( RWRWV12STDLIB ) ; or the MSVC version of the Standard C++ Library is being used ( RWMSVCSTDLIB ) . <p> Does the library support multithreading ? <p> Support for multithreading means that the library is " multithread safe . " <p> However , you should be aware that there are two levels of multithread safety : <p> MT-safe : level 1 . At this level , a safe routine , class , or library may be accessed or executed from within a multithreaded application . Safe objects are re-entrant and protect their internal global or static data from corruption by multiple threads . However , a safe object does not necessarily support concurrency . That is , a safe routine , class , or library may require explicit global or local locking and unlocking of objects to achieve some level of concurrency . <p> MT-safe : level 2 . This safety level provides for a reasonable degree of concurrency . That is , explicit locking and unlocking @ @ @ @ @ @ @ @ @ @ several individual operations must be combined and treated as a single atomic operation ( testing for and reading the contents of a queue , for example ) . <p> Rogue Wave 's support for multithreading is generally at level 1 , but check a library 's User 's Guide for details of that library 's multithread support . <p> Command line implications : The use or non-use of multithreading generally affects at least one compiler flag , and may require one or more macros to be declared , particularly if an application depends on Threads.h++ . <p> RWDEBUG activates a set of PRECONDITION and POSTCONDITION clauses at the beginning and end of critical functions . These pre- and post-conditions are implemented with asserts . A failure causes the program to halt after first printing out the offending condition , along with the file and line number where it occurred . <p> Compiler source code debugging <p> A debug build type implies that the compiler 's debug flag has been set . <p> The alternative to a Debug build is called Release , for which neither debugging facility is activated . @ @ @ @ @ @ @ @ @ @ and libraries or applications that depend on Tools.h++ , the RWDEBUG macro is required , and possibly other macros . In all cases , the compiler 's debugging flag must be set . To build a library through Software Parts Manager that activates just one of the debugging facilities , you must customize a Release build type to add either RWDEBUG or the compiler debugging flag . <p> Is the library static or shared ? <p> Command line implications : Static linking is relatively straightforward , requiring only that the required libraries be linked in . ( For DBTools.h++ , this includes an access library object module and library file . ) Shared linking ( also called DLL or dynamic linking ) is more complex . On Unix platforms , the environment must be set to point to the required shared libraries . On Windows , you must set the macro RWDLL , which activates product-specific DLL macros for any Rogue Wave libraries you are using . Also , Windows-specific and sometimes compiler-specific macros are required . 
@@75677832 @4377832/ <h> Overview of a rectangular gauge <p> A rectangular gauge can be horizontal or vertical depending on the value of its direction property It can contain several visual elements , as shown in the illustration above . These elements are laid out according to the value of their area property as shown in the following illustration : <p> The side areas ( top , bottom , left , and right ) are used to place fixed size indicators , such as labels or various indicators about the gauge state . The center of the gauge is used for the core elements , such as the scale or the value renderers . <p> The visual elements of a rectangular gauge extend the RectangularGaugeElement class or one of its subclasses . They are characterized by : <p> An area of reference that can either be top , bottom , left , right , or center <p> A position and a size specified using x , y , width , and height properties , optionally expressed in a percentage of their corresponding area <p> The layout of the visual elements of a @ @ @ @ @ @ @ @ @ @ If the showTitle style property is true , the title is placed at a reserved area at the top or bottom depending on the value of the titlePlacement property . <p> The side areas are sized so that the elements in the left and right , on one hand , and top and bottom , on the other hand , can fit respectively their measured width and height inside these areas . <p> The elements in the side areas are positioned and sized according to the value of their x , y , width , and height properties . Percentage values are relative to the bounds of the corresponding areas computed in step 2 . <p> The remaining area in the center of the gauge is used to lay out the elements in this area . If the gauge has no explicit width , either in pixels or in percentage , the width of the center area will be computed from the measured width of the elements in this area . Similarly , if the gauge has no explicit height , either in pixels or in percentage , the height @ @ @ @ @ @ @ @ @ @ height of the elements in this area . If the gauge has an explicit width ( or height ) , the elements in the center take as much width ( or height ) as is available <p> The background and foreground skins , defined using the backgroundSkin and foregroundSkin properties , if any , are sized so that they cover the whole gauge except the title area . 
@@75677833 @4377833/ <h> 9.3 Objective Chart Wizard <p> In addition to the Chart Editor , the Chart Wizard allows the user to modify chart settings . Chart Wizard allows new components to be added and changed interactively . The results of changes are displayed immediately in a view window . The user can easily experiment with various chart and axis types to determine the best combination for representing his data . <p> The Chart Wizard can help the developer or end user create a chart from scratch or it can reconfigure an existing chart . Figure 123 shows the Chart Layout page of the Wizard , while Figure 124 shows the layout preview window . <p> If the SRGraph object passed to the Wizard has an empty component list , The Wizard displays the Chart Layout page . The user selects a basic chart layout from a number of choices , and the Wizard adds components to the chart accordingly . Then , the user selects an initial graph type for the display . The newly configured chart is displayed in a view window as it will appear in your application @ @ @ @ @ @ @ @ @ @ chart contains some data that it can graph . The Wizard can either copy the data in original SRGraph object or it can use its own arbitrary data set . <p> The Advanced pages can be used to interactively configure a graph . Components can be added or removed from the component list . Multiple SRGraphDisplay , SRGraphTitle , SRGraphBackground , SRGTextPanel , and SRGraphLegend components can be added . The SRGCompoundDisplay component is not supported . <p> The commonly used styles of these components can be modified by the Wizard . The effects of changing a check box status or making a selection from a list box are displayed immediately . Entries into edit boxes are realized when the Apply button is clicked . The Wizard is instructive because it readily shows the effect of the various style settings on the chart . <p> When you are satisfied with the chart , you can then dismiss the Wizard and save your newly enhanced graph . The graph object that the Wizard modifies and displays is actually a copy of your original . No changes you make inside the Wizard @ @ @ @ @ @ @ @ @ @ function of the SRGWizSheet class after you dismiss the Wizard dialog . <p> The data values can be changed by dragging with the mouse . You can determine whether or not the changed data is saved to your graph by specifying a parameter of SaveGraph() . <p> The Chart Wizard is included in the Objective Chart library . The Wizard consists of several classes derived from CPropertyPage and CPropertySheet . It is used just like a dialog or a property sheet class . In most cases , the SRGWizSheet class is the only class you have to work with . <p> Create a menu item with the predefined resource identifier , IDGRAPHWIZARD = 0xd104 . The message map in the view classes connects this command message with the function OnGraphWizard() , which displays the Chart Wizard property sheet . <p> Or , instantiate the SRGWizSheet dialog wherever you like in your application . The code segment below demonstrates how to incorporate the wizard into any Objective Chart application . <p> pParentWnd is a pointer to the parent window of the property sheet , usually NULL . iSelectPage is the index @ @ @ @ @ @ @ @ @ @ 0 . viewSize can be optionally used to set a view area larger than the Wizard 's view window . Then the Use ScrollView check box on the Misc page enables the display of scroll bars for viewing the entire chart . This is useful if the chart uses an absolute ( not percentage ) measurement mode . bUseGraphData specifies whether the data in the chart is to be copied into the Wizard . The default value is TRUE . Specify FALSE if the chart is using Dynamic or Structure data models or to avoid duplicating large amounts of data . If bUseGraphData is FALSE , a default data set is supplied to the Wizard 's internal chart . <p> SRGWizSheet() makes a local copy of the user 's chart . Any changes the user makes are applied to a local copy . The original chart is not affected . The Wizard 's SaveGraph() routine is called to update the original chart when the DoModal() function returns with an IDOK status . The chart 's data values are not affected , unless SaveGraph(TRUE) is called . Of course , if @ @ @ @ @ @ @ @ @ @ can not save the data regardless of its parameter . <p> Because the Chart Wizard makes a copy of the original chart and its components via serialization , the components in the chart returned from the Chart Wizard are different from the originals . Any pointers to the components that you have stored are no longer valid . <p> Data stored using the Dynamic or Structure data storage models can not be copied into the Wizard . If these data models are used , the Wizard must be constructed with bUseGraphData = FALSE and terminated with SaveGraph(FALSE) . A default data set is displayed . <p> The Advanced section of the Wizard consists of four property pages : General setup , Fill style , Font style , and Misc . The first three pages have a combo box that let 's you select a component ( from a list of components in the graph ) for modification . <p> The General setup page let 's you set the measurement mode , component rectangle , border style , and shadow style . Table 19 shows the additional options that can be modified for @ @ @ @ @ @ @ @ @ @ types for representing your data can be quickly determined . <p> Legend style , Key style , Key size , Key first flag , RCLock flag and the number of rows and columns <p> The Fill style page determines how the background of the selected component is filled . You can choose a solid color , a horizontal , vertical or angled vignette ( a gradient of colors across the area ) , or a bitmap image . For vignettes , the starting ( top ) and ending ( bottom ) colors can be selected . Bitmap images can come from the project 's resources or a file on disk . Enter the resource name or file path in the provided edit box . The images can be in bitmap , DIB , or JPEG format . <p> The Font style page determines how text appears in the selected component . <p> If you come up with a chart layout that you would like to reuse , the layout ( component sizes and positions ) can be appended to a text file . Then you can override SRGWizSheet : : @ @ @ @ @ @ @ @ @ @ selection list . <p> If you have created your own graph type or axis type , you can add your custom types to the wizard 's selection lists . You have to override the LoadCustomGraphType()and LoadCustomStandChart() or LoadCustomAxisType() functions of the SRGWizSheet class . 50236 @qwx670236 
@@75677835 @4377835/ <h> Cloud Integration Gateway <p> The proliferation of cloud and SaaS applications has led to an unprecedented rise in the number of applications within the enterprise . As digital business initiatives become a priority , the need for integrated data streams that can be made available to mobile devices , Apps and the Internet of Things has become increasingly critical . Legacy integration infrastructure and ESBs are not equipped to support the scale , message protocols , developer adoption patterns or security standards that are demanded by the digital business . Enterprises that conduct business through digital channels need to put in place a cloud integration gateway that provides an integration-tier that is targeted towards the need of an agile digital business . <h> Integration Redefined <p> Lightweight , quick and configurable drag-and-drop integration for the new digital enterprise designed specifically to accelerate digital business transformation . Integration projects should not be complex , nor require custom code , proprietary adaptors , or intervention by specific application experts . Akana ( formerly SOA Software ) Cloud Integration Gateway let 's you integrate any App , data source , SaaS or @ @ @ @ @ @ @ @ @ @ apps , cloud , Internet of Things or publish it as APIs for developer/partner consumption . <h> Multi-point Integration <p> Akana Cloud Integration Gateway is the only complete solution that delivers API management , integration capabilities , an SOA environment and analytics to meet your current and future business needs . It balances a simplified design with powerful and a modern integration gateway design pattern , which leads to faster implementation of integration projects that are geared towards digital mediums like mobile , the Cloud and Internet of Things . <h> Unlock the Potential of Your Data <p> Transform any application , service , or a combination of them into elegant and simple APIs . Securely share this data with your developer community and business partners and quickly onboard them to help them build upon your data . Drive developer adoption with updated documentation and developer community . Akana Cloud Integration Gateway is designed to help you easily connect with developers , inspire them , and drive your API and data usage . <h> Deploy in the cloud , or on-premises <p> On-Premise or in the Cloud You can choose @ @ @ @ @ @ @ @ @ @ of your business <p> Virtual Appliance Deploy as a pre-packaged hardened virtual appliance on any infrastructure of your choice <h> Orchestration and Process Designer <p> Elegant design : Use the drag-and-drop process designer to configure integration scenarios so they can connect multiple applications and services to meet your specific business needs . <h> Cloud and Mobile Security <p> Security handshakes should be invisible to the user while still protecting corporate data . Akana Cloud Integration Gateway protects enterprise data without compromising the user experience . It supports a wide variety of security standards and protocols like LDAP , SAML , OAuth , and WS-Security , and it provides easy integration with enterprise and cloud Identity and Access Management systems . It enforces security policies and SLAs to ensure that data is exchanged or transferred by only approved applications or individuals . <h> Analytics and Monitoring <p> Your integration infrastructure is the backbone of your digital business . You need visibility into all integration scenarios and identify those that are most profitable , have the potential to be profitable or are bottlenecks to your operations . Akana Cloud Integration Gateway provides @ @ @ @ @ @ @ @ @ @ granular IT control , and the ability to receive alerts so you can troubleshoot issues . Akana analytics dashboards provide visibility into the performance of APIs and services from different perspectives , including those of a department , partner , application contract , and an API/service or operation . <h> Extensible Integration <p> Because your business and its processes are unique , not every integration scenario can be captured by out-of-the-box connectors or templates . Akana Cloud Integration Gateway provides an exclusive server side scripting capability that enables use of common scripting languages such as java script and node.js to define additional integration scenarios . This powerful scripting capability allows for easy and quick changes without the need of re-compiling or re-deploying . <h> Cloud Integration Governance <p> The digital enterprise , by definition , has a huge number of SaaS applications and mobile apps , which mandates that enterprises have several interdependent and dynamic integration scenarios . This calls for positive and agile governance that does not slow down implementation . Rather it requires you to identify and respond to extreme scenarios where integration fails due to changes in @ @ @ @ @ @ @ @ @ @ that opens your corporate data to potential hack and security threats . Akana Cloud Integration Gateway provides agile and positive governance controls to manage both your services dependencies as well as integration of metadata , which ensures that your business is responsive and able to meet the needs of your partners and customers . <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75677836 @4377836/ <h> Hear what our customers say . <p> We work with thousands of customers to help solve their most pressing and complex software challenges . The worlds leading financial institutions , telecommunications providers , manufacturers , defense and aerospace companies , academic organizations , government agencies and energy suppliers use our tools , components and libraries . We make developing code easier and faster . Find out how our customers use Rogue Wave products . <p> " Klocwork is easy to implement and has higher performance . We think Klocwork has the best performance balance . " - Heartland.Data <h> Raytheon : Overcoming Challenges of Legacy Code <p> Offering network solutions for government and defense customers , Raytheon had two challenges : frequent use of legacy code and the unavailability of the original developers meant new developers had to come up to speed quickly ; and the need to run ' what if ' scenarios . 
@@75677837 @4377837/ <h> Members <p> Class RWCTokenizer is designed to break a string up into separate tokens , delimited by an arbitrary white space . Think of it as an iterator for strings and as an alternative to the ANSI C function strtok() which has the unfortunate side effect of changing the tokenized string . <p> #include &lt;iostream&gt; #include &lt;rw/ctoken.h&gt; int main ( ) RWCString a ( " Something is rotten in the state of " " Denmark and Hamlet is taking out the trash . " ) ; RWCTokenizer next(a) ; // Tokenize the string a RWCString token ; // Will receive each token // Advance until the null string is returned : while ( ! ( token=next() ) . isNull() ) std : : cout &lt;&lt; token &lt;&lt; " n " ; <p> Program output : <p> Something is rotten in the state of Denmark and Hamlet is taking out the trash . <p> Advances to the next token and return it as a substring . The tokens are delimited by any of the four characters in " tn0 " ( space , tab , newline and null ) @ @ @ @ @ @ @ @ @ @ <p> Advances to the next token and return it as a substring . The tokens are delimited by any character in s , or any embedded null . <p> RWCSubString operator() ( const char* s , sizet num ) ; <p> Advances to the next token and return it as a substring . The tokens are delimited by any of the first num characters in s . Buffer s may contain nulls , and must contain at least num characters . Tokens will not be delimited by nulls unless s contains nulls . <p> RWCString operator() ( **25;8839;TOOLONG regex ) ; <p> Returns the next token using a delimiter pattern represented by the regular expression pattern regex . <p> This method , unlike the other operator() overloads , allows a single occurrence of a delimiter to span multiple characters . <p> For example , consider the RWCTokenizer instance tok . The statement tok ( RWCString ( " ab " ) ) treats either a or b as a delimiter character . On the other hand , tok ( RWTRegex&lt;char&gt; ( " ab " ) ) treats the two-character pattern , @ @ @ @ @ @ @ @ @ @ consumes consecutive occurrences of delimiters and skips over any empty fields that may be present in the string . To obtain empty fields as well as non-empty fields , use the nextToken() method . <p> Returns true if the last token from the search string has been extracted . If the last token has not been extracted , it will return false . When using the function call operator interface , this is the same as the last non-empty token having been returned . <p> RWCString nextToken() <p> Returns the next token using a default set of delimiter characters . <p> This method may return an empty token if there are consecutive occurrences of any delimiter character in the search string . <p> RWCString nextToken ( const RWCString&amp; str ) <p> Returns the next token using a specified string of delimiter characters . <p> This method may return an empty token if there are consecutive occurrences of any delimiter character in the search string . <p> RWCString nextToken ( const RWCString&amp; str , sizet num ) ; <p> Returns the next token using the first num code units from the @ @ @ @ @ @ @ @ @ @ may return an empty token if there are consecutive occurrences of any delimiter character in the search string . <p> RWCString **33;8866;TOOLONG regex ) ; <p> Returns the next token using a delimiter pattern represented by a regular expression pattern . <p> Unlike the other nextToken() overloads , this method allows a single occurrence of a delimiter to span multiple characters . <p> For example , nextToken ( RWCString ( " ab " ) ) treats either a or b as a delimiter character . Conversely , **30;8901;TOOLONG ( " ab " ) ) treats the two-character pattern ab as a single delimiter . <p> This method may return an empty token if there are consecutive occurrences of any delimiter character in the search string . 
@@75677838 @4377838/ <p> Open source software usage has accelerated over the past decade , and today most enterprises use open source on the desktop as well as in development and critical infrastructure . As open source adoption has increased , so too has the realization that responsible open source usage requires organizations to actively manage it with policies , processes , tool sets , and human resources . Best-in-class enterprises are committed to honoring the terms for all software , whether open source or proprietary , yet also understand that effective management does not require heavy-handed processes . <p> In this webinar Donald D'Angelo , Senior Vice President of Open Source Product Management at Bank of America , outlines the business case for open source software management , and then describes how Bank of America developed its industry-leading open source governance and compliance program . <p> Highlights of Don 's presentation include : <p> Creating an open source policy <p> Open source management <p> Risk acceptance processes <p> Distributing open source <p> Contributing to open source projects <p> Presenter As a senior vice president at Bank of America , Don D'Angelo @ @ @ @ @ @ @ @ @ @ He is leading advocate for the use of risk managed open source to realize cost savings and innovation while helping project teams shorten their release time to market . 
@@75677839 @4377839/ <p> Class RWBitVec is a bitvector whose length can be changed at run time . Because this requires an extra level of indirection , this makes it slightly less efficient than classes RWGBitVec(size) or RWTBitVec&lt;size&gt; , whose lengths are fixed at compile time . <p> Construct a vector with N bits . The initial value of the bits is undefined . <p> RWBitVec ( sizet N , RWBoolean initVal ) ; <p> Construct a vector with N bits , each set to the Boolean value initVal . <p> RWBitVec ( const RWByte* bp , sizet N ) ; <p> Construct a vector with N bits , initialized to the data in the array of bytes pointed to by bp . This array must be at least long enough to contain N bits . The identifier RWByte is a typedef for an unsigned char . <p> RWBitVec ( const RWBitVec&amp; v ) ; <p> Copy constructor . Uses value semantics -- the constructed vector will be a copy of v. <p> Logical assignments . Set each element of self to the logical AND , XOR , or OR , respectively @ @ @ @ @ @ @ @ @ @ and v must have the same number of elements ( i.e. , be conformal ) or an exception of type RWInternalErr will occur . <p> Returns a reference to bit i of self . A helper class , RWBitRef , is used . The result can be used as an lvalue . The index i must be between 0 and the length of the vector less one . Bounds checking is performed . If the index is out of range , then an exception of type RWBoundsErr will occur . <p> RWBitRef operator() ( sizet i ) ; <p> Returns a reference to bit i of self . A helper class , RWBitRef , is used . The result can be used as an lvalue . The index i must be between 0 and the length of the vector less one . Bounds checking is performed only if the preprocessor macro RWBOUNDSCHECK has been defined before including the header file &lt;rw/bitvec.h&gt; . If so , and if the index is out of range , then an exception of type RWBoundsErr will occur . <p> RWBoolean operator ( sizet i ) @ @ @ @ @ @ @ @ @ @ . The result can not be used as an lvalue . The index i must be between 0 and the length of the vector less one . Bounds checking is performed . If the index is out of range , then an exception of type RWBoundsErr will occur . <p> RWBoolean operator() ( sizet i ) const ; <p> Returns the boolean value of bit i . The result can not be used as an lvalue . The index i must be between 0 and the length of the vector less one . Bounds checking is performed only if the preprocessor macro RWBOUNDSCHECK has been defined before including the header file &lt;rw/bitvec.h&gt; . If so , and if the index is out of range , then an exception of type RWBoundsErr will occur . <p> Clears ( i.e. , sets to FALSE ) the bit with index i . The index i must be between 0 and the length of the vector less one . No bounds checking is performed . The following are equivalent , although clearBit(sizet) is slightly smaller and faster than using operator() ( sizet ) : @ @ @ @ @ @ @ @ @ @ data() const ; <p> Returns a const pointer to the raw data of self . Should be used with care . <p> sizet firstFalse() const ; <p> Returns the index of the first FALSE bit in self . Returns RWNPOS if there is no FALSE bit . <p> sizet firstTrue() const ; <p> Returns the index of the first TRUE bit in self . Returns RWNPOS if there is no TRUE bit . <p> unsigned hash() const ; <p> Returns a value suitable for hashing . <p> RWBoolean isEqual ( const RWBitVec&amp; v ) const ; <p> Returns TRUE if self and v have the same length and if each bit of self is set to the same value as the corresponding bit in v. Otherwise , returns FALSE . <p> sizet length() const ; <p> Returns the number of bits in the vector . <p> ostream&amp; printOn ( ostream&amp; s ) const ; <p> Print the vector v on the output stream s . See the example above for a sample of the format . <p> void resize ( sizet N ) ; <p> Resizes the vector to have @ @ @ @ @ @ @ @ @ @ vector , the additional bits will be set to FALSE . <p> istream&amp; scanFrom(istream&amp;) ; <p> Read the bit vector from the input stream s . The vector will dynamically be resized as necessary . The vector should be in the same format printed by member function printOn(ostream&amp;) . <p> void setBit ( sizet i ) ; <p> Sets ( i.e. , sets to TRUE ) the bit with index i . The index i must be between 0 and size-1 . No bounds checking is performed . The following are equivalent , although setBit(sizet) is slightly smaller and faster than using operator() ( sizet ) : <p> a(i) = TRUE ; a.setBit(i) ; <p> RWBoolean testBit ( sizet i ) const ; <p> Tests the bit with index i . The index i must be between 0 and size-1 . No bounds checking is performed . The following are equivalent , although testBit(sizet) is slightly smaller and faster than using operator() ( sizet ) : 
@@75677841 @4377841/ <p> This class maintains a collection of values , implemented as a singly-linked list . This is a value based list : objects are copied in and out of the links that make up the list . Unlike intrusive lists ( see class RWTIsvSlist&lt;T&gt; ) the objects need not inherit from a link class . However , this makes the class slightly less efficient than the intrusive lists because of the need to allocate a new link off the heap with every insertion and to make a copy of the object in the newly allocated link . <p> Parameter T represents the type of object to be inserted into the list , either a class or fundamental type . The class T must have : <p> Sets self to a copy of the list list . Depending on the nature of the copy constructor of T , this could be relatively expensive because every item in the list must be copied . <p> T&amp; operator ( sizet i ) ; <p> Returns a reference to the item at index i . The results can be used as an lvalue @ @ @ @ @ @ @ @ @ @ i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> const T&amp; operator ( sizet i ) const ; <p> Returns a copy of the item at index i . The results can not be used as an lvalue . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> Applies the user-defined function pointed to by applyFun to every item in the list . This function must have prototype : <p> void yourFun ( T&amp; a , void* d ) ; <p> Client data may be passed through as parameter d . <p> T&amp; at ( sizet i ) ; <p> Returns a reference to the item at index i . The results can be used as an lvalue . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . @ @ @ @ @ @ @ @ @ @ <p> Returns a copy of the item at index i . The results can not be used as an lvalue . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> void clear() ; <p> Removes all items from the list . Their destructors , if any , will be called . <p> RWBoolean contains ( const T&amp; a ) const ; <p> Returns TRUE if the list contains an object that is equal to the object a . Returns FALSE otherwise . Equality is measured by the class-defined equality operator . <p> Returns TRUE if the list contains an item for which the user-defined " tester " function pointed to by testFun returns TRUE . Returns FALSE otherwise . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> For each item in the list this function will be called with the item as the first argument . Client data may be passed through as parameter @ @ @ @ @ @ @ @ @ @ number of items that are currently in the collection . <p> RWBoolean find ( const T&amp; target , T&amp; k ) const ; <p> Returns TRUE if the list contains an object that is equal to the object target and puts a copy of the matching object into k . Returns FALSE otherwise and does not touch k . Equality is measured by the class-defined equality operator . If you do not need a copy of the found object , use contains() instead . <p> Returns TRUE if the list contains an object for which the user-defined tester function pointed to by testFun returns TRUE and puts a copy of the matching object into k . Returns FALSE otherwise and does not touch k . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> For each item in the list this function will be called with the item as the first argument . Client data may be passed through as parameter d . If you do not need a copy of the found object , use contains() instead . @ @ @ @ @ @ @ @ @ @ Returns but does not remove the first item in the list . The behavior is undefined if the list is empty . <p> T get() ; <p> Returns and removes the first item in the list . The behavior is undefined if the list is empty . <p> sizet index ( const T&amp; a ) ; <p> Returns the index of the first object that is equal to the object a , or RWNPOS if there is no such object . Equality is measured by the class-defined equality operator . <p> sizet index ( RWBoolean ( *testFun ) ( const T&amp; , void* ) , void* d ) const ; <p> Returns the index of the first object for which the user-defined tester function pointed to by testFun returns TRUE , or RWNPOS if there is no such object . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> For each item in the list this function will be called with the item as the first argument . Client data may be passed through as parameter d . <p> @ @ @ @ @ @ @ @ @ @ the item a to the end of the list . <p> void insertAt ( sizet i , const T&amp; a ) ; <p> Insert the item a at the index position i . This position must be between zero and the number of items in the list , or an exception of type RWBoundsErr will be thrown . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in the list , FALSE otherwise . <p> T&amp; last() ; const T&amp; last() const ; <p> Returns but does not remove the last item in the list . The behavior is undefined if the list is empty . <p> sizet occurrencesOf ( const T&amp; a ) const ; <p> Returns the number of objects in the list that are equal to the object a . Equality is measured by the class-defined equality operator . <p> Returns the number of objects in the list for which the user-defined " tester " function pointed to by testFun returns TRUE . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> @ @ @ @ @ @ @ @ @ @ called with the item as the first argument . Client data may be passed through as parameter d . <p> void prepend ( const T&amp; a ) ; <p> Adds the item a to the beginning of the list . <p> RWBoolean remove ( const T&amp; a ) ; <p> Removes the first object which is equal to the object a and returns TRUE . Returns FALSE if there is no such object . Equality is measured by the class-defined equality operator . <p> RWBoolean remove ( RWBoolean ( *testFun ) ( const T&amp; , void* ) , void* d ) ; <p> Removes the first object for which the user-defined tester function pointed to by testFun returns TRUE , and returns TRUE . Returns FALSE if there is no such object . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> For each item in the list this function will be called with the item as the first argument . Client data may be passed through as parameter d . <p> sizet removeAll ( const T&amp; a ) @ @ @ @ @ @ @ @ @ @ object a . Returns the number of objects removed . Equality is measured by the class-defined equality operator . <p> sizet removeAll ( RWBoolean ( *testFun ) ( const T&amp; , void* ) , void* d ) ; <p> Removes all objects for which the user-defined tester function pointed to by testFun returns TRUE . Returns the number of objects removed . The tester function must have the prototype : <p> RWBoolean yourTester ( const T&amp; , void* d ) ; <p> For each item in the list this function will be called with the item as the first argument . Client data may be passed through as parameter d . <p> T removeAt ( sizet i ) ; <p> Removes and returns the object at index i . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> T removeFirst() ; <p> Removes and returns the first item in the list . The behavior is undefined if the list is empty . <p> T removeLast() ; @ @ @ @ @ @ @ @ @ @ . The behavior is undefined if the list is empty . This function is relatively slow because removing the last link in a singly-linked list necessitates access to the next-to-the-last link , requiring the whole list to be searched . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677842 @4377842/ <p> A user-supplied hashing function for type K must be supplied to the constructor when creating a new table . If K is a Rogue Wave class , then this requirement is usually trivial because most Rogue Wave objects know how to return a hashing value . In fact , classes RWCString , RWDate , RWTime , and RWWString contain static member functions called hash that can be supplied to the constructor as is . The function must have prototype : <p> unsigned hFun ( const K&amp; a ) ; <p> and should return a suitable hash value for the object a . <p> To find a value , the key is first hashed to determine in which bucket the key and value can be found . The bucket is then searched for an object that is equal ( as determined by the equality operator ) to the key . <p> The initial number of buckets in the table is set by the constructor . There is a default value . If the number of ( key/value ) pairs in the collection greatly exceeds the number of buckets then @ @ @ @ @ @ @ @ @ @ . The number of buckets can be changed by calling member function resize() . This is an expensive proposition because not only must all the items be copied into the new buckets , but all of the keys must be rehashed . <p> If you wish this to be done automatically , then you can subclass from this class and implement your own special insert() and remove() functions which perform a resize() as necessary . <p> Constructs a new hash dictionary . The first argument is a pointer to a user-defined hashing function for items of type K ( the key ) . The table will initally have buckets buckets although this can be changed with member function resize() . <p> **25;8933;TOOLONG , V&gt; ( const **25;8960;TOOLONG , V&gt;&amp; dict ) ; <p> Copy constructor . Constructs a new hash dictionary as a copy of dict . The new dictionary will have the same number of buckets as the old table . Hence , although the keys and values must be copied into the new table , the keys will not be rehashed . <p> Sets self to a copy @ @ @ @ @ @ @ @ @ @ the same number of buckets as the old table . Hence , although the keys and values must be copied into the new table , the keys will not be rehashed . <p> V&amp; operator ( const K&amp; key ) ; <p> Look up the key key and return its associated value as an lvalue reference . If the key is not in the dictionary , then it is added to the dictionary . In this case , the value associated with the key will be provided by the default constructor for objects of type V. <p> Applies the user-defined function pointed to by applyFun to every key-value pair in the dictionary . This function must have prototype : <p> void yourFun ( const K&amp; key , V&amp; value , void* d ) ; <p> The key will be passed by constant reference and hence can not be changed . The value will be passed by reference and can be modified . Client data may be passed through as parameter d . <p> void clear() ; <p> Removes all items from the collection . <p> RWBoolean contains ( const K&amp; @ @ @ @ @ @ @ @ @ @ contains a key which is equal to key . Returns FALSE otherwise . Equality is measured by the class-defined equality operator for class K. <p> sizet entries() const ; <p> Returns the number of key-value pairs currently in the dictionary . <p> RWBoolean find ( const K&amp; target , K&amp; retKey ) const ; <p> Returns TRUE if the dictionary contains a key which is equal to target and puts the matching key into retKey . Returns FALSE otherwise and leaves retKey untouched . Equality is measured by the class-defined equality operator for class K. <p> RWBoolean findValue ( const K&amp; key , V&amp; retVal ) const ; <p> Returns TRUE if the dictionary contains a key which is equal to key and puts the associated value into retVal . Returns FALSE otherwise and leaves retVal untouched . Equality is measured by the class-defined equality operator for class K. <p> RWBoolean findKeyAndValue ( const K&amp; key , K&amp; retKey , V&amp; retVal ) const ; <p> Returns TRUE if the dictionary contains a key which is equal to key and puts the matching key into retKey and the associated value @ @ @ @ @ @ @ @ @ @ retVal untouched . Equality is measured by the class-defined equality operator for class K. <p> void insertKeyAndValue ( const K&amp; key , const V&amp; value ) ; <p> Inserts the key key and value value into the dictionary . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if the dictionary has no items in it , FALSE otherwise . <p> RWBoolean remove ( const K&amp; key ) ; <p> Returns TRUE and removes the ( key/value ) pair where the key is equal to the key . Returns FALSE if there is no such key . Equality is measured by the class-defined equality operator for class K. <p> void resize ( sizet N ) ; <p> Changes the number of buckets to N , a relatively expensive operation if there are many items in the collection . 
@@75677844 @4377844/ <p> Returns a pointer to the collection over which this iterator is iterating . <p> T* findNext ( const T* a ) ; <p> Advances the iterator to the first element that is equal to the object pointed to by a and returns a pointer to it . If no item is found , returns nil and the position of the iterator will be undefined . Equality is measured by the class-defined equality operator for type T. <p> T* findNext ( RWBoolean ( *testFun ) ( T* , void* ) , void* ) ; <p> Advances the iterator to the first element for which the tester function pointed to by testFun returns TRUE and returns a pointer to it . If no item is found , returns nil and the position of the iterator will be undefined . <p> void insertAfterPoint ( T* a ) ; <p> Inserts the object pointed to by a into the iterator 's associated collection in the position immediately after the iterator 's current position which remains unchanged . <p> T* key() const ; <p> Returns a pointer to the object at the iterator @ @ @ @ @ @ @ @ @ @ iterator is no longer valid . <p> T* remove() ; <p> Removes and returns the object at the iterator 's current position from the iterator 's associated collection . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . If the first element of the iterator 's associated collection is removed , then the position of the iterator will be undefined . <p> T* removeNext ( const T* a ) ; <p> Advances the iterator to the first element that is equal to the object pointed to by a , then removes and returns it . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . Equality is measured by the class-defined equality operator for type T. <p> T* removeNext ( RWBoolean ( *testFun ) ( T* , void* ) , void* ) ; <p> Advances the iterator to the first element for which the tester function pointed @ @ @ @ @ @ @ @ @ @ it . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . <p> void reset() ; <p> Resets the iterator to the state it had immediately after construction . 
@@75677848 @4377848/ <h> 10.1 Using the MIME Headers Effectively <p> This section presents each of the MIME headers supported by the MIME package with a focus on using the headers effectively . The section provides background reading and a quick reference rather than task lists or a complete specification of the headers . For step-by-step instructions , see Chapter 9 , " Using the MIME Package , " For the complete details on a specific header , see the RFC that defines the header . <p> The key to using MIME headers effectively is understanding how the headers describe the content of the body . Example 32 shows a simple MIME message containing nine headers and a part body that consists of a single line of data . <p> Each header contains a label , such as MIME-Version , and a value , such as 1.0 . The first five header fields are specified by MIME in RFC 2045 . The Content-Location header is specified in RFC 2557 , and the Content-Disposition header is specified in RFC 1806 . Each header in this example message is discussed in more detail below @ @ @ @ @ @ @ @ @ @ information on the version of the MIME format that the message follows . The name of this header is -MIME-Version . The value of the header indicates the revision of the MIME specification the message follows . The MIME package supports MIME version 1.0 , so the value of this header in Example 32 is 1.0 . Although the MIME package allows any version value , the only value defined by the MIME specifications is 1.0 . <p> The header is only required for a top-level MIME message . Nested parts within a multipart message need not include the MIME-Version header . <p> The Content-Type header declares the original file format of the part body . In Example 32 , the Content-Type header contains the value text/plain and one parameter , charset=us-ascii . <p> A Content-Type header contains two values separated by a slash . These values are the media type and subtype of the Content-Type . In Example 32 , the media type is text and the subtype is plain . <p> The media type specifies the kind of content in broad terms , while the subtype is more @ @ @ @ @ @ @ @ @ @ common subtypes such as plain , html , and xml . In all three cases , the basic format of the document is text , and the document can be considered text for many purposes , such as deciding whether the document can be usefully opened within a text editor . The subtype provides more detailed information about the content . Although an HTML document can be displayed as plain text , rendering the document in a browser or opening the document in an HTML editor may be more useful . <p> The two-part value gives applications a way to determine the preferred handling of a document . If the application recognizes both the media type and subtype , the application can handle the content in exactly the way the sender intended . If the application only recognizes the media type , the application can still provide a reasonable fallback . <p> Depending on the media type or subtype , a Content-Type may require a parameter . For example , MIME allows text content types to include a parameter specifying the character set . The Content-Type header in Example 32 @ @ @ @ @ @ @ @ @ @ types for discrete content : text , image , audio , video , and application . The message media type is defined for MIME parts that contain complete messages as content , such as an email digest . <p> For messages containing more than one MIME part , the format defines a media type of multipart . The requirements of the multipart content type are intimately connected with the body of the message . Section 10.2.2 , " Multipart Bodies , " discusses -multipart message bodies and content types . <p> A Content-Type header is optional . The MIME specification defines a part without a Content-Type header as text/plain ; charset=us-ascii . <p> Each MIME part may contain a header that specifies whether the part was processed for transfer and how the body of the message part is currently represented . The field name of this header is **25;8987;TOOLONG . In Example 32 , the **25;9014;TOOLONG header contains the value 7bit . <p> The MIME specification defines five distinct transfer encodings . Two of these encodings , base64 and quoted-printable , indicate that the part body was processed for transmission @ @ @ @ @ @ @ @ @ @ remaining three encodings , 7bit , 8bit , and binary , indicate that the body has not been processed for transmission , and that the message is currently represented as either 7-bit ASCII , 8-bit ASCII , or as raw binary data . MIME also allows applications to define and use nonstandard values for the **25;9041;TOOLONG of a message . <p> The body of a part defined with a given transfer encoding must actually match the format declared . A MIME part that contains other MIME parts may only have an encoding of 7bit , 8bit , or binary . Table 1 summarizes the transfer encodings defined by the MIME specification and the body format that each encoding specifies . <h> Table 1 : MIME **25;9068;TOOLONG values <p> Field Value <p> Character Set <p> Body format <p> base64 <p> 7-bit ASCII <p> Encoded into 7-bit ASCII . Lines typically less than 78 characters . CRLF sequence only occurs as a line break . <p> q-uoted-printable <p> 7-bit ASCII <p> Encoded into 7-bit ASCII . Lines typically less than 78 characters . CRLF sequence only occurs as a line break . @ @ @ @ @ @ @ @ @ @ Lines no longer than 998 characters . CRLF sequence only occurs as a line break . <p> 8bit <p> 8-bit ASCII <p> Unencoded 8-bit ASCII . Lines no longer than 998 characters . CRLF sequence only occurs as a line break <p> binary <p> No restrictions <p> Any data acceptable . CRLF may or may not indicate a line break . <p> If a MIME part is 7bit , the **25;9095;TOOLONG header is optional . MIME parts with any other transfer encoding must contain a **25;9122;TOOLONG header . If the MIME part is a multipart content type , the part should not have an encoding of base64 or quoted-printable . <p> The Content-ID header associates a unique I 'd with a MIME part . In Example 32 , the Content-ID header contains the value **35;9149;TOOLONG . A Content-ID header is designed to allow external references to a given MIME part . Therefore , the Content-ID provided must be world-unique . <p> The value of a Content-ID header has the format &lt;xxxx@yyyy&gt; . A MIME application typically creates a world-unique value by setting the right side of the value to indicate the @ @ @ @ @ @ @ @ @ @ of the value generally contains a serial number , an indication of the date and time the message was generated , or both . Most applications use a combination of letters , numbers , and common punctuation ( typically , period and hyphen ) for the values of xxxx and yyyy , even though the specification technically allows a slightly larger character set . <p> Most MIME messages contain a single Content-ID header , at the top level of the message . If the Content-Type of the part is m-ultipart/alternative , the MIME specification recommends that each contained part have a unique Content-ID unless each part contains exactly the same information ( see RFC 2046 for complete details ) . <p> The Content-Description header briefly describes the body the part contains . In Example 32 , the Content-Description header contains the value very simple MIME message . This header is only a human-readable description , and does not otherwise affect the structure or content of the part . <p> The Content-Location header associates a URI with the part . In Example 32 , the Content-Location header contains the value http @ @ @ @ @ @ @ @ @ @ the part using the value of the Content-Location header . The URI in the header is only used by other parts within the same message . Therefore , the URI need not be world-unique or indicate an actual resource on the Internet . <p> The Content-Disposition header indicates how an application should present the body . A value of inline indicates that the part body should be presented as part of the message . A value of attachment indicates that the part body should be presented as an attached file . In Example 32 , the Content-Disposition header contains the value inline . The body should be presented as part of the message . <p> The headers end at the first blank line in the part . Everything after the first blank line in the part is content of the message , which the MIME specification refers to as the message body or part body . 50235 @qwx670235 
@@75677850 @4377850/ <p> IlvJComponentGraphic is used to add Swing JComponent objects to an IlvManager instance . <h> Overview <p> Instances of JComponent and its subcomponents are modified to remove their Swing double-buffering when the IlvJComponentGraphic holding them is added to an IlvManager . Each JComponent in an IlvJComponentGraphic is displayed in all IlvManagerView instances associated with its manager . The current transformation is correctly applied to all objects . <p> Note : use IlvComponentGraphic and not IlvJComponentGraphic to add AWT components to your custom application . <h> Example <p> The following code example shows how to use an IlvJComponentGraphic to include a Swing component in a simple Java application : <p> An instance of JComponent can be embedded into several instances of IlvJComponentGraphic but can not be added to both an IlvJComponentGraphic and a regular Swing container such as JFrame . <p> An instance of JComboBox can be embedded into only one instance of IlvJComponentGraphic . <p> The mechanism is designed for embedding simple Swing components ( such as a button , a checkbox , or a text field ) into a manager . Embedding complex panels with many interactive subelements @ @ @ @ @ @ @ @ @ @ may not work . <p> When more than one view is attached to a manager , JComponent objects can be fully functional only in the first manager view attached to the manager if the views do not share the same top level window of frame . This is a limitation of the Microsoft user interface ; other user interfaces do not have this limitation . <p> Adding to a manager a large number of IlvJComponentGraphic embedded complex Swing components can affect performances . <h> About Graphic Objects <p> IlvJComponentGraphic is a custom graphic object , that is , a subclass of IlvGraphic . Graphic objects are controlled using an IlvManager instance and displayed using one or more IlvManagerView instances in a Java Swing application . For information about generic features for graphic objects , see IlvGraphic . <h> Field Detail <h> RESIZECOMPONENTNEVER <p> public static final int RESIZECOMPONENTNEVER <p> The component-resizing mode that specifies that the encapsulated JComponent is not resized , except during this class constructor and during the **36;9218;TOOLONG method . When the IlvJComponentGraphic object is subsequently resized or shown in a magnifying view , it will be @ @ @ @ @ @ @ @ @ @ final int RESIZECOMPONENTONRESHAPE <p> The component-resizing mode that specifies that the encapsulated JComponent is resized every time this graphic object is reshaped or resized . Still , when the IlvJComponentGraphic object is subsequently shown in a magnifying view , it will be rendered through proportional zoom . <h> RESIZECOMPONENTONZOOM <p> public static final int RESIZECOMPONENTONZOOM <p> The component-resizing mode that specifies that the encapsulated JComponent is resized during the drawing , according to the zoom level . In this mode , proportional zoom is not normally used for rendering the component ( except during printing ) . <h> getComboBoxOptions <p> Returns the additional options to configure the combo box component . This assumes that the Swing component handled by this graphic object is a JComboBox . Returns null if the Swing component is not a combo box . <p> Since : <p> JViews 8.0 <h> setZoomLimit <p> public void setZoomLimit ( double limit ) <p> Specifies the zoom factor limit . When the zoom factor applied to the initial JComponent is less than this value , the IlvJComponentGraphic is displayed as a filled rectangle . The default value is 0.1. @ @ @ @ @ @ @ @ @ @ <p> Determines when the encapsulated JComponent is resized . If resizeComponentMode is RESIZECOMPONENTNEVER , a proportional zoom will be used for drawing the component in all cases . If resizeComponentMode is RESIZECOMPONENTONRESHAPE , proportional zoom will be used only on behalf of a magnifying view or for printing . If resizeComponentMode is RESIZECOMPONENTONZOOM , proportional zoom will normally not be used . <h> getResizeComponentMode <h> setActive <p> public void setActive ( boolean active ) <p> Sets whether the JComponent is active . An active component receives events and can react on interaction . An inactive component does not receive any events , regardless whether it is enabled or not . It is only displayed . <p> For some Swing components , it is useful to make them inactive while they are moved by the select interactor. 
@@75677853 @4377853/ <h> 4.4 Mixed-Currency Calculations <p> It is very possible that your applications will need to add money values of different currencies . The Currency Module provides a money calculator class in the class **26;9284;TOOLONG . <p> Before you can use a money calculator class , you must consider and possibly set two policies . The first is the conversion policy , which determines what currency will be used for the result of a mixed-currency calculation . The second is the rounding policy , which determines how the money calculator should round decimal places . <p> Whenever your application performs arithmetic operations involving two or more different currencies , one or more currency conversions must take place . A conversion policy determines how the money calculator will express the result of its calculation . <p> There are four conversion policies available to the money calculator class : <p> No Conversion . An operations performed on monies of different currencies throws an exception . <p> Base Currency Conversion . When arithmetic operations are performed on monies of different currencies , both operands are converted to a base currency . After performing @ @ @ @ @ @ @ @ @ @ the base currency . <p> Target Currency Conversion . When arithmetic operations are performed on monies of different currencies , the source operand ( first argument ) is converted to the target operand ( second argument ) currency . After performing the calculation , the money calculator returns the result in the target currency . <p> Source Currency Conversion . When arithmetic operations are performed on monies of different currencies , the target operand ( second argument ) is converted to the source operand ( first argument ) currency . After performing the calculation , the money calculator returns the result in the source currency . <p> A money calculator object 's currency conversion type can be set at construction . It can also be set or changed using the setConversionType() member function . <p> In addition to setting the conversion type , you must also associate an RWExchangeFactory object with the calculator object . The RWExchangeFactory provides the exchange rate table that is used to perform the conversion . For more information on exchange rates and exchange rate tables , see Section 5.2 , " Exchange Rates and Exchange @ @ @ @ @ @ @ @ @ @ construct an **26;9312;TOOLONG and some money objects , then perform mixed-currency calculations : <p> In addition to setting the conversion policy , you must set a rounding policy and a precision for the calculator . The precision specifies how many digits to the right of the decimal points should be reported . <p> You can also set a comparison digit that let 's you control when rounding up or down occurs . The comparison digit works only with plain or bankers rounding . As described below , the plain and bankers rounding methods always compare the digit to the right of the precision position to the comparison digit and then increment the digit in the precision position , or leave it as is , based on the comparison . The default comparison digit is 5 . <p> Rounding a negative number is equivalent to rounding the absolute value of the negative number , then multiplying the result by negative one . <p> Round up . If the digits the right of the specified precision decimal place are non-zero , add one to the digit at the specified precision decimal place , @ @ @ @ @ @ @ @ @ @ down . Truncate all digits to the right of the specified precision decimal place . <p> Plain . If the digit one to the right of the specified precision decimal place is greater than a comparison digit , increase the digit at the precision position by one and truncate all numbers to the right . Otherwise , truncate all digits to the right of the precision position . For example , if the precision is 1 and the comparison digit is 5 , then 2.35 and 2.35001 both round to 2.3 , and 2.37 rounds to 2.4 . If you set the comparison digit to 3 , however , 2.35 , 2.35001 and 2.37 all round to 2.4 . <p> Bankers . Bankers rounding is the same as plain rounding except that in the case of a tie , increment the digit at the specified precision position if necessary to make it an even number . A tie occurs when the digit to the right of the specified precision position equals the comparison digit , and there are no following non-zero digits . For example , when rounding to one @ @ @ @ @ @ @ @ @ @ the number 2.45 represents a tie . It rounds to 2.4 , because the 4 at the precision position is an even number . 2.45000 is also a tie and also rounds to 2.4 . However , 2.45001 is not a tie , so it rounds to 2.5 based on the rules for plain rounding . <p> Do n't round . No rounding will occur , and precision is ignored . <p> Table 3 shows the effects of the rounding policies : <h> Table 3 : Methods of rounding <p> Method <p> 1.245 <p> 1.25 <p> 1.251 <p> 1.255 <p> 1.259 <p> -1.259 <p> 1.26500 <p> 1.26501 <p> UPprecision = 2 <p> 1.25 <p> 1.25 <p> 1.26 <p> 1.26 <p> 1.26 <p> -1.26 <p> 1.27 <p> 1.27 <p> DOWNprecision = 2 <p> 1.24 <p> 1.25 <p> 1.25 <p> 1.25 <p> 1.25 <p> -1.25 <p> 1.26 <p> 1.26 <p> PLAINprecision = 2comparison = 5 <p> 1.24 <p> 1.25 <p> 1.25 <p> 1.25 <p> 1.26 <p> -1.26 <p> 1.26 <p> 1.26 <p> BANKERSprecision = 2comparison = 5 <p> 1.24 <p> 1.25 <p> 1.25 <p> 1.26 <p> 1.26 <p> -1.26 <p> 1.26 <p> @ @ @ @ @ @ @ @ @ @ <p> 1.255 <p> 1.259 <p> -1.259 <p> 1.26500 <p> 1.26501 <p> The default constructor for an RWMoneyCalculator creates a money calculator without a rounding method or a currency conversion policy . For other constructors , the default rounding method is noRounding , the default precision is 2 , and the default comparison digit is 5 . RWMoneyCalculator provides member functions setAccuracy() , setRoundDigit() , and setRoundMethod() to set the precision , comparison digit , and rounding method for the object . 50235 @qwx670235 
@@75677855 @4377855/ <h> Friends 50231 @qwx670231 <p> Gadget class . <p> Library : ilvadvgdt <p> This class is a subclass of IlvComboBox that combines a text field ( IlvTextField class ) with a scrollable string list . The user can enter a character string in the combo box text field , or click on the arrow that appears on the right side of the field to display a string list of the class IlvStringList providing a set of predefined choices . <p> Initializes a new instance of the class IlvScrolledComboBox . The size of the combo box is computed from the label parameter . If you want to give the combo box a specific size , use the other constructor . <p> By default , the string list of the scrolled combo box has the same width as the text field . If the string list contains items that are wider than the text field , these may be hidden partially . When the large list mode is enabled , the string list is resized to accommodate the widest item . 50234 @qwx670234 <p> alignment <p> The alignment of the string list . Valid values are : IlvLeft and IlvRight. 
@@75677856 @4377856/ <p> Specifies an alternative source of Rogue Wave Views data defining the user interface of this dialog . This data can be stored in a file , in which case fileordata represents the name of the file , or in a C++ string , in which case fileordata stands for the string itself . If fileordata is not specified , the default dialog is used . <p> type <p> The type of the dialog . For details , see IlvIDialogType . <p> transientFor <p> The system view for which the dialog is transient . For details , see the IlvView constructors . <p> Specifies an alternative source of Rogue Wave Views data defining the user interface of this dialog . This data can be stored in a file , in which case fileordata represents the name of the file , or in a C++ string , in which case fileordata stands for the string itself . If fileordata is not specified , the default dialog is used . <p> type <p> The type of the dialog . For details , see IlvIDialogType . <p> transientFor <p> The system view @ @ @ @ @ @ @ @ @ @ see the IlvView constructors . 
@@75677859 @4377859/ <h> The Priority Queue Operations <p> A priority queue is a data structure that can hold elements of type T and that implements the following five operations : <p> push(T) <p> add a new value to the collection being maintained <p> top() <p> return a reference to the smallest element in collection <p> pop() <p> delete the smallest element from the collection <p> size() <p> return the number of elements in the collection <p> empty() <p> return true if the collection is empty <p> Elements of type T must be comparable to each other , either through the use of the default less than operator ( the &lt; operator ) , or through a comparison function passed either as a template argument or as an optional argument on the constructor . The latter form will be illustrated in the example program provided later in this section . As with all the containers in the Standard Library , there are two constructors . The default constructor requires either no arguments or the optional comparison function . An alternative constructor takes an iterator pair , and initializes the values in the @ @ @ @ @ @ @ @ @ @ optional third argument can be used to define the comparison function . <p> The priority queue data type is built on top of a container class , which is the structure actually used to maintain the values in the collection . There are two containers in the standard library that can be used to construct priority queues : vectors or deques . <p> Queues constructed out of vectors tend to be somewhat smaller , while queues constructed out of deques can be somewhat faster , particularly if the number of elements in the queue varies widely over the course of execution . However , these differences are slight , and either form will generally work in most circumstances . <p> Because the priority queue data structure does not itself know how to construct iterators , very few of the algorithms noted in Chapter 13 can be used with priority queues . Instead of iterating over values , a typical algorithm that uses a priority queue constructs a loop , which repeatedly pulls values from the structure ( using the top() and pop() operations ) until the collection becomes empty ( @ @ @ @ @ @ @ @ @ @ described in the next section will illustrate this use . <p> Priority queues are implemented by internally building a data structure called a heap . Abstractly , a heap is a binary tree in which every node possesses the property that the value associated with the node is smaller than or equal to the value associated with either child node . 
@@75677861 @4377861/ <h> 3.6. - Prefetching <p> Even programs with good data locality will now and then have to access a cache line that is not in the cache , and will then stall until the data has been fetched from main memory . It would of course be better if there was a way to load the data into the cache before it is needed so the stall could be avoided . This is called prefetching and there are two ways to achieve it , software prefetching and hardware prefetching. <h> 3.6.1. - Software Prefetching <p> With software prefetching the programmer or compiler inserts prefetch instructions into the program . These are instructions that initiate a load of a cache line into the cache , but do not stall waiting for the data to arrive . <p> A critical property of prefetch instructions is the time from when the prefetch is executed to when the data is used . If the prefetch is too close to the instruction using the prefetched data , the cache line will not have had time to arrive from main memory or the next cache @ @ @ @ @ @ @ @ @ @ effectiveness of the prefetch . <p> If the prefetch is too far ahead of the instruction using the prefetched data , the prefetched cache line will instead already have been evicted again before the data is actually used . The instruction using the data will then cause another fetch of the cache line and have to stall . This not only eliminates the benefit of the prefetch instruction , but introduces additional costs since the cache line is now fetched twice from main memory or the next cache level . This increases the memory bandwidth requirement of the program . <p> Processors that have multiple levels of caches often have different prefetch instructions for prefetching data into different cache levels . This can be used , for example , to prefetch data from main memory to the L2 cache far ahead of the use with an L2 prefetch instruction , and then prefetch data from the L2 cache to the L1 cache just before the use with a L1 prefetch instruction . <p> There is a cost for executing a prefetch instruction . The instruction has to be decoded and @ @ @ @ @ @ @ @ @ @ always prefetches cache lines that are already in the cache will consume execution resources without providing any benefit . It is therefore important to verify that prefetch instructions really prefetch data that is not already in the cache . <p> The cache miss ratio needed by a prefetch instruction to be useful depends on its purpose . A prefetch instruction that fetches data from main memory only needs a very low miss ratio to be useful because of the high main memory access latency . A prefetch instruction that fetches cache lines from a cache further from the processor to a cache closer to the processor may need a miss ratio of a few percent to do any good . <p> It is common that software prefetching fetches slightly more data than is actually used . For example , when iterating over a large array it is common to prefetch data some distance ahead of the loop , for example , 1 kilobyte ahead of the loop . When the loop is approaching the end of the array the software prefetching should ideally stop . However , it is often @ @ @ @ @ @ @ @ @ @ the array than to insert additional code to check when the end of the array is reached . This means that 1 kilobyte of data beyond the end of the array that is n't needed is fetched . <h> 3.6.2. - Hardware Prefetching <p> Many modern processors implement hardware prefetching . This means that the processor monitors the memory access pattern of the running program and tries to predict what data the program will access next and prefetches that data . There are few different variants of how this can be done . <p> A stream prefetcher looks for streams where a sequence of consecutive cache lines are accessed by the program . When such a stream is found the processor starts prefetching the cache lines ahead of the program 's accesses . <p> A stride prefetcher looks for instructions that make accesses with regular strides , that do not necessarily have to be to consecutive cache lines . When such an instruction is detected the processor tries to prefetch the cache lines it will access ahead of it . <p> An adjacent cache line prefetcher automatically fetches adjacent cache @ @ @ @ @ @ @ @ @ @ can be used to mimic behaviour of a larger cache line size in a cache level without actually having to increase the line size . <p> Hardware prefetchers can generally only handle very regular access patterns . The cost of prefetching data that is n't used can be high , so processor designers have to be conservative . <p> An advantage of hardware prefetching compared to software prefetching is that no extra instructions that use execution resources are needed in the program . If you know that an application is going to be run on processors with hardware prefetching , a combination of hardware and software prefetching can be used . The hardware prefetcher can be trusted to prefetch highly regular accesses , while software prefetching can be used for irregular accesses that the hardware prefetcher can not handle . 
@@75677862 @4377862/ <h> Solve open source issues with full-stack enterprise support <p> With Rogue Wave Open Source Support , you get much more than fast bug fixes , you get around-the-clock access to Tier 3/4 open source architects ready to support , consult , and educate your team to solve issues across your entire software stack and development lifecycle . Our vendor-neutral , unbiased support covers the top open source software packages used in mission-critical production environments and includes : <p> If you 're committed to adopting open source , here are seven key questions to think about when determining how effective your current strategy is against the common hurdles . <p> " Without their support we would have been floundering within the Java SDK and Tomcat , and would not have advanced to where we are today . " <h> Common support questions : <p> Which open source package or package version is best suited for a particular job or function ? <p> Are any of the open source packages used in my environment not recommended ? <p> Are there alternative packages I should consider deploying ? <p> How do @ @ @ @ @ @ @ @ @ @ open source package ? <p> What changes were made in a specific version of an open source package ? <p> What benefits can be gained by using a certain version of an open source package ? <p> How will I be affected by a specific security update ? <h> Get a Customized Support Quote <h> Our OSS support stack and support blueprint <p> Click to enlarge <p> Click to enlarge <h> Support options <p> Some enterprises view open source support as an insurance policy , while others rely on support for detailed assistance and problem resolution . That 's why we offer multiple consultative support options that allow you to customize your level of service to your exact needs : <p> Silver Support <p> Gold Support <p> Hours <p> 12x5 ( business hours ) <p> 24x7 ( around the clock ) <p> Service level agreement <p> 4-hour response <p> 1-hour response <p> Problem submission <p> phone / email / online <p> phone / email / online <p> Supported packages <p> Hundreds of OSS packages CentOS Linux <p> Hundreds of OSS packages CentOS Linux <p> Number of named contacts <p> Unlimited @ @ @ @ @ @ @ @ @ @ Unlimited <p> " rogue wave open source support worked through the night to provide a solution within 9 hours . " <h> One number to call for all packages <p> With only one number to call to speak with an open source architect , there 's no need for confusing and costly escalation processes or expensive component-level contracts that do n't cover your entire stack . Whether the problem originates in one package or is the result of complex interactions across the stack , our experts have the training , experience , and mandate to handle all of them . These are your front-line experts , answering questions and delivering solutions just as anyone on your team should be . <h> What is an open source architect ? <p> An open source architect is much more than a seasoned developer , they 're an influential thought leader able to diagnose , solve , and explain difficult technical issues while enabling positive change within an organization . They do this by understanding that many issues are n't just technical , they could involve process and political challenges as well , which @ @ @ @ @ @ @ @ @ @ , and efforts moved forward to avoid analysis paralysis and drive progress . <p> Our architects operate at a Tier 3 and Tier 4 level , meaning they 're experts in their fields and have the experience to not only solve issues seen before but also research and create solutions to new or unknown scenarios ( and they often assist Tier 2 and 3 staff ) . They provide much more than support , they lead the organization towards successful completion by : <p> Offering unbiased , expert advice on the top OSS packages used by enterprises <p> Giving comprehensive , influential guidance and training <p> Providing the answers necessary to progress in the right direction <p> Being held accountable for their continued performance against rigorous standards 
@@75677863 @4377863/ <h> 8.2 The MVC Design Pattern <p> The Model-View-Controller architecture is an object-oriented framework and well-known design pattern for building applications and reusable GUI components . MVC prescribes a way of breaking an application or component into three parts : the model , view , and controller . The original motivation for this separation was to map the traditional input , processing , output roles into the GUI realm : <p> Input --&gt; Processing --&gt; Output <p> Controller --&gt; Model --&gt; View <p> The user input , system function and state , and visual feedback to the user are separated and handled by controller , model , and view respectively . Figure 10 represents the basic MVC triad and lines of communication . <p> The model is really the cornerstone of the triad . As its name implies , its job is to model some real-world system by emulating its state and functionality . Models define queries for reporting state , commands for altering state , and notifications to inform observers ( views , for example ) that a change in state has occurred . The controller is responsible @ @ @ @ @ @ @ @ @ @ is to receive mouse and keyboard input and map this user stimulus into application response for example , by executing the model 's commands . The view manages a rectangular area of the display and is responsible for data presentation and hit testing . ( Hit testing calculates the object at a given position on screen . ) And due to its observer relationship with the model , new views can be defined and attached to a model while holding the model 's interface constant . <p> Figure 10 shows the relationships between model , view and controller in a triad . The dashed lines represent weakly typed aggregation and the solid lines represent strongly typed aggregation . The model maintains a pointer to the viewport , which allows it to send the viewport weakly typed change notifications . Since it is a weakly typed relationship , the model references the viewport only through a base class that allows it to send notifications to the viewport . <p> In contrast , the viewport knows exactly what kind of model it observes . It has a strongly typed pointer to the @ @ @ @ @ @ @ @ @ @ 's functions . The viewport also has a weakly typed relationship with the controller . The viewport is not tied to a specific type of controller , which means that different types of controllers can be used with the same viewport . <p> The controller has pointers to both the model and the viewport and knows the type of both . Because the controller defines the behavior of the triad , it needs to know the type of both the model and the viewport to translate user input into application response . <p> The relationship between the model and viewport is actually defined by another design pattern . The subject-observer pattern defines a one-to-many dependency between objects so that when one object changes state , all its dependents are notified and updated automatically . In the case of MVC , the model is a subject and viewports are observers . See Section 4.2 , " The Subject-Observer Pattern , " for an overview and examples of this design pattern . <p> A more recent text , A System of Patterns : Pattern-Oriented Software Architecture by Frank Buschmann et al . @ @ @ @ @ @ @ @ @ @ and the Command Processor design pattern within the context of C++. 50236 @qwx670236 
@@75677865 @4377865/ <h> 15.1 Why Design an RWCollectable Class ? <p> Before we get to the nuts and bolts of how to design an RWCollectable class , let 's discuss a concrete example of why you might choose to design RWCollectable classes . <p> Suppose you run a bus company . To automate part of your ridership tracking system , you want to write classes that represent a bus , its set of customers , and its set of actual passengers . In order to be a passenger , a person must be a customer . Hence , the set of customers is a superset of the set of passengers . Also , a person can physically be on the bus only once , and there is no point in putting the same person on the customer list more than once . As the developer of this system , you must make sure there are no duplicates on either list . <p> These duplicates can be a problem . Suppose that the program needs to be able to save and restore information about the bus and its customers . When it @ @ @ @ @ @ @ @ @ @ program nanvely iterates over the set of customers , then over the set of passengers , saving each one , any person who is both a customer and a passenger is saved twice . When the program polymorphically restores the bus , the list of passengers will not simply referto people already on the customer list . Instead , each passenger will have a separate instantiation on both lists . <p> You need some way of recognizing when a person has already been polymorphically saved to the stream and , instead of saving him or her again , merely saving a reference to the previous instance . <p> This is the job of class RWCollectable . Objects that inherit from RWCollectable have the ability to save not only their contents , but also their relationships with other objects that inherit from RWCollectable . We call this feature isomorphic persistence . Class RWCollectable has isomorphic persistence , but more than that , it can determine at run time the type of the object to be saved or restored . We call the type of persistence provided by RWCollectablepolymorphic persistence , and @ @ @ @ @ @ @ @ @ @ The code below shows how we might declare the classes described in the previous section . Later we 'll use the macro RWDECLARECOLLECTABLE and discuss our function choices . You 'll find the complete code from which this example is taken at the end of this chapter ; it is also given as the bus example in the toolexam directory . <p> Note how both classes inherit from RWCollectable . We have chosen to implement the set of customers by using class RWSet , which does not allow duplicate entries . This will guarantee that the same person is not entered into the customer list more than once . For the same reason , we have also chosen to implement the set of passengers using class RWSet . However , we have chosen to have this set live on the heap . This will help illustrate some points in the coming discussion . 
@@75677866 @4377866/ <h> Member Functions <p> RWMutexLock implements a mutex or mutual exclusion lock . It can be used to permit only one thread at a time to access a section of code that is to be treated as a single atomic operation . Mutexes are typically used to protect sections of code that access shared resources or data . The sensitive area of code , or critical section , is bracketed by calls to acquire and release on the mutex . <p> All operations on the mutex , except initialization , are themselves guaranteed to be atomic in order to prevent race conditions from destroying the integrity of the lock . However , there is no reliable mechanism to guarantee that a race condition will not occur during initialization of a mutex lock . Generally , the user can ensure this by creating and initializing all mutexes in a primary thread of execution , before other threads are spawned . However , in the common case , when a mutex is used to protect static global data , there is no portable way to atomically initialize the mutex because C++ @ @ @ @ @ @ @ @ @ @ implementation-specific . <p> RWMutexLock provides some protection against race conditions during initialization of static global mutexes by providing a special constructor that does no initialization . When this constructor is used , initialization is postponed until the first attempt to acquire the lock . In order to prevent race conditions during mutex initialization by using this constructor , the user must still make sure the first acquire operation on such a mutex is not attempted concurrently by two or more threads . <p> This class is primarily a portable object wrapper for platform-specific mutex implementations . For example , RWMutexLock uses an instance of pthreadmutext for POSIX conforming environments , mutext on Solaris platforms , a mutex semaphore represented by an HMTX handle under OS2 , and a mutex represented by a HANDLE under Win32 . <p> #include **29;9340;TOOLONG // for RWMutexLock #include **30;9371;TOOLONG // for RWTLockGuard&lt;T&gt; class SavingsAccount public : SavingsAccount ( int initialBalance ) ; void deposit ( int amount ) ; void withdraw ( int amount ) ; int balance(void) ; static void **27;9403;TOOLONG decrement ) ; static double getInterestRate(void) ; private : int balance ; static @ @ @ @ @ @ @ @ @ @ // instance data ; void SavingsAccount : : deposit ( int amount ) // Acquire mutex so that only one thread can access the // state . Normally you should use a LockGuard to acquire a // mutex that is to be released at the end of a scope . We // show the explicit form here for completeness . The // preferred form is shown below . objectMutex.acquire() ; balance += amount ; objectMutex.release() ; void SavingsAccount : : withdraw ( int amount ) // An RWTLockGuard acquires a synch . object // in its constructor and releases it in its destructor. // Preferred over explicit calls to acquire and release // on the mutex . This is because : // 1 ) you will never forget to do the release and // 2 ) if an exception is thrown from somewhere in your // function , the lock will always be released because all // objects on the stack will have their destructors called // as the stack is unwound // calls objectMutex.acquire() : **31;9432;TOOLONG lock(objectMutex) ; balance -= amount ; // objectMutex released in lock destructor. int @ @ @ @ @ @ @ @ @ @ a typedef of // **31;9465;TOOLONG . It has the same effect // as above . This is the form that we prefer // for purely aesthetic reasons : RWMutexLock : : LockGuard lock(objectMutex) ; return balance ; // objectMutex released in lock destructor . <p> Causes the current thread to block until the mutex is released , at which time the thread acquires the mutex and continues . In the debug version of the library , this function will produce an assertion and abort if a thread attempts to recursively acquire the same mutex . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError . <p> This function will throw an RWCancellation object if the mutex has cancellation detection enabled and a runnable containing the calling thread has been canceled . <p> RWWaitStatus acquire ( unsigned long milliseconds ) ; <p> Blocks at least for the specified number of milliseconds , or until the mutex is released-whichever comes first . If the mutex is released within the specified time , acquires it , and continues . If the mutex is not released , returns RWTHRTIMEOUT . In the debug version @ @ @ @ @ @ @ @ @ @ and abort if a thread attempts to recursively acquire the same mutex . <p> Note that true timed-acquisition is not supported on all platforms . OS/2 and Win32 support it , but Solaris and POSIX do not . On those platforms that do not support true timed-acquisition , if the mutex can not be acquired immediately , the function simply returns RWTHRTIMEOUT . Timed mutex acquisition is available if the macro , **25;9498;TOOLONG is defined . <p> This function will throw an RWCancellation object if the mutex has cancellation detection enabled and a runnable containing the calling thread has been canceled . Other possible exceptions include RWTHRResourceLimit and RWTHRInternalError . <p> Releases the mutex , making it available . Possible exceptions include RWTHRInternalError . <p> RWBoolean tryAcquire(void) ; <p> Tries to acquire mutex without blocking . Returns TRUE if the mutex is acquired , and FALSE if the mutex is not acquired . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError. 
@@75677867 @4377867/ <h> Data Types <h> Member Functions <p> An RWSemaphore is a synchronization object that maintains a non-negative counter . When a semaphore is acquired the count is decremented . If the count is zero when acquire() is called , then the calling thread will be put on a wait queue and block . When the thread reaches the head of the queue it can acquire the semaphore as soon as the counter is incremented . The count is incremented when a thread calls release() on the semaphore . The initial count of a semaphore is set when it is created ; it defaults to 0 . <p> An important difference between a mutex and a semaphore with a count of 1 is that a mutex can only be released by the thread that acquired it . A semaphore can be released by any thread . <p> Among the uses of semaphores are restricting access to some limited resource , and signaling some condition between threads . <p> // This program simulates a situation where 5 people all want to // take a nap but there are only two pillows @ @ @ @ @ @ @ @ @ @ a stiff neck by sleeping without one ! ) // A semaphore with an initial count of 2 is used to coordinate // access to this limited resource . The semaphore ensures that // at most two people are sleeping at any given time . #include &lt;iostream.h&gt; #include **29;9525;TOOLONG #include **29;9556;TOOLONG #include **34;9587;TOOLONG #include **41;9623;TOOLONG RWSemaphore sem(2) ; // Coordinate pool of 2 pillows RWMutexLock coutLock ; // Coordinate use of cout void print ( int i 'd , const char* p ) RWMutexLock : : LockGuard lock(coutLock) ; cout &lt;&lt; " Thread " &lt;&lt; i 'd &lt;&lt; " " &lt;&lt; p &lt;&lt; endl ; void takeNap ( int i 'd ) print ( i 'd , " is waiting for a pillow " ) ; sem.acquire() ; // Get one of the two pillows print ( i 'd , " has acquired a pillow and is settling down for a nap " ) ; rwSleep(1000) ; // Even a 1 second nap can be very refreshing ! print ( i 'd , " is awake and making a pillow available " ) ; sem.release() ; // Make a pillow available int main() int i ; @ @ @ @ @ @ @ @ @ @ ) ( threadi = **29;9666;TOOLONG , i+1 ) ) . start() ; for ( i=0 ; i&lt;5 ; ++i ) threadi.join() ; return 0 ; /* * OUTPUT : * Thread 1 is waiting for a pillow Thread 1 has acquired a pillow and is settling down for a nap Thread 2 is waiting for a pillow Thread 2 has acquired a pillow and is settling down for a nap Thread 3 is waiting for a pillow Thread 4 is waiting for a pillow Thread 5 is waiting for a pillow Thread 1 is awake and making a pillow available Thread 2 is awake and making a pillow available Thread 3 has acquired a pillow and is settling down for a nap Thread 4 has acquired a pillow and is settling down for a nap Thread 3 is awake and making a pillow available Thread 4 is awake and making a pillow available Thread 5 has acquired a pillow and is settling down for a nap Thread 5 is awake and making a pillow available * */ <p> Acquires the semaphore by attempting to decrement the count . If the @ @ @ @ @ @ @ @ @ @ another thread increments the count by calling release() . Otherwise , the count is decremented and the thread is allowed to proceed . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError . <p> RWWaitStatus acquire ( unsigned long milliseconds ) ; <p> Acquires the semaphore by attempting to decrement the count . If the semaphore count is zero , the current thread blocks until another thread increments the count or the specified amount of time expires . If the time has expired , the method returns RWTHRTIMEOUT . Otherwise , the count is decremented and the thread is allowed to proceed . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError . <p> RWSemaphoreRep* getSemaphoreRep(void) const ; <p> Currently supported for the Win32 platform only , this method provides access to the underlying mechanism . <p> void P(void) ; <p> Calls acquire() . P stands for passeren , which is Dutch for to pass . Provided for those who wish to use this traditional sign handed down from the Dutch inventor of the semaphore , E. W. Dijkstra . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError . @ @ @ @ @ @ @ @ @ @ Returns the result of calling acquire(milliseconds) . P stands for passeren , which is Dutch for to pass . Provided for those who wish to use this traditional sign handed down from the Dutch inventor of the semaphore , E. W. Dijkstra . Possible exceptions include RWCancellation , RWTHRResourceLimit , and RWTHRInternalError . <p> void release(void) ; <p> Releases the semaphore by incrementing the semaphore count . Possible exceptions include RWTHRInternalError . <p> NOTE : This method always increments the count , even if this increases the count beyond the count supplied to the constructor . For instance , the sequence sem = RWSemaphore(1) ; sem.release() ; increases sem 's count to 2 . <p> Calls release() . V stands for vrygeven , which is Dutch for " to release . " Provided for those who wish to use this traditional sign handed down from the Dutch inventor of the semaphore , E. W. Dijkstra . Possible exceptions include RWTHRInternalError . <p> NOTE : This method always increments the count , even if this increases the count beyond the count supplied to the constructor . For instance , the sequence @ @ @ @ @ @ @ @ @ @ to 2. 
@@75677868 @4377868/ <p> See IlvPort : : initDevice() for a general explanation of this method . In this class , the parameter printer may be either a string returned by the function IlvGetWindowsPrinter() or a string that is the name of a printer available for Windows . If this parameter is null , then the registered **26;9697;TOOLONG is called to actually initialize the printer . <p> This function should be called before invoking the initDevice() method . If you want to change the paper orientation once the device has been initialized , you must close the device , call setOrientation() , and then invoke initDevice() once again . <p> The values are the same as the ones specified in the member dmOrientation of the Windows structure DEVMODE. 
@@75677869 @4377869/ <p> Class RWSortedVector represents a group of ordered items , internally sorted by the compareTo() function and accessible by an index number . Duplicates are allowed . An object stored by RWSortedVector must inherit from the abstract base class RWCollectable . An insertion sort is used to maintain the vector in sorted order . <p> Because class RWSortedVector is implemented as a vector of pointers , traversing the collection is more efficient than with class RWBinaryTree . However , insertions are slower in the center of the collection . <p> Note that because the vector is sorted , you must not modify elements contained in the vector in such a way as to invalidate the ordering . <p> Returns TRUE if for every item in self , the corresponding item in sv at the same index is equal . The two collections must also have the same number of members . <p> const RWCollectable* operator ( sizet i ) ; <p> Returns the ith element in the collection . If i is out of range , an exception of type RWBoundsErr will be thrown . The return value can @ @ @ @ @ @ @ @ @ @ operator() ( sizet i ) ; <p> Returns the ith element in the collection . Bounds checking is enabled by defining the preprocessor directive RWBOUNDSCHECK before including the header file " rwsortvec.h " . In this case , if i is out of range , an exception of type RWBoundsErr will be thrown . The return value can not be used as an lvalue . <p> Redefined from class RWOrdered . Performs a binary search to return the index of the first item that compares equal to the target item , or RWNPOS if no such item can be found . <p> virtual RWCollectable* insert ( RWCollectable* c ) ; <p> Redefined from class RWOrdered . Performs a binary search to insert the item pointed to by c after all items that compare less than or equal to it , but before all items that compare greater than it . Returns nil if the insertion was unsuccessful , c otherwise . 
@@75677870 @4377870/ <p> Class RWDBSchema is an ordered collection of RWDBColumns . An RWDBSchema serves as an encapsulation of the database notion of schema , a set of attributes defining a table . DBTools.h++ extends this notion slightly by using an RWDBSchema to define a stored procedure 's formal parameter list , and to specify a list of columns wherever one is required . Each RWDBSchema can have foreign key and primary key information associated with it . <p> Every RWDBTable has an RWDBSchema . An application can interrogate the RWDBSchema of an RWDBTable for schema information , or obtain a copy of an RWDBSchema for its own use . An RWDBSchema instance may be used to create a database table . To do this , an application can use an RWDBSchema obtained from an existing RWDBTable , modify an existing RWDBSchema , or build one from scratch using the methods appendColumn , foreignKey , and primaryKey . <p> This class is implemented using a technique called copy on write . With this technique , the copy constructor and assignment operators reference the old object and , as a result , @ @ @ @ @ @ @ @ @ @ when the object is about to be changed . The net result is excellent performance , with easy-to-understand copy semantics . <p> Compares self to schema . Returns TRUE if schema and self are identical . <p> RWDBColumn operator ( sizet index ) const ; <p> Returns the RWDBColumn in self at position index . If index is out of range , returns an RWDBColumn with a status of RWDBStatus : : invalidPosition . Indexing into an empty schema is treated as out of range . Note that the returned RWDBColumn is not a deep copy ; modifications to it change the containing schema . <p> RWDBColumn operator ( const RWCString&amp; name ) const ; <p> Returns the first RWDBColumn in self with the given name . If no such column exists , an RWDBColumn is returned with a status of RWDBStatus : : columnNotFound . Note that the returned RWDBColumn is not a deep copy ; modifications to it change the containing schema . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until the mutex @ @ @ @ @ @ @ @ @ @ const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> Constructs a new RWDBColumn according to the supplied parameters , appends it to self , and returns it . Applications using this method must usually supply only name and type , as well as storagelength if type is RWDBValue : : string . <p> name represents the name of the new column appended to the schema . <p> type should be one of the DBTools.h++ datatype attributes . See RWDBValue for more explanation . <p> storageLength should be set if the datatype requires a size , such as String or Blob datatypes . <p> nativeType should be set if one of the DBTools.h++ datatype attributes can not represent the native datatype of the database . If this field is set , type should be left as the default to show that a native datatype was requested . The native datatypes of a specific database can be determined through documentation or header files . <p> precision and scale are used when specifying a numeric datatype , such as Decimal . The precision and scale @ @ @ @ @ @ @ @ @ @ should be set to FALSE if a column requires a value . The default value of TRUE allows a column 's value to be set to null . <p> paramType should be set when specifying the parameters of a stored procedure . See RWDBStoredProc for more information on how to use this parameter . For normal tables , use the default value . <p> Returns a comma-delimited string of the foreign keys attached to self . <p> RWCString keysAsString ( const RWDBPhraseBook&amp; ) ; <p> Returns a comma-delimited string of the foreign keys attached to self . <p> RWDBSchema primaryKey() ; <p> Returns the primary key associated with self as an RWDBSchema . An empty schema indicates there is no primary key associated with self . <p> RWDBSchema&amp; primaryKey ( const RWDBSchema&amp; pk ) ; <p> Sets self 's primary key to pk . Returns a reference to self . <p> void release() const ; <p> Releases a previously acquired mutex . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> void **26;9725;TOOLONG : : @ @ @ @ @ @ @ @ @ @ error handler . The supplied handler is inherited by all objects produced by self . By default , the error handler of an RWDBSchema is inherited from the object that produced it ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : 
@@75677871 @4377871/ <p> The where() method of RWDBDeleter is used to specify a WHERE clause . The WHERE clause is encapsulated by an RWDBCriterion , which is some number of RWDBExprs combined with logical operators . <p> A DELETE statement does not normally produce results . However , DBTools.h++ recognizes that some database vendors provide triggers , which can cause results to be generated by a DELETE statement . Consequently , the execute() method of RWDBDeleter returns an RWDBResult , which is a sequence of zero or more RWDBTables . Applications are not obliged to request any tables from the returned object . <p> RWDBDeleter is designed around the Interface/Implementation paradigm . An RWDBDeleter instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBDeleter implementation is a base class from which a family of database-specific deleter implementations is derived . <p> The default constructor creates an RWDBDeleter whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience , for example , to declare an array of RWDBDeleters . Usable RWDBDeleters are obtained @ @ @ @ @ @ @ @ @ @ lock . If the mutex is already locked by another thread , the function blocks until the mutex is released . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWCString asString() const ; <p> Returns the SQL equivalent of DELETE FROM table WHERE ... . <p> void clear() ; <p> Clear self 's WHERE clause and internal controls . <p> RWDBStatus : : ErrorHandler errorHandler() const ; <p> Returns the error handler attached to self . <p> RWDBResult execute() ; <p> Uses a default database connection to cause the SQL statement encapsulated by self to be executed . The connection is held by the RWDBResult until the RWDBResult is destroyed . <p> RWDBResult execute ( const RWDBConnection&amp; connection ) ; <p> Uses the supplied connection to cause the SQL statement encapsulated by self to be executed . The connection is held by the RWDBResult until the RWDBResult is destroyed . This function can behave asynchronously if executed using an asynchronous connection . <p> RWBoolean isReady() const ; <p> This function returns TRUE if the @ @ @ @ @ @ @ @ @ @ object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if self 's status is RWDBStatus : : ok , otherwise returns FALSE . Does not return FALSE if the previous executed statement failed . You must check the status of the RWDBResult returned from execute() instead of the status of the RWDBDeleter object . <p> void release() const ; <p> Releases a previously acquired mutex . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> void **26;9753;TOOLONG : : ErrorHandler handler ) ; <p> Installs handler as self 's error handler . The supplied handler is inherited by all objects produced by self . By default , the error handler of an RWDBDeleter is inherited from the object that produced it ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : <p> typedef void ( *ErrorHandler ) ( const RWDBStatus&amp; ) ; <p> RWDBStatus status() const ; <p> Returns the current status of self @ @ @ @ @ @ @ @ @ @ that produced self . Returns an RWDBTable whose status is RWDBStatus : : notInitialized if self was produced with the default constructor . <p> RWDBCriterion where() const ; <p> Returns a copy of self 's RWDBCriterion , an encapsulated SQL WHERE clause . Returns an empty RWDBCriterion if self has no WHERE clause . <p> RWDBDeleter&amp; where ( const RWDBCriterion&amp; criterion ) ; <p> Specifies criterion as self 's SQL WHERE clause . If self already has a WHERE clause , this method replaces it . Specifying an empty criterion clears self 's WHERE clause . Notice that a deleter without a WHERE clause deletes all rows from its table . Returns a reference to self . 
@@75677872 @4377872/ <h> 11.3 Tools.h++ Templates and the Standard C++ Library <p> Most of the Tools.h++ collection class templates use the Standard C++ Library for their underlying implementation . The collection classes of the Standard C++ Library , called containers , act as an engine under the hood of the Tools.h++ templates . <p> For example , the value-based Tools.h++ double-ended queue **25;9781;TOOLONG member of type deque&lt;T&gt; from the Standard C++ Library . This member serves as the implementation of the collection . Like an engine , it does the bulk of the work of adding and removing elements , and so on . RWTValDeque&lt;T&gt; is a wrapper class , like the hood protecting the engine . More than cosmetic , it functions as a simpler , object-oriented interface to the deque class , making it easier and more pleasant to deal with . <p> Thanks to inlining and the lack of any extra level of indirection , this wrapping incurs few , if any , performance penalties . If you need direct access to the implementation , the wrapper classes offer the member function std() , which returns a reference @ @ @ @ @ @ @ @ @ @ Wave template collections supply standard iterators , you can use them with the Standard C++ Library algorithms as if they were Standard C++ Library collections themselves . <p> A unique feature of this version of Tools.h++ is that many of its template collections do not actually require the presence of the Standard C++ Library . Consider RWTValDlist&lt;T&gt; . If you are using Tools.h++ on a platform that supports the Standard C++ Library , RWTValDlist&lt;T&gt; will be built around the Standard C++ Library list container . But if your platform does not support the Standard C++ Library , you may still use the class . Tools.h++ accomplishes this feat transparently through an alternate implementation , not based on the Standard C++ Library . The appropriate implementation is selected at compile time based on the settings in the configuration header file , rw/compiler.h . In fact , the alternate implementations are exactly those that were employed in the previous version of Tools.h++ . <p> When using one of these template collections without the Standard C++ Library , you will be restricted to a subset of the full interface . For example , @ @ @ @ @ @ @ @ @ @ nor are the begin() and end() functions , which return Standard C++ Library iterators . The Tools.h++Class Reference contains entries for both the full and the subset interfaces for all of the templates that can be used either with or without the Standard C++ Library . <p> There are two reasons you may want to use the restricted subset interface for a collection class template : <p> You may be operating in an environment that does not yet support a version of the Standard C++ Library compatible with this version of Tools.h++ . In that case , you have no choice but to use the restricted subset interface . The good news is that by using the interface , you will be ready to start using the full interface as soon as the Standard C++ Library becomes available on your platform . <p> Another reason to stick to the subset interface is that you want to write portable code -- a class library , perhaps -- that can be deployed on multiple platforms , some without support for the Standard C++ Library . Clients of that code can still take @ @ @ @ @ @ @ @ @ @ forced to inflict on them a " lowest common denominator . " See Section 2.10 toward the end of this chapter for more information on the restricted subset interface . <p> There are seven Standard C++ Library containers : deque , list , vector , set , multiset , map , and multimap . Tools.h++ extends these with five additional containers which are compliant with the Standard C++ Library : rwslist , rwhashset , rwhashmultiset , rwhashmap , and rwhashmultimap . Each of these has value-based and pointer-based Rogue Wave wrapper templates . Tools.h++ also offers always-sorted versions , both value-based and pointer-based , of the doubly-linked list and vector collections . The total : 28 new or re-engineered collection class templates , all based on the Standard C++ Library ! <p> To keep things simple and allow you to program with more flexibility , we have implemented common interfaces within the various divisions of standard-library based collection class templates . For example , the RWTPtrSet and RWTPtrMultiSet templates have interfaces identical to their value-based cousins ; so do the map-based collection classes . All of the Sequence-based collections have @ @ @ @ @ @ @ @ @ @ ( An exception here is the set of deque-based classes , which contain push and pop member functions designed to enhance their abstraction of the queue data structure . ) <p> There are pluses and minuses to this approach . The downside is that it puts slightly more of the burden on you , the developer , to choose the appropriate collection class . Had we chosen not to provide the insertAt ( sizetype index ) member function for class **31;9808;TOOLONG , we could have enforced the idea that vector-based templates are not a good choice for inserting into the middle of a collection class . Instead , it is up to you to be aware of your choices and use such member functions judiciously . <p> On the plus side , the common interface lowers the learning curve , allows flexibility in experimenting with different collections , and provides the capability of dealing with the Rogue Wave templates polymorphically via genericity. 14 <p> Real-life programming is seldom as neat as the exercises in a data structures textbook . You may find yourself in a situation where it is difficult @ @ @ @ @ @ @ @ @ @ to use . With the common interface , you can easily benchmark code that uses an RWTValDeque and later benchmark it again , substituting an RWTValOrderedVector or RWTValDlist . You can also write class and function templates that are parameterized on the collection class type . For example : 
@@75677873 @4377873/ <p> Retrieves the descent spacing value of a given IlvFont object . Refer to the figure " Font " for an illustration . You can also get this quantity for a specific string by calling the member function sizes . <p> This method returns logical dimensions . It does not return the precise painted rectangle but the dimensions of a box that provides minimum spacing to other graphical effects ( such as a border surrounding the text ) . In other words , it is different from the bounding box of the ink used to draw the text . 50234 @qwx670234 <p> string <p> The string to be measured . <p> length <p> The length of the string , in bytes . If a negative value is provided , the length is computed using strlen . <p> Just like IlvFont : : sizes , this method returns a logical dimension . It does not return the precise height of the painted rectangle but the height of a box that provides minimum spacing to other graphical effects ( such as a border surrounding the text ) . In other words @ @ @ @ @ @ @ @ @ @ used to draw the text . 50234 @qwx670234 <p> string <p> The string to be measured . <p> length <p> The length of the string , in bytes . If a negative value is provided , the length is computed using strlen . <p> Returns : <p> The logical height of the string , in pixels , when displayed with this font . <p> Just like IlvFont : : sizes , this method returns a logical dimension . It does not return the precise width of the painted rectangle but the width of a box that provides minimum spacing to other graphical effects ( such as a border surrounding the text ) . In other words , it is different from the width of the ink used to draw the text . 50234 @qwx670234 <p> string <p> The string to be measured . <p> length <p> The length of the string , in bytes . If a negative value is provided , the length is computed using strlen . <p> Returns : <p> The logical width of the string , in pixels , when displayed with this font . 
@@75677875 @4377875/ <h> Members <p> This alternative interface is now deprecated and may be eliminated from a later release . For more information on the support of deprecated classes , please contact your Rogue Wave account representative . <p> Class RWCRegexp represents a regular expression . The constructor " compiles " the expression into a form that can be used more efficiently . The results can then be used for string searches using class RWCString . <p> The regular expression ( RE ) is constructed as follows : <p> The following rules determine one-character REs that match a single character : <p> Any character that is not a special character ( to be defined ) matches itself . <p> A backslash ( ) followed by any special character matches the literal character itself . I.e. , this " escapes " the special character . <p> NOTE -- There is one exception to this rule . char is interpreted as a control character : thus R is control-R . To match the circumflex itself , use x5e in ASCII environments . <p> The " special characters " are : <p> + * @ @ @ @ @ @ @ @ @ @ any character except the newline . For example , " . umpty " matches either " Humpty " or " Dumpty . " <p> A set of characters enclosed in brackets ( ) is a one-character RE that matches any of the characters in that set . Example : " akm " matches either an " a " , " k " , or " m " . A range of characters can be indicated with a dash . Example : " a-z " matches any lower-case letter . However , if the first character of the set is the caret ( ) , then the RE matches any character except those in the set . It does not match the empty string . Example : akm matches any character except " a " , " k " , or " m " . The caret loses its special meaning if it is not the first character of the set . <p> The following rules can be used to build a multicharacter RE . <p> A one-character RE followed by an asterisk ( * ) matches zero or more occurrences @ @ @ @ @ @ @ @ @ @ more lower-case characters . <p> A one-character RE followed by a plus ( + ) matches one or more occurrences of the RE . Hence , a-z+ matches one or more lower-case characters . <p> A question mark ( ? ) is an optional element . The preceding RE can occur zero or once in the string -- no more . For example , xy ? z matches either xyz or xz . <p> The concatenation of REs is a RE that matches the corresponding concatenation of strings . For example , A-Za-z* matches any capitalized word . <p> Finally , the entire regular expression can be anchored to match only the beginning or end of a line : <p> If the caret ( ) is at the beginning of the RE , then the matched string must be at the beginning of a line . <p> If the dollar sign ( $ ) is at the end of the RE , then the matched string must be at the end of the line . <p> The following escape codes can be used to match control characters : <p> b @ @ @ @ @ @ @ @ @ @ f <p> formfeed <p> n <p> newline <p> r <p> carriage return <p> t <p> tab <p> xddd <p> the literal hex number 0xdd <p> ddd <p> the literal octal number ddd <p> C <p> Control code . For example , D is " control-D " <p> The most frequent problem with use of this class is in being able to specify a backslash character to be parsed . If you are attempting to parse a regular expression that contains backslashes , you must be aware that the C++ compiler and the regular expression constructor will both assume that any backslashes they see are intended to escape the following character . Thus , to specify a regular expression that exactly matches " aa " , you would have to create the regular expression using four backslashes as follows : the regular expression needs to see " aa " , and for that to happen , the compiler would have to see " aa " . <p> RWCRegexp reg ( " aa " ) ; 1 2 <p> The backslashes marked with a are an escape for the compiler , and @ @ @ @ @ @ @ @ @ @ regular expression parser . At that point , the backslash marked 1 is an escape , and the one marked 2 will actually be put into the regular expression . <p> Similarly , if you really need to escape a character , such as a " . " , you will have to pass two backslashes to the compiler : <p> RWCRegexp regDot ( " . " ) <p> Once again , the backslash marked is an escape for the compiler , and the one marked with will be seen by the regular expression constructor as an escape for the following " . " . <p> Returns the index of the first instance in the string str that matches the regular expression compiled in self , or RWNPOS if there is no such match . The search starts at index start . The length of the matching pattern is returned in the variable pointed to by len . If an invalid regular expression is used for the search , an exception of type RWInternalErr will be thrown . Note that this member function is relatively clumsy to use -- class @ @ @ @ @ @ @ @ @ @ <p> Pattern exceeded maximum length . ( To change the amount of space allocated for a pattern , edit regexp.cpp to change the value of RWCRegexp : : maxval , then recompile and insert the changed object into the appropriate library. ) 
@@75677876 @4377876/ <p> This class maintains a stack of values . Not only can the type of object inserted onto the stack be parameterized , but also the implementation of the stack . <p> Parameter T represents the type of object in the stack , either a class or built in type . The class T must have : <p> well-defined copy semantics ( T : : T ( const T&amp; ) or equiv . ) ; <p> well-defined assignment semantics ( T : : operator= ( const T&amp; ) or equiv . ) ; <p> any other semantics required by class C. <p> Parameter C represents the class used for implementation . Useful choices are **28;9841;TOOLONG or RWTValDlist&lt;T&gt; . Class RWTValSlist&lt;T&gt; can also be used , but note that singly-linked lists are less efficient at removing the last item of a list ( function pop() ) , because of the necessity of searching the list for the next-to-the-last item . 
@@75677877 @4377877/ <h> Member Function Documentation <p> This member function is called whenever the bounding box of the contents of this IlvSCManagerRectangle is modified . It occurs when the transformer of the manager view is changed , or when objects are added or removed from the manager . This function is called by the internal manager view hook to compute the correct values to assign to the scroll bars so that they match the manager contents . 50234 @qwx670234 <p> bbox <p> Rectangle used to store the returned value . <p> IlvScrollBar* IlvSCManagerRectangle : : getHorizontalScrollBar <p> ( <p> ) <p> const <p> Retrieves the horizontal scroll bar . <p> Returns : <p> A pointer to the horizontal scroll bar used by this object , or 0 if there is no horizontal scroll bar . <p> IlvScrollBar* IlvSCManagerRectangle : : getVerticalScrollBar <p> ( <p> ) <p> const <p> Retrieves the vertical scroll bar . <p> Returns : <p> A pointer to the vertical scroll bar used by this object , or 0 if there is no vertical scroll bar . <p> This member function let 's you move the vertical scroll bar @ @ @ @ @ @ @ @ @ @ , or move the vertical scroll bar to the top or to the bottom of the graphic object . The default is to have the vertical scroll bar on the left of the object , and the horizontal scroll bar located at the bottom of the object ( except on the Bidi version of Rogue Wave Views , where the location of the vertical scroll bar depends on the layoutDirection of this object ) . 50234 @qwx670234 <p> which <p> Indicates which scroll bar should be moved . This parameter can be either IlvHorizontal or IlvVertical . <p> Returns : <p> where The new location of the indicated scroll bar . If which is IlvVertical , valid values are IlvLeft and IlvRight . If which is IlvHorizontal , valid values are IlvTop and IlvBottom . <p> If IlTrue , the manager is considered to be owned by the object and will be automatically deleted when the object is destroyed . If IlFalse , destroying the manager will be the responsibility of the user . 
@@75677878 @4377878/ <h> Open source audits <p> The adoption of open source software has helped every team deliver value faster but the variety , volume , and risks have also grown , leading organizations to look inward to meet legal and compliance obligations and eliminate security risks . The OpenLogic application audit service analyzes internally-developed software for both known and unknown open source packages to create complete bill of materials ( BOM ) and bill of licenses for open source components , helping you understand the scope and depth of usage . <p> Once scanned , Rogue Wave aggregates the information and creates comprehensive reports to give companies the information they need to make informed decisions about distribution , security issues , and legal considerations . <h> Open source license compliance <p> Without a comprehensive understanding of the open source packages and licenses embedded in your applications , companies that distribute software or products containing software may be at risk of violating the legal obligations of one or more licenses . Our OpenLogic application audit service helps enterprises understand the license obligations that come with the open source software used in @ @ @ @ @ @ @ @ @ @ Compliance Checklist service provides the critical information that organizations need to fulfill their open source license compliance requirements . This is essential for companies that distribute software or products containing software and need to assure license compliance . The Compliance Checklist service does just that - it provides the framework to verify OSS license compliance . With this service , you avoid customer objections and potential litigation . <h> Open source M &amp; A and legal audits <p> Open source licenses used in acquired intellectual property have a significant impact on the valuation of the company . Whether for internal audit purposes or a Merger and Acquisition ( M &amp; A ) transaction , our M&amp;A Open Source Audit service provides technical and legal stakeholders with a detailed scan of software assets to identify open source . It offers a due diligence report that includes a complete list of open source packages and licenses that were found along with the relevant obligations that must be followed to ensure license compliance . <p> During an M&amp;A transaction , its critical for both sellers and buyers to understand the IP profile of @ @ @ @ @ @ @ @ @ @ software that may be included in proprietary code . Buyers can leverage the M&amp;A Open Source Audit service to identify intellectual property conflicts and ensure that they understand any embedded open source licenses and obligations . Sellers can use the M&amp;A Open Source Audit service to provide accurate disclosures and ensure mergers and acquisitions move forward smoothly and without asset devaluation . <h> OSS application security <p> The open source software ( OSS ) bill of materials ( BOM ) delivered in our OSS audits provide a list of the OSS components that are part of the codebase . These components may have known security vulnerabilities associated with themand its critical for an organization to quickly identify and remediate any such threats to avoid the financial , reputation , and regulatory damages associated with security breaches . Our OSS audit experts help CISO and development teams prioritize and identify the security risks hiding in their code bases . The audit consultants review the National Institute of Standards and Technology ( NIST ) Vulnerability Database to provide a risk assessment of the discovered OSS software components allowing you to develop a remediation plan and prioritize based on severity . 
@@75677880 @4377880/ <p> Developing secure applications requires constant vigilance , from prototype to release and post-release . Security vulnerabilities can be introduced when the first line of code is written , and not detected until much later . That 's why building bulletproof software means catching bugs , errors , and loopholes as early as possible , with tools that cover all aspects of development : writing code at the developer desktop , finding risks during run-time debugging , identifying malware or spyware with smart , predictive analytics , ensuring open source use is protected , and protecting your code from unauthorized access . <p> We call this our risk mitigation toolchain . Encompassing development efforts from individual development to builds to deployment , we provide the tools that identify and reduce your security risk . <p> Bringing the power of static code analysis to the desktop , Klocwork finds security vulnerabilities as code is being written , before they become reality . Working within popular IDEs ( or at the command line ) , Klocwork ensures that you know where potential risks can occur by reporting against common memory and command @ @ @ @ @ @ @ @ @ @ OWASP , CWE , CERT , SAMATE , and DISA . <p> Open source software plays a dominant role in the industry today and with it , comes more attention on security and more business impacts when flaws make the headlines . OpenLogic is purpose-built to protect your organization against security weaknesses in two ways : with open source scanning , you get a complete picture of where open source exists on servers , desktops , and even within a few lines of code within a repository ; with OpenLogic , you get up-to-date reporting of known security flaws and issues plus access to the latest patches . <p> Recent cyberattacks against big companies and high profile government agencies have underscored the importance of secure applications . Our security audit service helps organizations protecting themselves against those attacks . It follows a comprehensive methodology developed over years of experience in analyzing PHP , Java , and C/C++ applications . Our focus is identifying vulnerabilities in an applications custom code in addition to the platform . The audit delivers a detailed evaluation of your code for vulnerabilities , non-secure programming practices @ @ @ @ @ @ @ @ @ @ spectrum of known attack vectors . <p> High performance computing and supercomputing presents unique testing challenges that the TotalView debugger is built to handle . Helping you discover memory issues and execution problems by allowing the simultaneous debugging of multiple processes and threads across many cores , TotalView helps you keep your app secure and protected . <p> Being able to predict malicious attacks before they occur is how IMSL Numerical Libraries helps your organization safeguard itself . Through an extensive set of proven , embeddable math and statistics algorithms , you can easily build advanced forecasting and detection functions that translate large amounts of real data into accurate predictions of potential attack vectors . <p> You worked hard to develop your code . Now you need to protect it . Zend Guard delivers powerful encoding and obfuscation technologies to prevent reverse engineering , copyright infringement , and unauthorized modification of your code . Zend Guard helps you manage risks that stem from unauthorized access to source code . These risks include loss of intellectual property , ease of probing for application security vulnerabilities , and loss of revenue that @ @ @ @ @ @ @ @ @ @ circumvent licensing , and then recompiled. 
@@75677881 @4377881/ <h> Rogue Wave Software releases 2017 Open Source Support Report <p> Louisville , CO " 2/23/2017 <h> Eighty percent of issues arise from configuration and infrastructure <p> For the second year in a row , Rogue Wave Software has released an Open Source Support Report examining how and why customers use open source software ( OSS ) . The report profiles open source package popularity , shifts in the open source community , and real-world statistics on how OSS is used in the enterprise . <p> " This year we 've added more information exposing what our open source support and audit teams see in real-life situations , " says Justin Reock , senior director of support and professional services at Rogue Wave Software . " We can now confirm what weve always suspected : Most OSS issues can be attributed to a lack of product knowledge or something in the environment outside of the package , and not usually the package itself . " <p> The Rogue Wave Open Source Support Report also includes actual use cases from Rogue Wave Open Source Support customers , allowing a rare look @ @ @ @ @ @ @ @ @ @ using open source in mission-critical applications . <p> As Rod Cope , CTO of Rogue Wave Software and founder of OpenLogic , says in the report , " The old story of needing to understand if your organization uses open source has shifted to how , and what it might mean for your organization . " In fact , OSS was discovered in 98 percent of audits , with a shocking number of those audits containing copy-left licenses . <p> The report exposes the challenge of unknown and unsupported OSS use , and offers a remedy to organizations seeking commercial-grade support for OSS . Rogue Wave employs some of the best and most active open source experts ; contributing to , setting up , using , and debugging hundreds of OSS packages , and digging into source code on a daily basis . The Rogue Wave Open Source Support Report exposes real data to confidently use and manage open source . <h> About Rogue Wave Software <p> Rogue Wave helps thousands of global enterprise customers tackle the hardest and most complex issues in building , connecting , and securing applications @ @ @ @ @ @ @ @ @ @ , and support have been used across financial services , technology , healthcare , government , entertainment , and manufacturing , to deliver value and reduce risk . From API management , web and mobile , embeddable analytics , static and dynamic analysis to open source support , we have the software essentials to innovate with confidence . 
@@75677882 @4377882/ <p> Class RWDBOSql is an encapsulation of a database-specific SQL statement with all its input and output bindings . Program variables may be bound to placeholders in your statement using operator &lt;&lt; , and shifting in RWDBAbstractBuffers , such as RWDBTBuffers , which describe input data . Class RWDBOSql also contains a vector of RWDBMultiRows , each of which specifies the output bindings for a single result set . You can use the RWDBOSqloperator to obtain a reference to an RWDBMultiRow , and then use the **28;9871;TOOLONG to provide output bindings for the RWDBMultiRow . <p> When executing an RWDBOSql that produces results , there are two options for specifying the output RWDBAbstractBuffers for those results : <p> If the format of the results is known when creating the query , RWDBOSql may gain performance if output RWDBAbstractBuffers are bound to the result set before invoking execute() . However , binding output RWDBAbstractBuffers before invoking execute() is not required . <p> If the existence or format of the results is unknown--for example , if you are entering ad hoc queries--you would do the following : <p> Execute the RWDBOSql @ @ @ @ @ @ @ @ @ @ discover the number and size of the result sets <p> Bind RWDBAbstractBuffers , such as RWDBTBuffer instances , to the result sets using the RWDBOSqloperator and the **28;9901;TOOLONG <p> Invoke fetch() to begin fetching results . <p> RWDBOSql is designed around the Interface/Implementation paradigm . An RWDBInserter instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . <p> In this example , we use an RWDBOSql to execute a query with a placeholder . The input value and output storage are both specified using RWDBTBuffer . Please note that Oracle-specific placeholder syntax is used here ; check your access library guide or vendor documentation for appropriate SQL and placeholder syntax . <p> Default constructor . Creates an RWDBOSql object with statement type RWDBOSql : : NonQuery and no statement set . Its error handler is set to the error handler of the static RWDBManager . <p> RWDBOSql ( const RWCString &amp; sql , StatementType type = NonQuery ) ; <p> Creates an RWDBOSql with SQL statement set to sql , and statement type set to type . The @ @ @ @ @ @ @ @ @ @ query inside the statement . This information is used to help optimize binding and performance . Error handler for the created object is set to the error handler of the static RWDBManager , as in the default constructor . <p> RWDBOSql ( const RWDBOSql&amp; osql ) ; <p> Creates an RWDBOSql whose implementation is shared with osql . All attributes are shared , including statement , status , and bindings . <p> Cleans up the RWDBOSql implementation if it is the last RWDBOSql to reference that implementation , consistent with standard Interface/Implementation destructor behavior . Blocks if an asynchronous operation has not completed . If blocking is not desired , call to cancel it before the RWDBOSql is destroyed . <p> Assignment operator . Causes self 's current implementation to be discarded , including its SQL statement , bindings , state , status , and any other attributes . Self will share osql 's implementation . <p> RWDBOSql&amp; operator&lt;&lt; ( RWDBAbstractBuffer&amp; input ) ; <p> Sets an input binding on the current binding location . Advances the current binding location internally by one , so that the next call to @ @ @ @ @ @ @ @ @ @ to self . <p> RWDBMultiRow&amp; operator ( sizet index ) ; <p> Returns a reference to the RWDBMultiRow that stores all the output bindings for the indexth result set . <p> Attempts to cancel the pending result set , or current statement execution . The exact definition is vendor-dependent ; see your access library guide for details . <p> NOTE:This call is only valid after the RWDBOSql is executed . Calling cancel() before execute() invalidates the RWDBOSql , setting an RWDBStatus : : invalidUsage error , and calling any associated error handler . <p> RWDBStatus : : errorHandler errorHandler() const ; <p> Returns the error handler attached to self . <p> void **27;9931;TOOLONG cn , sizet blkSz=0 ) ; <p> Executes the SQL statement on cn . If blkSz is nonzero , blkSz rows are sent to the server from the input bindings . If blkSz is zero , the number of rows sent is determined by the minimum of the lengths of all input-bound buffers . <p> RWDBOSql&amp; fetch() ; <p> Fetches the current result set into the output bindings for that result set , and returns a reference @ @ @ @ @ @ @ @ @ @ fetched , no rows are fetched , and the next call to fetch() moves to the next result set and fetches . The member function fetch() returns at most n rows at a time , where n is the minimum of the lengths of the output-bound RWDBTBuffers for the current result set . After calling fetch() , use rowsFetched() to determine how many rows were fetched . <p> NOTE:This call is only valid after the RWDBOSql is executed . Calling fetch() before execute() invalidates the RWDBOSql , setting an RWDBStatus : : invalidUsage error , and calling any associated error handler . <p> RWDBOSql&amp; fetchReturnParams() ; <p> Fetches any in/out or out-type stored procedure parameters into the bound buffers for those parameters . Returns a reference to self . <p> RWBoolean hasResult() const ; <p> Returns TRUE if there is data waiting to be fetched . Also returns TRUE if all the data has been fetched , but the end-of-fetch is not yet encountered . If no attempt is made to read past the end of the result set that was fetched , hasResult() still returns TRUE . <p> RWBoolean @ @ @ @ @ @ @ @ @ @ in ready state , indicating that accessing the object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if the RWDBOSql is not in an error condition . This call blocks if the last operation on this RWDBOSql is not yet completed . <p> RWDBValue returnValue() const ; <p> Obtains and returns the stored procedure return value , if one exists . If no return value exists , or a stored procedure has not been executed , returns an RWDBValue whose type is RWDBValue : : NoType . <p> long rowCount() const ; <p> Returns the number of rows affected by the last execute() , if available . Returns -1 if this information is unavailable . <p> long rowsFetched() const ; <p> Returns the number of rows fetched in the last fetch() operation . Blocks if the fetch() was asynchronous and has not yet completed . Returns -1 if no fetch was performed . <p> RWDBSchema schema() const ; <p> Returns the schema for the current result set , if the statement is executed and has results . Returns @ @ @ @ @ @ @ @ @ @ the format of results are unknown , as is the case when using ad hoc queries . <p> void **26;9960;TOOLONG : : ErrorHandler err ) ; <p> Installs err as self 's error handler . <p> RWCString statement() const ; <p> Returns the current SQL statement by value . If no statement is set , returns an empty string ( " " ) . 
@@75677884 @4377884/ <h> Planning Governance - Build the Right Services <p> Planning is an important part of both Enterprise API Management and Integrated SOA Governance solutions that allows companies to build to plan and build to priority , modeling current and desired architectures and identifying and prioritizing candidate services . Planning solutions maximize the efficiency of investment in APIs and SOA , solidifying the role of existing platforms as foundation service providers . <p> I.T . has always struggled with balancing long term planning with addressing the immediate and short term needs of the business , in most cases the short term requirements take precedent over long range planning . When this is applied to enterprise architecture , organizations end up with a bunch of services that deliver minimal business value , instead of their goal of SOA . <p> Planning Governance allows organizations to identify potential services in a planned and managed community including enterprise architects , business analysts and portfolio managers . When utilizing planning governance , services can be proactively built to plan rather than simply reacting and building single use services . This approach reduces the risks @ @ @ @ @ @ @ @ @ @ chaotic service sprawl . <p> Planning solutions include the identification analysis and modeling of candidate APIs and services , policies , profiles , processes and information . An effective planning governance product manages an organizations API and SOA portfolios while examining existing and planned applications and determining which capabilities should be exposed as services , and where applications benefit from consuming shared services . <p> Planning solutions require integration with a wide range of existing enterprise repositories , application portfolio management , and enterprise architecture planning solutions , to harvest current and desired architectures . The output from the Planning Governance process is a set of candidate services that feed into the Lifecycle Governance process , and candidate policies feeding into the Policy Governance process . 
@@75677885 @4377885/ <p> RWDBMemTable is a table of data that resides in program memory . After construction , an RWDBMemTable is no longer associated with a table in the database . An application can modify the data in an RWDBMemTable , but the changes are not propagated back to the database . <p> RWDBMemTable is designed around the Interface/Implementation paradigm . An RWDBMemTable instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . <p> Because an RWDBMemTable resides in memory , it is possible to provide random access to its data . DBTools.h++ provides operator for indexing on RWDBMemTable , the result of which is a reference to RWDBRow . RWDBRow inherits indexing operator from the Tools.h++ class RWOrdered . The net result is the ability to access RWDBMemTable data with double indexing , as if it were a two-dimensional C++ array . <p> There are limitations to using RWDBMemTable , as it lacks some of the functionality of an RWDBTable . The differences in functionality come from the lack of a server in memory for selecting , deleting @ @ @ @ @ @ @ @ @ @ . This means that selectors , cursors , deleters , inserters , and updaters can not be created using memory tables . Instead , the actual table in the database must be referenced . <p> However , RWDBReader may be produced from RWDBMemTable , allowing access to each row within the memory table , rather than using the overloaded operators for indexing . <p> It should also be noted that since memory tables exist within memory , the normal data definition language ( DDL ) constructs that are associated with tables are also dysfunctional , and return invalid results . These include grant , revoke , addColumn , dropColumn , and so on . <p> Constructs an empty RWDBMemTable with given capacity . A capacity of zero means there is no limit on the number of rows to be stored . <p> RWDBMemTable ( const RWDBTable&amp; table , sizet capacity = 0 ) ; <p> Uses a default database connection to construct an RWDBMemTable and populate it with a maximum of capacity rows from table . A capacity of zero means there is no limit on the number of rows @ @ @ @ @ @ @ @ @ @ = 0 ) ; <p> Uses the supplied reader to construct an RWDBMemTable , populating it with a maximum of capacity rows copied from reader . A capacity of zero means there is no limit on the number of rows to be stored . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until the mutex is released . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWDBColumn column ( const RWCString&amp; name ) const ; <p> Inherited from RWDBTable . Returns a deep copy of the first RWDBColumn in self 's schema whose name matches the given name . The returned RWDBColumn is associated with self , that is , the table() method of the returned RWDBColumn returns this table . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . <p> RWDBColumn @ @ @ @ @ @ @ @ @ @ RWDBTable . Returns a deep copy of the RWDBColumn in self 's schema at the given index . The returned RWDBColumn is associated with self , that is , the table() method of the returned RWDBColumn returns this table . If index is out of range , the function returns an RWDBColumn with status RWDBStatus : : invalidPosition . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . <p> Inherited from RWDBTable . Returns a deep copy of the first RWDBColumn in self 's schema whose name matches the given name , according to caseCompare . The RWDBColumn returned is associated with self , that is , the table()method of the returned RWDBColumn returns this table . If no match is found , the function returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . A deep copy of the column from self at the specified index is made . If index is out of range , the function returns @ @ @ @ @ @ @ @ @ @ <p> RWDBDatabase database() const ; <p> Inherited from RWDBTable . An RWDBMemTable is not closely associated with a database , so this method always returns an RWDBDatabase with a status of RWDBStatus : : notInitialized. 
@@75677886 @4377886/ <h> 11.3 Data Formatting <p> Programmers working with DBTools.h++ have several classes available for datatype normalization . ( See Chapter 6 ) . These classes provide data structures to hold complex types , yet allow them to be treated like simple types . These classes include : <p> The data that these classes hold are locale sensitive ; in other words , legal input and output of these types look different depending on the locale in effect . The issue here is input and output of the data from the point of view of the user of an application . DBTools.h++ automatically formats the data when sending to and retrieving from a database . The application programmer must be concerned only with the raw form of the data as it comes into the program or goes out to a program user . <p> The three classes all have techniques associated with them to allow input and output from various locales . The following section outlines the techniques used in each of the classes . <p> The RWDBDateTime class encapsulates a point in time with a range from years down @ @ @ @ @ @ @ @ @ @ data in and out of DATETIME columns in databases . <p> Once an instance of RWDBDateTime is initialized , it can be used like any other datatype with DBTools.h++ . DBTools.h++ takes care of any formatting or binding automatically in a locale neutral manner . The application programmer does not have to address localization issues in regards to getting this datatype in and out of the database . <p> However , getting a valid RWDBDateTime value from users in various locales is tricky . The example below demonstrates how to take a string representing a localized date time value and convert it into an RWDBDateTime instance . Following the conversion , the RWDBDateTime is streamed to standard output to demonstrate output in various locales . <p> DBTools.h++ does not include an operator&lt;&lt; for ostreams and instances of RWDBDateTime . The following example shows how to make an operator&lt;&lt; that outputs an RWDBDateTime correctly with whatever locale was imbued in the ostream . <p> RWDate is a class from Tools.h++ that can also be used as a database datatype . DBTools.h++ can handle any formatting issues without intervention when getting this @ @ @ @ @ @ @ @ @ @ can for RWDate . Of course , the trick again is getting localized information from a user to initialize an instance of RWDate . Tools.h++ gives several options . <p> First , there is a constructor that takes a reference to an istream and a reference to an RWLocale . This allows direct initialization of the RWDate instance from the istream . <p> A second technique is shown in the example below . A string initialized with a representation of a localized date is created and then converted to an RWDate with the assistance of an RWLocale reference . <p> RWDecimalPortable is used to hold monetary values . For this , it is more accurate than float or double . Float and double introduce errors in monetary values because binary is not entirely accurate for fractional base 10 values . RWDecimalPortable uses the less efficient but perfectly accurate ASCII method . <p> When an RWDecimalPortable instance is given to DBTools.h++ to be inserted into a table , DBTools.h++ handles any formatting required by the server automatically . You do n't have to worry about that . However , you do @ @ @ @ @ @ @ @ @ @ <p> Unfortunately , there is no constructor for RWDecimalPortable that takes an RWLocale as a parameter . When an RWDecimalPortable is initialized from a string , it always assumes that the string is formatted in the style required by the current global locale . <p> At times application programmers are faced with input from users in awkward formats . A simple formatting technique , such as using a thousand separator , adds greatly to the readability of data by people . Unfortunately , software rarely allows the use of thousand separators . This is probably because the tools for parsing such input have been unavailable , and programmers have not acutely felt a need to create them . <p> The class RWLocale from the Tools.h++ library provides a method for converting strings that represent numbers into the basic long or double datatypes . The strings can even contain the national equivalents of the thousand and decimal separators . The following example demonstrates the technique : 
@@75677888 @4377888/ <h> CodeDynamics <h> Pinpoint and replay run-time issues for faster resolution <p> Examines complex C and C++ applications at execution time to help identify bugs , memory issues , and crashes with CodeDynamics . Developers spend hours , days , or even weeks understanding what happens in large , long-running programs . CodeDynamics quickly identifies the cause of the crash , allowing complete control over breakpoints and stepping . <p> Built for multithreaded applications , CodeDynamics gives unparalleled visibility into running programs , unmatched control over thread states , and great views to aid analysis . <h> CodeDynamics highlights <p> Hear an introduction to CodeDynamics . Learn about the main features of CodeDynamics , and see a brief walk-through of the modern , and easy-to-use interface . <h> How can CodeDynamics help ? <p> Scenario <p> CodeDynamics helps <p> An application outputs an incorrect value . To determine what went wrong you typically have to restart the whole debugging session to step into the routine . <p> Using our unique ReplayEngine capability , during the same debugging session you can easily step back to the point just before a @ @ @ @ @ @ @ @ @ @ determine the cause of the error , and exactly where it occurred . <p> When an application incorrectly writes memory it can overwrite the stack frame and crash the program . This will typically yield an invalid stack trace , giving the developer no clue where the application actually crashed . <p> Step backwards at the point of the crash to see the stack trace and reconstruct and reveal the point of the crash as well as the data that caused it to crash . <p> Setting breakpoints at the thread level , controlling individual threads , and switching between the threads to understand their states is cumbersome , time-consuming , and does not allow enough granular control . <p> Our user interface gives you a clear view of the running threads in the application , their current state , and where they may be stopped in the code . You can easily switch the analysis context from one thread to another by simply diving in on a new thread . You can set breakpoints down to the individual thread level for fine-grained control over the execution of a thread @ @ @ @ @ @ @ @ @ @ a per thread basis . <p> You want to see STL container classes such as vector , list , map , and sets as conceptual representations of the data versus their low-level implementations . <p> Automatically detect STL and Boost containers to transform them into an easily understood conceptual view . For example , with CodeDynamics a linked list will be shown as a simple array of the values rather than the underlying linked node implementation . <p> Start dynamic analysis on a target executable or a running executable . IDE debuggers such as Eclipse or NetBeans require the overhead of maintaining a project and configuring the debug launch of the target executable . <p> Quickly start dynamic analysis on a new target , or attach to a running executable. 
@@75677889 @4377889/ <p> Class RWDlistCollectables represents a group of ordered items , not accessible by an external key . Duplicates are allowed . The ordering of elements is determined externally , generally by the order of insertion and removal . An object stored by RWDlistCollectables must inherit abstract base class RWCollectable . <p> Class RWDlistCollectables is implemented as a doubly-linked list , which allows for efficient insertion and removal , as well as for movement in either direction . <p> Redefined from class RWSequenceable . The index must be between zero and the number of items in the collection less one , or an exception of type RWBoundsErr will occur . Note that for a linked list , these functions must traverse all the links , making them not particularly efficient . <p> Redefined from class RWSequenceable . Returns the index of the first item that isEqual to the item pointed to by c , or RWNPOS if there is no such index . <p> virtual RWCollectable* insert ( RWCollectable* c ) ; <p> Redefined from class RWCollection . Adds the item to the end of the collection and returns it @ @ @ @ @ @ @ @ @ @ void insertAt ( sizet indx , RWCollectable* e ) ; <p> Redefined from class RWSequenceable . Adds a new item to the collection at position indx . The item previously at position i is moved to i+1 , etc . The index indx must be between 0 and the number of items in the collection , or an exception of type RWBoundsErr will occur . 
@@75677890 @4377890/ <p> There is a single , global RWDBManager in charge of producing RWDBDatabases typed according to the application 's request . It mediates access to database servers , abstracting details of access to vendor-supplied libraries , including any dynamic loading and linking . The RWDBManager , through its database() method , is responsible for filling requests for database implementations of a particular type . To do so , it maintains a set of database types for which it is able to produce an implementation . <p> Associated with each database type is a method that produces the implementation . This method may reside in a dynamically-linked library , or may be statically linked with a specialized object . In the former case , the method is identified by a conventional name , rwdbNewDatabaseImp , with any ambiguity alleviated by the containing library . In the latter case , each method must be uniquely named , as in rwdbNewSybaseDatabaseImp , for example . The association between method names and database types is made at link time via static initialization . <p> When presented with a request for a particular type @ @ @ @ @ @ @ @ @ @ known implementations . If no entry is found , and the operating environment supports dynamic linking , a search is made for a dynamically-linked library ( DLL ) whose name matches the requested type . If a DLL is found , it is loaded , the conventionally-named method is located , and the association is added to the set of implementations of the RWDBManager . Once an entry is located , its method is invoked to obtain an implementation of the requested type , a connection is established , and the result is returned to the caller . If no entry is found , the object returned to the caller has a status of RWDBStatus : : notFound . <p> Produces an RWDBDatabase . The first argument let 's DBTools.h++ identify the kind of database being requested . The remaining arguments are used to establish a session with the requested database server . Since the details of logging into a database vary widely among vendors , the actual values supplied for the various parameters vary according to accessLib . Your DBTools.h++ access library guide explains the values you must supply to @ @ @ @ @ @ @ @ @ @ : ErrorHandler errorHandler() const ; <p> Retrieves the error handler currently installed in the RWDBManager , if any . <p> Installs handler as the error handler for the RWDBManager . The supplied handler is inherited by all RWDBDatabase instances created by the RWDBManager . By default , the RWDBManager error handler does nothing ; this method overrides the default . The errorHandler is declared as a typedef within the scope of RWDBStatus : <p> typedef void ( *ErrorHandler ) ( const RWDBStatus&amp; ) ; <p> static RWCString version() ; <p> Returns a string that identifies the version of the DBTools.h++ core library in which self resides . Note : this method identifies the version of the DBTools.h++core library , while RWDBDatabase : : version() identifies the version of a DBTools.h++access library . 
@@75677891 @4377891/ <p> Returns TRUE if the iterator is at the start of the list , FALSE otherwise ; <p> RWBoolean atLast() const ; <p> Returns TRUE if the iterator is at the end of the list , FALSE otherwise ; <p> type* findNext ( yourTester t , const type* d ) ; <p> Moves the iterator to the next item for which the function pointed to by t finds a match with d and returns it . Returns nil if no match is found , in which case the position of the iterator will be undefined . <p> type* findNextReference ( const type* e ) ; <p> Moves the iterator to the next item with the address e and returns it . Returns nil if no match is found , in which case the position of the iterator will be undefined . <p> type* insertAfterPoint ( type* a ) ; <p> Adds item a after the current iterator position and return the item . The position of the iterator is left unchanged . <p> type* key() const ; <p> Returns the item at the current iterator position . <p> type* @ @ @ @ @ @ @ @ @ @ current cursor position . Afterwards , the iterator will be positioned at the previous item in the list . In a singly-linked list , this function is an inefficient operation because the entire list must be traversed , looking for the link before the link to be removed . <p> type* removeNext ( yourTester t , const type* d ) ; <p> Moves the iterator to the next item for which the function pointed to by t finds a " match " with d and removes and returns it . Returns nil if no match is found , in which case the position of the iterator will be undefined . <p> type* **25;10018;TOOLONG type* e ) ; <p> Moves the iterator to the next item with the address e and removes and returns it . Returns nil if no match is found , in which case the position of the iterator will be undefined . 
@@75677892 @4377892/ 50231 @qwx670231 <p> Timer class . <p> Library : display <p> Rogue Wave Views has an internal mechanism for implementing timers . The internal mechanism is hidden and system-dependent . It is based on the IlvTimer class . The purpose of a timer is to call a function repeatedly , once every given time period . To call a function this way , create an IlvTimer instance and call its member function run . The timer object calls its member function doIt each time the period expires . Timers are based on the time-out mechanisms of the display system . The timer automatically repeats the call to doIt after every period if the timer is not specified to run only once . The IlvTimer class can be used in two different cases : <p> The first case supposes you have a user-defined function that must match the IlvTimerProc type . In this case , you simply instantiate an IlvTimer object , specifying this function , and an argument the function can use . <p> The second case uses a derived subclass of IlvTimer with overloading of the member function @ @ @ @ @ @ @ @ @ @ : : doIt <p> ( <p> ) <p> virtual <p> Calls the internal function set in the constructor or by setProc . <p> This is the virtual member function that is called when the timer is running . Its default implementation consists of calling the internal function that you may have set in the constructor call or in a call to the member function setProc . You can also overload this member function to define your own implementation . <p> If the " run once " state is set to IlTrue , the timer will not be rearmed when called . This means that it will run only once . However , after the first call to doIt is complete-and you do not need the timer anymore-you need to delete it . 
@@75677893 @4377893/ <p> Class RWGSlist(type) represents a group of ordered elements of type type , not accessible by an external key . Duplicates are allowed . This class is implemented as a singly-linked list . Objects of type RWGSlist(type) are declared with macros defined in the standard C++ header file &lt;generic.h&gt; . <p> In order to find a particular item within the collection , a user-provided global " tester " function is required to test for a " match , " definable in any consistent way . This function should have prototype : <p> RWBoolean yourTesterFunction ( const type* c , const void* d ) ; <p> The argument c is a candidate within the collection to be tested for a match . The argument d is for your convenience and will be passed to yourTesterFunction() . The function should return TRUE if a " match " is found between c and d . <p> Adds an item to the end of the collection and returns it . Returns nil if the insertion was unsuccessful . <p> void apply ( void ( *ap ) ( type* , void* ) , void* @ @ @ @ @ @ @ @ @ @ in order , from first to last , calling the user-provided function pointed to by ap for each item . This function should have prototype : <p> void yourApplyFunction ( type* c , void* ) ; <p> and can perform any operation on the object at address c . The last argument is useful for passing data to the apply function . <p> type*&amp; at ( sizet i ) ; const type* at ( sizet i ) const ; <p> Returns a pointer to the ith item in the collection . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type TOOLINDEX will be thrown . <p> void clear() ; <p> Removes all items in the collection . <p> RWBoolean contains ( yourTester t , const void* d ) const ; <p> Returns TRUE if the collection contains an item for which the user-defined function pointed to by t finds a match with d . <p> RWBoolean containsReference ( const type* e @ @ @ @ @ @ @ @ @ @ an item with the address e . <p> sizet entries() const ; <p> Returns the number of items in the collection . <p> type* find ( yourTester t , const void* d ) const ; <p> Returns the first item in the collection for which the user-provided function pointed to by t finds a match with d , or nil if no item is found . <p> type* findReference ( const type* e ) const ; <p> Returns the first item in the collection with the address e , or nil if no item is found . <p> type* first() const ; <p> Returns the first item of the collection . <p> type* get() ; <p> Returns and removes the first item of the collection . <p> type* insert ( type* e ) ; <p> Adds an item to the end of the collection and returns it . Returns nil if the insertion was unsuccessful . <p> void insertAt ( sizet indx , type* e ) ; <p> Adds a new item to the collection at position indx . The item previously at position i is moved to i+1 , @ @ @ @ @ @ @ @ @ @ the number of items in the collection , or an exception of type TOOLINDEX will be thrown . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if the collection is empty , otherwise FALSE . <p> type* last() const ; <p> Returns the last item of the collection . <p> sizet occurrencesOf ( yourTester t , const void* d ) const ; <p> Returns the number of occurrences in the collection for which the user-provided function pointed to by t finds a match with d . <p> sizet **28;10045;TOOLONG type* e ) const ; <p> Returns the number of items in the collection with the address e . <p> type* prepend ( const type* a ) ; <p> Adds an item to the beginning of the collection and returns it . Returns nil if the insertion was unsuccessful . <p> type* remove ( yourTester t , const void* d ) ; <p> Removes and returns the first item from the collection for which the user-provided function pointed to by t finds a match with d , or returns nil if no item is found . <p> type* removeReference ( const @ @ @ @ @ @ @ @ @ @ item from the collection with the address e , or returns nil if no item is found . 
@@75677894 @4377894/ <h> 4.8 Define and Map Servlets <p> The servlet element of a web.xml file defines a servlet instance . The servlet element always contains a servlet-name element and a servlet-class element , and may also contain initialization parameters . <p> The servlet-name element declares a name for this particular servlet instance . Each servlet instance in a context must have a unique name . However , the name is only used to associate URL mappings with this instance , and need not correspond to the name of the servlet class or the URL of the servlet . <p> The servlet-class element tells the container how to construct an instance of the servlet class . There are two components to this element . The element contains the base name of the shared library ( . dll or . so ) that contains the servlet , and the name of the function that the container uses to load the servlet . The components of the element are separated by a single period . For example , the element **26;10075;TOOLONG contains the base name status and the function name createStatusServlet . <p> @ @ @ @ @ @ @ @ @ @ of the library without the platform-specific prefix ( if any ) , without the 12d or 15d suffix , and without the platform-specific extension . See Appendix C for information on library name mappings for each platform that HydraExpress supports . <p> The function name in the servlet-class element must match the function name defined in the servlet implementation . The RWSFDEFINESERVLET macro in the implementation source code defines the function name , as described in Section 6.4 . Note that the name of this function must be a legal C++ identifier . <p> The servlet element below defines a servlet named HelloWorld . The servlet shared library has the base name rwsfservletexample , and the container calls the function createHelloWorld to load the servlet instance . Notice that the name of the servlet instance does not need to correspond to the class name . <p> To add another instance of the same servlet class to the container , use another servlet element with a different servlet-name . The web.xml file fragment below defines two different instances of the same servlet class : <p> Each servlet element may contain any @ @ @ @ @ @ @ @ @ @ to the servlet in much the same way that command line parameters are passed to a program , so the exact parameter names and values required depend on the individual servlet . ( See below for an example of the corresponding servlet code . ) The example below shows a web.xml file fragment that defines two different instances of the same servlet class . <p> A servlet element only defines an instance of a servlet . For the container to forward requests to the servlet , the servlet must be mapped to one or more URLs or called by name from another servlet or a filter . <p> The servlet-mapping element associates a URL pattern to a servlet instance . The servlet-mapping always contains a servlet-name element and a url-pattern element . <p> The servlet-name element must match a servlet-name defined in a servlet element elsewhere in the web.xml file . Since a servlet container may have multiple instances of the same servlet running , the container uses the servlet-name to associate a mapping with a servlet . <p> The url-pattern element contains a pattern that the container uses to @ @ @ @ @ @ @ @ @ @ given servlet . In simple terms , the url-pattern determines the location of the servlet within the context . The url-pattern element can also contain more sophisticated mappings , as described in Section 4.4 , " URL Patterns . " <p> For example , the web.xml fragment below maps the URL /status/* to a servlet named getStatus . If the servlet is defined in the examples context of a container at http : //example.com/ , then this element tells the container that the getStatus servlet should receive requests for URLs that start with http : **29;10103;TOOLONG . <p> Although different patterns can map to the same servlet , the same pattern can not map to two different servlets . If the same url-pattern appears more than once within a web.xml file , the HydraExpress Agent makes no guarantees about which servlet receives a request . Section 4.4 , " URL Patterns , " describes the url-pattern element in detail . <p> Servlets are inherently multithreaded . However , the servlet container supports a simple mechanism for serializing access to a particular servlet . If a servlet element contains the attribute @ @ @ @ @ @ @ @ @ @ thread at a time to enter the servlet . If a new request arrives for the servlet while a thread is active in the servlet , the new request waits until the active thread leaves the servlet . <p> The servlet element below specifies that only one thread at a time may enter the servletInfo instance . <p> The Rogue Wave name and logo are registered trademarks of Rogue Wave Software , and HydraExpress is a trademark of Rogue Wave Software . All other trademarks are the property of their respective owners.Contact Rogue Wave about documentation or support issues . 
@@75677895 @4377895/ <h> 2.11 Transaction Processing <p> When connecting to Oracle 10g server , RWDBConnection : : isolation() returns the isolation level of the server . When connecting to Oracle11g server , RWDBConnection : : isolation() returns the isolation level of the connection to the server rather than the server 's default isolation level . <p> Note : To determine the isolation level of an Oracle 10g server , the database user must have permissions to read V$PARAMETER system table . Typically , this is only available to the system account , SYS ; however , access can be safely granted to other users by running UTLMONITOR.SQL , which is provided by Oracle . For more information , see the entry for V$PARAMETER in the Oracle 10g Server Administrator 's Guide . <p> Note : To determine the isolation level of a connection to an Oracle11g server , the system table V$SESOPTIMIZERENV is read . <p> Table 5 shows the mapping between the Oracle 10g server configuration and the isolation levels returned : <p> Please note that the Oracle server initialization parameter rowlocking is obsolete in Oracle 10g . Hence , @ @ @ @ @ @ @ @ @ @ in front of its name , and reporting a warning in the log when the server is started . Please see Oracle10g documentation for more information . <p> Table 6 shows the mapping between the Oracle11g session parameter and the isolation levels returned : <p> Beginning with Oracle11g , a new column , **25;10134;TOOLONG , in the dynamic performance view V$SESOPTIMIZERENV is available to determine the transaction level of a connection to the Oracle server . <p> These methods have straightforward implementations that correspond to OCI calls like OCITransCommit() , OCITransRollback() , and SQL statements . <p> An application can add the DB Interface Module transaction methods to its code to take explicit control of its transaction blocks . However , transactions may not be nested as this feature is not supported by Oracle . <p> NOTE -- Oracle does not support nested transactions . <p> The savepoint feature is supported . The savepoint feature allows a current transaction to be partially rolled back to a marked point . The following example demonstrates the use of the savepoint feature and the other transaction processing methods of the DB Interface Module @ @ @ @ @ @ @ @ @ @ c int ) with no rows in it . RWDBInserter ins= myTable.inserter() ; cn1.beginTransaction ( ) ; // Begin transaction .. ( ins &lt;&lt; 1 ) . execute(cn1) ; // First insertion ... cn1.setSavepoint ( " svp1 " ) ; // Save first insertion ( ins &lt;&lt; 2 ) . execute(cn1) ; // Second insertion ( ins &lt;&lt; 3 ) . execute(cn1) ; // Third insertion cn1.rollbackTransaction ( " svp1 " ) ; // Roll back second and // third insertions cn1.commitTransaction() ; // Commit transaction on // part that is not rolled back // The above program results in myTable holding one row of data . // Its value is 1 . 
@@75677898 @4377898/ <p> Returns an RWDBJoinExpr that represents an encapsulation of the LEFT OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in outer joins , the generated SQL adds precedence to jexpr such that jexpr is evaluated first before the table is joined . <p> Returns an RWDBJoinExpr that represents an encapsulation of the RIGHT OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in outer joins , the generated SQL adds precedence to jexpr , such that jexpr is evaluated first before the table is joined . <p> Returns an RWDBJoinExpr that represents an encapsulation of the FULL OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in outer joins , the generated SQL adds precedence to jexpr , such that jexpr is evaluated first before the table is joined . <p> Returns an RWDBJoinExpr that represents an encapsulation of the NATURAL LEFT OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in @ @ @ @ @ @ @ @ @ @ , such that jexpr is evaluated first before the table is joined . <p> Returns an RWDBJoinExpr that represents an encapsulation of the NATURAL RIGHT OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in outer joins , the generated SQL adds precedence to jexpr , such that jexpr is evaluated first before the table is joined . <p> Returns an RWDBJoinExpr that represents an encapsulation of the FULL OUTER JOIN SQL phrase between a table and an outer join expression . For databases that support precedence in outer joins , the generated SQL adds precedence to jexpr , such that jexpr is evaluated first before the table is joined . 
@@75677899 @4377899/ <p> RWZone is an abstract base class . It defines an interface for time zone issues such as whether or not daylight-saving time is in use , the names and offsets from GMT ( also known as UTC ) for both standard and daylight-saving times , and the start and stop dates for daylight-saving time , if used . <p> Note that because it is an abstract base class , there is no way to actually enforce these goals -- the description here is merely the model of how a class derived from RWZone should act . <p> Most programs interact with RWZone only by passing an RWZone reference to an RWTime or RWDate member function that expects one . <p> RWZoneSimple is an implementation of the abstract RWZone interface sufficient to represent U.S. daylight-saving time rules . Three instances of RWZoneSimple are initialized from the global environment at program startup to represent local , standard , and universal time . They are available via calls to the static member functions RWZone : : local() , RWZone : : standard() , and RWZone : : utc() , respectively . @ @ @ @ @ @ @ @ @ @ number of seconds west of GMT for standard time in this zone . The number is negative for zones east of Greenwich , England . <p> virtual int altZoneOffset() const = 0 ; <p> Returns the number of seconds west of GMT for daylight-saving time in this zone . <p> virtual RWBoolean daylightObserved() const = 0 ; <p> Returns TRUE if daylight-saving time is observed for this zone . <p> virtual RWBoolean isDaylight ( const struct tm* tspec ) const = 0 ; <p> Returns TRUE if the time and date represented in the struct tm argument is in the range of daylight-saving time for this zone . The elements of the tm argument must all be self-consistent ; in particular , the tmwday member must agree with the tmyear , tmmon , and tmday members . <p> Return with the struct tm argument set to the local time that daylight-saving time begins , or ends , for the year indicated by the tmyear member passed in . If daylight-saving time is not observed , the struct tm members are all set to a negative value . Note that in @ @ @ @ @ @ @ @ @ @ date than it begins . <p> Return the name of , respectively , the standard and daylight-saving time zones represented , such as " PST " and " PDT " . Note that the current date and time have no effect on the return values of these functions . <p> Returns a reference to an RWZone representing local time . By default this will be an instance of RWZoneSimple created with offsets and zone names from the operating system , with U.S. rules for daylight-saving time if observed . This is used as the default argument value for RWDate and RWTime functions that take an RWZone . <p> static const RWZone&amp; os() ; <p> Determines the current daylight saving rule from the underlying operating system . You can set a daylight saving rule for the current year by instantiating RWZone : : local ( &amp;RWZone : : os() ) . <p> static const RWZone&amp; standard() ; <p> Returns a reference to an RWZone representing standard local time , with no daylight-saving time corrections . By default this is an instance of RWZoneSimple with offset and zone name from the operating @ @ @ @ @ @ @ @ @ @ the other functions above to be set . Each returns the previous value . <p> static constRWDaylightRule* dstRule ( DstRule rule = NoAm ) ; <p> Returns one of the built-in daylight-saving time rules according to rule . Function dstRule() is provided for convenience in constructing RWZoneSimple instances for time zones in which common daylight-saving time rules are obeyed . Currently two such rule systems are provided , NoAm for the U.S.A. and Canada , and WeEu for most of Western Europe ( excluding the U.K. ) . See RWZoneSimple for more details . If DstRuleNoDST is given , then 0 is returned . The result of calling dstRule() is normally passed to the RWZoneSimple constructor . 
@@75677900 @4377900/ <p> Python is a popular language for deep learning but debugging calls to existing C/C++ code in shared libraries can be extremely challenging . Untangling the confusing maze of library calls , data translations , and linked-in CUDA code can be convoluted and time consuming , as neither Python nor C/C++ debuggers provide a comprehensive view across the languages . <p> In this video , recorded at GPU Technology Conference 2017 , we look at how Python-C/C++ transformations combined with a multithreaded , multiprocess debugger helps you understand what 's going on within your deep learning code . <p> Akana SOLA is a powerful , complete proven tool that makes it easy to expose mainframe artifacts such as programs and data as fully governance secure APIs , or it can enable those mainframe artifacts to easily access external APIs . <p> In this video , well introduce you to the outbound feature in SOLA . This feature allows you to easily make your mainframe programs be able to go out and access , as a client , an external API . <p> In this video , you 'll learn how @ @ @ @ @ @ @ @ @ @ halt the execution of a program when the contents of a memory location change . This feature can save you a lot of time tracking down problems in your code . <p> In this video , you 'll learn how to use Watchpoints in CodeDynamics . Watchpoints are used to halt the execution of a program when the contents of a memory location change . This feature can save you a lot of time tracking down problems in your code . <p> Klocwork SmartRank is a defect recommendation engine which guides developers to rapidly find and correct the simplest , most important defects first . With SmartRank , prioritize and tackle detected issues in the order that gives you the most value . <p> It starts at the developer 's desktop . It 's here where code is written , tested , reviewed , and written again . Finding problems here , at the earliest possible point before the build , means less testing later on and fewer downstream impacts to cost and schedule . Klocwork puts static code analysis and continuous integration , including support for Jenkins and TeamCity @ @ @ @ @ @ @ @ @ @ , you will discover the multiple ways to easily navigate source code and learn how the code is constructed . With CodeDynamics , source code can be examined by using the files/function search object , " diving " in on a function , or searching directly in the file . <p> Learn more about additional features of CodeDynamics by viewing the video series which highlights the dynamic analysis and debugging features of the tool . 
@@75677901 @4377901/ <h> IMSL Fortran Library features <h> One cohesive package of advanced numerical algorithms <p> Lying at the heart of the IMSL Numerical Libraries are the comprehensive and trusted IMSL mathematical and statistical numerical algorithms . The IMSL Libraries are the gold standard for comprehensive libraries of numerical computing algorithms that software developers can embed into their applications . The latest version of the IMSL Fortran Numerical Library is comprised of all of the trusted algorithms from past versions of the IMSL family of Fortran libraries , including the IMSL F90 Library , the IMSL FORTRAN 77 Library , and the IMSL parallel processing features . In addition , utilities are included to simplify large-scale computing with the ScaLAPACK library . Interface modules to ScaLAPACK give users easy access to MPI-enabled algorithms , and allow them to write parallel code without needing to be experts in parallel programming . LAPACK integration provides easy access to SMP-enabled algorithms and allows users to write parallel code without needing to know parallel programming . CUBLAS integration allows developers to leverage NVIDIA GPU hardware through familiar function calls for many level 3 and level @ @ @ @ @ @ @ @ @ @ algorithms included in the IMSL Fortran Library , please see the function catalog . <h> Powerful interface modules <p> The IMSL Fortran Library includes powerful and flexible interface modules allowing developers to be more productive . For all applicable routines , the modules accomplish the following : <p> Allows users to utilize the fast , convenient optional arguments of the modern Fortran syntax for 100 percent of the relevant algorithms in the library , allowing for greater control and faster , simpler code development <p> Only require a short list of required arguments for each algorithm to facilitate development of simpler Fortran applications <p> Provide full depth and control via optional arguments for experienced programmers <p> Reduce development effort by checking data-type matches and array sizing at compile time <p> With operators and function modules , provide faster and more natural programming through an object-oriented approach <p> A simple and flexible interface to the library routines speeds programming and simplifies documentation <h> Complete backward compatibility <p> For over four decades , the IMSL Fortran Library has maintained full backward compatibility with all previous versions of the library . No code @ @ @ @ @ @ @ @ @ @ versions of the IMSL Fortran Library . Calls to routines from the IMSL FORTRAN 77 Library with the F77 syntax continue to function . <h> Fully tested <p> Four decades of experience in testing numerical algorithms for quality and performance across an extensive range of the latest compilers and environments is embodied in the IMSL product . Rogue Wave works with compiler partners and hardware partners to ensure a high degree of reliability and performance optimization . This experience has allowed Rogue Wave to refine its test methods with painstaking detail . The result of this effort is a robust , sophisticated suite of test methods that allow the IMSL user to rely on the numerical analysis functionality and focus their bandwidth on their application development and testing . <h> SMP/OpenMP support <p> The IMSL Fortran Library offers expanded SMP support for a number of parallel processing environments . Computationally intensive algorithms in the areas of linear systems and matrix manipulation , eigensystem analysis , and fast Fourier transforms ( FFTs ) leverage SMP capabilities on a variety of systems . 
@@75677902 @4377902/ <p> An RWHashDictionary represents a group of unordered values , accessible by external keys . Duplicate keys are not allowed . RWHashDictionary is implemented as a hash table of associations of keys and values . Both the key and the value must inherit from the abstract base class RWCollectable , with a suitable definition of the virtual function hash() and isEqual() for the key . <p> Returns TRUE if for every key-value pair in self , there is a corresponding key in hd that isEqual . Their corresponding values must also be equal . Note : If you inherit from RWHashDictionary in the presence of the Standard C++ Library , we recommend that you override this operator and explicitly forward the call . Overload resolution in C++ will choose the Standard Library provided global operators over inherited class members . These global definitions are not appropriate for set-like partial orderings . <p> RWBoolean operator== ( const RWHashDictionary&amp; hd ) const ; <p> Returns TRUE if self and hd have the same number of entries and if for every key-value pair in self , there is a corresponding key in @ @ @ @ @ @ @ @ @ @ equal . <p> Applies the user-supplied function pointed to by ap to each key-value pair of the collection . Items are not visited in any particular order . An untyped argument may be passed to the ap function through x . <p> Converts the RWHashDictionary to an RWBag , RWSet , RWOrdered , or an RWBinaryTree . Note that since a dictionary contains pairs of keys and values , the result of this call will be a container holding **25;10161;TOOLONG . Note also that the return value is a copy of the data . This can be very expensive for large collections . Consider using operator+= ( ) to insert each RWCollectableAssociation from this dictionary into a collection of your choice . <p> Inherited from class RWSet . Returns the number of keys which isEqual to the item pointed to by target . Because duplicates are not allowed , this function can only return 0 or 1 . <p> virtual RWCollectable* remove ( const RWCollectable* target ) ; <p> Redefined from class RWCollection . Removes the key and value pair where the key isEqual to the item pointed to by @ @ @ @ @ @ @ @ @ @ match was found . <p> virtual void removeAndDestroy ( const RWCollectable* target ) ; <p> Redefined from class RWCollection . Removes and deletes the key and value pair where the key isEqual to the item pointed to by target . Note that both the key and the value are deleted . Does nothing if the key is not found . <p> Removes the key and value pair where the key isEqual to the item pointed to by target . Returns the key , or nil if no match was found . The value part of the removed pair is put in v. You are responsible for defining v before calling this function . <p> Evaluates the function pointed to by tst for the key of each item in the RWHashDictionary . It inserts keys and values for which the function returns TRUE into a new RWHashDictionary allocated off the heap and returns a pointer to this new collection . Because the new dictionary is allocated off the heap , you are responsible for deleting it when done . This is a virtual function which hides the non-virtual function inherited from @ @ @ @ @ @ @ @ @ @ for both the key and the value of each item in the RWHashDictionary . It inserts keys and values for which the function returns TRUE into a new RWHashDictionary allocated off the heap and returns a pointer to this new collection . Because the new dictionary is allocated off the heap , you are responsible for deleting it when done . This is a virtual function which hides the non-virtual function inherited from RWCollection. 
@@75677903 @4377903/ <p> RWDBExprFormDefinition is a base class for a family of classes that provide an extensible mechanism for an application to define functional notation for RWDBExpr . RWDBExprFormDefinition allows a programmer to create an object that will translate into an RWDBExpr and eventually be expanded into an SQL string . The object will allow up to four expressions to be embedded into the resultant string . <p> An RWDBExprFormDefinition object is instantiated with a format string . The format string may contain placeholders for up to four positional parameters , which are labeled %0 through %3 . An object defined this way may subsequently be referenced like predefined functions , such as rwdbMax and rwdbAvg . <p> When an RWDBExprFormDefinition object is expanded by an asString() method of RWDBExpr , each instance of %0 is replaced with the first actual argument , each instance of %1 is replaced with the second actual argument , and so on . There can be multiple instances of a placeholder in the format string , and the placeholders may occur in any order . This allows great flexibility in defining functions , at the @ @ @ @ @ @ @ @ @ @ actually passed . To enable compile-time checking on the number of actual arguments , at the cost of some flexibility , use the RWDBExprFuncDefn classes . <p> Imagine that a database vendor 's SQL variant provides the function DECRYPT ( string , length , key ) . DBTools.h++ has no direct support for this function , yet we would like to use it without losing the benefits of the DBTools.h++ high-level constructs for data manipulation . To do so , we can use a function which we define ourselves : 
@@75677904 @4377904/ 50231 @qwx670231 <p> Class RWCTokenizer is designed to break a string into separate tokens , delimited by an arbitrary whitespace . Think of it as an iterator for strings and as an alternative to the ANSI C function strtok() that has the unfortunate side effect of changing the tokenized string . <h> Constructor &amp; Destructor Documentation <h> Member Function Documentation <p> bool RWCTokenizer : : done <p> ( <p> ) <p> const <p> Returns true if the last token from the search string has been extracted , otherwise false . When using the function call operator interface , this is the same as the last non-empty token having been returned . <p> Returns the next token using a delimiter pattern represented by the regular expression pattern regex . <p> This method , unlike the other operator() overloads , allows a single occurrence of a delimiter to span multiple characters . <p> For example , consider the RWCTokenizer instance tok . The statement tok ( RWCString ( " ab " ) ) treats either a or b as a delimiter character . On the other hand , tok ( RWTRegex&lt;char&gt; @ @ @ @ @ @ @ @ @ @ , ab , as a single delimiter . <p> This method consumes consecutive occurrences of delimiters and skips over any empty fields present in the string . To obtain empty fields as well as non-empty fields , use the nextToken() method . <p> Advances to the next token and returns it as a substring . The tokens are delimited by any of the first n characters in s . Buffer s may contain nulls , and must contain at least n characters . Tokens will not be delimited by nulls unless s contains nulls. 
@@75677905 @4377905/ 50231 @qwx670231 <p> Gadget class . <p> Library : ilvgadgt <p> The IlvFrame class is a gadget class that draws a frame with a label . The label of the frame is drawn using the main palette of the gadget and the frame is drawn using its top shadow and bottom shadow palettes . <p> A Boolean value specifying whether a message should be copied . If the value is IlFalse , then you must allocate some memory for the message because in any case the message characters are deleted from the memory by the IlvFrame . <p> Initializes a new instance of the IlvFrame class . The size of the frame is computed using the message parameter . 50234 @qwx670234 <p> display <p> The connection to the display . <p> point <p> The position of the frame . <p> message <p> The label of the frame . <p> thickness <p> The thickness of the frame . <p> palette <p> The palette used by the frame . <p> copy <p> A Boolean value specifying whether a message should be copied . If the value is IlFalse , then you @ @ @ @ @ @ @ @ @ @ case the message characters are deleted from the memory by the IlvFrame. 
@@75677906 @4377906/ <h> Constructor &amp; Destructor Documentation <p> Initializes a new instance of the IlvIMessageDialog class that initially displays a message with a single line . 50234 @qwx670234 <p> display <p> The connection to the display . <p> string <p> The message to be displayed . <p> fileordata <p> Specifies an alternative source of Rogue Wave Views data defining the user interface of this dialog . This data can be stored in a file , in which case fileordata represents the name of the file , or in a C++ string , in which case fileordata stands for the string itself . If fileordata is not specified , the default dialog is used . <p> type <p> The type of the dialog . For details , see IlvIDialogType . <p> transientFor <p> A system view for which the dialog is transient . For details , see the IlvView constructors . <p> Initializes a new instance of the IlvIMessageDialog class that initially displays a message with multiple lines . 50234 @qwx670234 <p> display <p> The connection to the display . <p> strings <p> An array of strings representing the message to be @ @ @ @ @ @ @ @ @ @ the strings array . <p> copy <p> Not used . <p> fileordata <p> Specifies an alternative source of Rogue Wave Views data defining the user interface of this dialog . This data can be stored in a file , in which case fileordata represents the name of the file , or in a C++ string , in which case fileordata stands for the string itself . If fileordata is not specified , the default dialog is used . <p> type <p> The type of the dialog . For details , see IlvIDialogType . <p> transientFor <p> The system view for which the dialog is transient . For details , see the IlvView constructors . <h> Member Function Documentation <p> A Boolean value specifying whether the dialog should be system modal . A system modal dialog grabs input events occurring on the entire system so that other applications are not able to catch any keyboard or mouse event until the member function returns . In this case , you can specify the cursor to be used with the cursor parameter . If grab is set to IlFalse ( the default ) @ @ @ @ @ @ @ @ @ @ the application does not receive input events in other windows . <p> Warning : <p> note Some operating systems , such as Windows NT and Windows 95 , do not allow system modal dialogs . On these operating system dialogs are always application modal . 
@@75677907 @4377907/ <h> 6.13 Iterators in Class Templates <p> The Essential Tools Module provides several distinct methods for iterating over a collection class . Most collections offer an apply member function , which applies your supplied function to every element of a collection class before returning . Another form of iteration is provided by separate collaborating iterator classes associated with many of the collections . For example , an RWTPtrDlistIterator&lt;T , A&gt; can be used to visit each element of an RWTPtrDlist&lt;T , A&gt; in turn . Iterators are described in Section 6.6 . <p> All Essential Tools Module standard library-based collection class templates provide standard iterators . These iterators are fully compliant with the C++ Standard Library requirements for iterators , making them a powerful tool for using the classes in conjunction with the C++ Standard Libraryespecially the algorithms . Although full treatment of iterators is beyond the scope of this guide , your C++ Standard Library reference and tutorials will provide ample information . <p> The standard library-based collection class templates provide three types of iterators : forward , bi-directional , and random-access . Forward iterators allow unidirectional traversal @ @ @ @ @ @ @ @ @ @ , bidirectional iterators allow traversal in both directionsfront to back , and back to front . Random-access iterators are bidirectional as well , and further distinguished by their ability to advance over an arbitrary number of elements in constant time . All of these iterators allow access to the item at the current position via the dereference operator * . <p> Given iterator iter and an integral value n , the following basic operations are just some of those supported : <p> Expression <p> Meaning <p> Supported by : <p> ++iter ; <p> advance to next item and return <p> Forw , Bidir , Random <p> iter++ ; <p> advance to next item , return original value <p> Forw , Bidir , Random <p> *iter ; <p> return reference to item at current position <p> Forw , Bidir , Random <p> --iter ; <p> retreat to previous item and return <p> Bidir , Random <p> iter-- ; <p> retreat to previous item , return original value <p> Bidir , Random <p> iter+=n ; <p> advance n items and return <p> Random <p> iter-=n ; <p> retreat n items and return @ @ @ @ @ @ @ @ @ @ describe all the operators and functions available for each type of iterator . <p> In addition to the iterators just described , the standard library-based collection class templates also provide two typedefs used to iterate over the items in a collection class : iterator , and constiterator . You can use the iterator typedef to traverse a collection class and modify the elements within . You can use instances of constiterator to traverse , but not modify , the collection class and access elements . For the associative container-based and sorted sequence-based collections , which do not allow modification of elements once they are in the collection class , the iterator and constiterator types are the same . <p> Finally , the templates also provide two member functions that return actual iterators you can use for traversing their respective collection classes . These member functions are begin() and end() . Each of these member functions is overloaded by a const receiver so that the non-const version returns an instance of type iterator , and the const version returns an instance of type constiterator . <p> Member function begin() always returns @ @ @ @ @ @ @ @ @ @ collection class . Member function end() returns an iterator which has a past-the-end value , the way a pointer to the NULL character of a null-terminated character string has a value that points " past the end . " An iterator of past-the-end value can be used to compare with another iterator to see if you 've finished visiting all the elements in the collection class . It can also be used as a starting point for moving backwards through collection classes that provide either bidirectional or random-access iterators . The one thing you can not do with an end() iterator is deference it . Here 's an example using iterators to move through a list and search for a match : <p> RWTValDlist&lt;int&gt; intCollection ; // a list of integers // ... &lt; put stuff in the list &gt; // position iter at start : RWTValDlist&lt;int&gt; : : iterator iter = intCollection.begin() ; // set another iterator past the end : RWTValDlist&lt;int&gt; : : iterator theEnd = intCollection.end() ; // iterate through , looking for a 7 : while ( iter ! = theEnd ) // test for end @ @ @ @ @ @ @ @ @ @ ' * ' to access current element return true ; // found a 7 ++iter ; // not a 7 , try next element return false ; // never found a 7 <p> In the case of a map-based collection class , like RWTValMap&lt;K , T , C , A&gt; , iterators refer to instances of the C++ Standard Library structure pair&lt;const K , T&gt; . As you iterate over a map-based collection , you have access to both the key and its associated data at each step along the traversal . The pair structure provides members first and second , which allow you to individually access the key and its data , respectively . For example : <p> Note that given a non-const reference to such a pair , you can still modify only the second elementthe data associated with the key . This is because the first element is declared to be of type const K. Because the placement of objects within the collection class is maintained internally , based on the value of the key , declaring it as const protects the integrity of the collection class @ @ @ @ @ @ @ @ @ @ , you have to remove the key and its data entirely , and replace them with a new entry . <p> It may not be obvious at first , but you can think of an iterator as a generalized pointer . Imagine a pointer to an array of int s . The array itself is a collection class , and a pointer to an element of that array is a random-access iterator . To advance to the next element , you simply use the unary operator ++ . To move back to a previous element , you use -- . To access the element at the current position of the iterator , you use the unary operator * . Finally , it is important to know when you have visited all the elements . C++ guarantees that you can always point to the first address past the end of an allocated array . For example : <p> int intCollection10 ; // an array of integers // ... &lt; put stuff in the array &gt; // position iter at start : int* iter = intCollection ; // set another iterator past @ @ @ @ @ @ @ @ @ @ // iterate through , looking for a 7 : while ( iter ! = theEnd ) // test for end of array if ( *iter == 7 ) // use ' * ' to access current element return true ; // found a 7 ++iter ; // not a 7 , try next element return false ; // never found a 7 <p> If you compare this code fragment to the one using standard iterators in Section 6.13.1 , you can see the similarities . If you need a bit of help imagining how the standard iterators work , you can always picture them as generalized pointers . 50235 @qwx670235 
@@75677908 @4377908/ <p> This method is used to implement modal and preemptive dialogs . It basically calls the IlvView method showModal ( grab , cursor ) , which calls show and enters a modal event loop . If an event player ( IlvEventPlayer ) is active , it tries to use it as a source of events . This method is often used by subclasses of IlvDialog to implement a method that returns a value from the user . 50234 @qwx670234 <p> grab <p> A Boolean value specifying whether the dialog should be system modal , that is , it grabs input events on the whole system so that , until the function returns , other applications will not be able to get any keyboard or mouse event . In this case , you can specify a cursor to be displayed in through cursor . If grab is set to IlFalse(default) , the dialog is application modal , that is , the application does not receive input events in other windows . 
@@75677909 @4377909/ <p> This class maintains a collection of keys , each with an associated item of type T. Order is determined by the key according to a comparison object of type C. C must induce a total ordering on elements of type K via a public member <p> bool operator() ( const K&amp; x , const K&amp; y ) const <p> which returns true if x and its partner should precede y and its partner within the collection . The structure less&lt;T&gt; from the C++-standard header file &lt;functional&gt; is an example . <p> RWTValMap&lt;K , T , C&gt; will not accept a key that compares equal to any key already in the collection . ( RWTValMultiMap&lt;K , T , C&gt; may contain multiple keys that compare equal to each other . ) Equality is based on the comparison object and not on the == operator . Given a comparison object comp , keys a and b are equal if <p> ! comp ( a , b ) &amp;&amp; ! comp ( b , a ) . <p> The value type must have operator== and operator&lt; defined . This requirement is @ @ @ @ @ @ @ @ @ @ , T , C&gt; offers the same interface to a collection that accepts multiple keys that compare equal to each other . RWTValSet&lt;T , C&gt; maintains a collection of keys without the associated values . <p> Class map&lt;K , T , C , allocator&gt; is the C++-standard collection that serves as the underlying implementation for this collection . <p> Returns true if self compares equal to m , otherwise returns false . Two collections are equal if both have the same number of entries , and iterating through both collections produces , in turn , individual pairs that compare equal to each other . <p> T&amp; operator ( const K&amp; key ) ; <p> Looks up key and returns a reference to its associated item . If the key is not in the dictionary , then it will be added with an associated item provided by the default constructor for type T. <p> If there exists an association a in self such that the expression ( ( *fn ) ( a , d ) ) is true , assigns a to r and returns true . Otherwise , returns false @ @ @ @ @ @ @ @ @ @ to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool findValue ( const K&amp; key , T&amp; r ) const ; <p> If there exists a key j in self that compares equal to key , assigns the item associated with j to r and returns true . Otherwise , returns false and leaves the value of r unchanged . <p> bool findKeyValue ( const K&amp; key , K&amp; kr , T&amp; tr ) const ; <p> If there exists a key j in self that compares equal to key , assigns j to kr , assigns the item associated with j to tr , and returns true . Otherwise , returns false and leaves the values of kr and tr unchanged . <p> bool insert ( const K&amp; key , const T&amp; a ) ; <p> Adds key with associated item a to the collection . Returns true if the insertion is successful , otherwise returns false . The function will return true unless the collection already holds an association with the equivalent key . <p> bool insertKeyAndValue ( const K&amp; key , @ @ @ @ @ @ @ @ @ @ version of the insert member above . It behaves exactly the same as insert . <p> bool isEmpty() const ; <p> Returns true if there are no items in the collection , false otherwise . <p> Returns the number of associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . fn points to a user-defined tester function which must have prototype : <p> bool **30;10188;TOOLONG a , void* d ) ; 50233 @qwx670233 <p> bool remove ( const K&amp; key ) ; <p> Removes the first association with key j in self such that j compares equal to key and returns true . Returns false if there is no such association . <p> bool remove ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes the first association a in self such that the expression ( ( *fn ) ( a , d ) ) is true and returns true . Returns false if there is no such element . fn points to a user-defined tester function which must have prototype : @ @ @ @ @ @ @ @ @ @ key ) ; <p> Removes all associations with key j in self such that j compares equal to key . Returns the number of items removed . <p> sizetype removeAll ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes all associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . Returns the number of items removed . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> map&lt;K , T , C , allocator&gt;&amp; std() ; const map&lt;K , T , C , allocator&gt;&amp; std() const ; <p> Returns a reference to the underlying C++-standard collection that serves as the implementation for self . This reference may be used freely , providing access to the C++-standard interface as well as interoperability with other software components that make use of the C++-standard collections . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p @ @ @ @ @ @ @ @ @ @ collection is created off the heap , then you are responsible for deleting it . 
@@75677910 @4377910/ <p> SOLA is the most complete mainframe Service Oriented Architecture ( SOA ) solution in the industry . SOLA solves todays most critical problem , making mainframe applications part of an SOA in a cost effective manner . SOLA provides customers with a fast and easy process to expose mainframe applications as secure Web Services , and allows mainframe applications to consume Web Services . Using SOLA , customers can leverage billions of dollars of existing mainframe investments when building an enterprise SOA . The SOLA runtime environment runs entirely on the mainframe , eliminating the need for expensive , unreliable and unnecessary middleware . This , coupled with SOLA 's Development Studio , vastly increases developer productivity , providing faster time to market and lower application development cost . The combination of a highly optimized runtime , no middleware and improved productivity provide the lowest Total Cost of Ownership ( TCO ) in the industry . Introducing SOLA 6.0 , SOLAs high performance and low CPU overhead enable customers to run the worlds largest mainframe SOA implementations in the most cost effective manner . SOLA is the only @ @ @ @ @ @ @ @ @ @ 10 million+ ) transactions per day in mission-critical mainframe SOA environments . <p> SOLA Advantages for Mainframe SOA <p> Most comprehensive mainframe SOA solution on the market <p> Production proven track record in the Fortune 1000 <p> Lowest TCO ( and highest ROI ) in the industry <p> SOLA is a Governed Service Platform , making it fully governable by Akana products like Policy Manager and Service Manager <h> SOLA What makes it the most complete Mainframe SOA Solution ? <p> Service Oriented Architecture ( SOA ) is an architectural methodology for the loose coupling and management of services . Mainframe web services are a component of mainframe SOA . SOLA goes beyond mainframe web services to offer every essential component of a mainframe SOA , enabling the mainframe to act as a first class participant in an enterprise wide SOA . <h> SOLA Governance <p> SOLA is the only mainframe SOA product to offer closed-loop Governance automation . A service is automatically governed from the point of creation because it inherits a security policy . Policy , by means of WS-PolicyAttachment , is associated with the service though all @ @ @ @ @ @ @ @ @ @ possible to create or run an ungoverned service . On top of this , SOLAs built in monitoring , logging and auditing capabilities , as well as its standards based architecture combine to make SOLA fully governable by external governance products like Akana 's Policy Manager . 
@@75677911 @4377911/ 50231 @qwx670231 <p> Manager interactor class . <p> Library : ilvmgr <p> This class handles complex sequences of user events treated by a particular view object . It is the parent class of all view interactors . Typical interactors derived from this class implement constructors of graphic objects . <h> Member Function Documentation <p> virtual void IlvManagerViewInteractor : : abort <p> ( <p> ) <p> virtual <p> Aborts the interaction . <p> Called by the manager when the user changes the current interactor . It resets the interactor to a state in which it appears to have never been launched . A common implementation is to erase the ghost image . Call this member function to inhibit the interactor action in particular circumstances . <p> Called to draw a preview image of the resulting user action ( the ghost image of the interactor ) . This function is generally invoked by IlvManagerViewInteractor : : handleEvent as a response to user events . <p> Ensures that a given location is visible on the screen . This is done by means of scrolling the view if the view is contained in @ @ @ @ @ @ @ @ @ @ that is , changing the view transformer ) if the view is not scrollable . <p> Called by the manager when an exposure request occurs in the interactor view to redraw shapes handled by the interactor , such as a ghost image . The basic implementation calls the member function IlvManagerViewInteractor : : drawGhost after the clipping region has been set to the exposed area . <p> Resets the interactor to its initial state . Called by the manager whenever the interactor is associated with a view . An association of this kind is established by the member function IlvManager : : setInteractor. 
@@75677913 @4377913/ <p> RWDBUpdater is an encapsulation of an SQL UPDATE statement . Its methods provide an application with explicit control over the UPDATE statement 's SET and WHERE clauses . <p> The insertion operator &lt;&lt; is used to add encapsulated SET clauses to an RWDBUpdater ; the where() method is used to specify a WHERE clause . The items which are inserted into an RWDBUpdater are RWDBAssignments , which are created by the assign() method of RWDBColumn . The WHERE clause is encapsulated by an RWDBCriterion , which is some number of RWDBExprs combined with logical operators . <p> An UPDATE statement does not normally produce results . However , DBTools.h++ recognizes that some database vendors provide triggers , which can cause results to be generated by an UPDATE statement . Consequently , RWDBUpdater 's execute() method returns an RWDBResult , which is a sequence of zero or more RWDBTables . Applications are not obliged to request any tables from the returned object . <p> RWDBUpdater is designed around the Interface/Implementation paradigm . An RWDBUpdater instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce @ @ @ @ @ @ @ @ @ @ implementation is a base class from which a family of database-specific updater implementations is derived . <p> This example accomplishes the same task as Example 1 , but provides bindings to an application variable . This allows the application to repeatedly execute the update with different values without reshifting in values . <p> The encapsulated WHERE clause of an RWDBUpdater is an RWDBCriterion , which is composed of RWDBExprs . Each encapsulated SET clause is an RWDBAssignment , produced by the assign() method of RWDBColumn . See RWDBAssignment , RWDBCriterion , RWDBExpr , and RWDBColumn for details . <p> The result of RWDBUpdater : : execute() is an RWDBResult , which represents a sequence of zero or more RWDBTables . See RWDBResult and RWDBTable for details . <p> The default constructor creates an RWDBUpdater whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience , for example , for declaring an array of RWDBUpdaters . Usable RWDBUpdaters are obtained from RWDBTables . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until @ @ @ @ @ @ @ @ @ @ from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> Uses a default database connection to cause the SQL statement encapsulated by self to be executed . The connection is held by the RWDBResult until the RWDBResult is destroyed . <p> RWDBResult execute ( const RWDBConnection&amp; connection ) ; <p> Uses the supplied connection to cause the SQL statement encapsulated by self to be executed . The connection is held by the RWDBResult until the RWDBResult is destroyed . This function can behave asynchronously if executed using an asynchronous connection . <p> RWBoolean isReady() const ; <p> This function returns TRUE if the object is in ready state , indicating that accessing the object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if self 's status is RWDBStatus : : ok , otherwise returns FALSE . Does not return FALSE if the previous executed statement failed . You must check the status of the RWDBResult returned from execute() instead of the status of the RWDBUpdater object . <p> void @ @ @ @ @ @ @ @ @ @ This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWDBUpdater&amp; set ( const RWDBAssignment&amp; assignment ) ; <p> Adds the encapsulated SET clause represented by assignment to self . Equivalent to inserting assignment into self . Returns a reference to self . <p> void **26;10220;TOOLONG : : ErrorHandler handler ) ; <p> Installs handler as self 's error handler . The supplied handler is inherited by all objects produced by self . By default , the error handler of an RWDBUpdater is inherited from the object that produced it ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : <p> typedef void ( *ErrorHandler ) ( const RWDBStatus&amp; ) ; <p> RWDBStatus status() const ; <p> Returns the current status of self . <p> RWDBTable table() const ; <p> Returns the RWDBTable that produced self . Returns an RWDBTable whose status is RWDBStatus : : notInitialized if self was created with the default constructor . <p> RWDBCriterion where() const ; <p> Returns a copy of self @ @ @ @ @ @ @ @ @ @ an empty RWDBCriterion if self has no WHERE clause . <p> RWDBUpdater&amp; where ( const RWDBCriterion&amp; criterion ) ; <p> Specifies criterion as self 's SQL WHERE clause . If self already has a WHERE clause , this method replaces it . Specifying an empty criterion clears self 's WHERE clause . Notice that an updater without a WHERE clause updates all rows in its table . Returns a reference to self . 
@@75677914 @4377914/ <p> Since TotalView does n't know that p actually points to an array of integers , you need to do several things to display the array : <p> 1 . Dive on the variable p of type int* . <p> 2 . Change its type to int20* . <p> 3 . Dive on the value of the pointer to display the array of 20 integers . <p> Displaying the argv Array <p> Typically , argv is the second argument passed to main() , and it is either a char **argv or char *argv . Suppose argv points to an array of three pointers to character strings . Here is how you can edit its type to display an array of three pointers : <p> 1 . Select the type string for argv . <p> CLI : dprint argv <p> 2 . Edit the type string by using the field editor commands . Change it to : <p> $string*3* <p> CLI : dprint ( $string*3* ) argv <p> 3 . To display the array , dive on the value field for argv . <p> Figure 143 " Editing the argv @ @ @ @ @ @ @ @ @ @ edit the address of a variable in a Variable Window by editing the value shown in the Address field . When you edit this address , the Variable Window shows the contents of the new location . <p> You can also enter an address expression such as 0x10b8 - 0x80 in this area . <p> TotalView displays C++ classes and accepts class as a keyword . When you debug C++ , TotalView also accepts the unadorned name of a class , struct , union , or enum in the type field . TotalView displays nested classes that use inheritance , showing derivation by indentation . <p> NOTE &gt;&gt; Some C++ compilers do not write accessibility information . In these cases , TotalView can not display this information . <p> TotalView tries to display the correct data when you change the type of a Variable Window while moving up or down the derivation hierarchy . Unfortunately , many compilers do not contain the information that TotalView needs so you might need to cast your class . 
@@75677915 @4377915/ <p> This class maintains a collection of pointers to type T , implemented as a singly-linked list . This is a pointer based list : pointers to objects are copied in and out of the links that make up the list . <p> Parameter T represents the type of object to be inserted into the list , either a class or fundamental type . The class T must have : <p> Sets self to a shallow copy of c . Afterwards , pointers will be shared between the two collections . <p> T*&amp; operator ( sizet i ) ; T* const&amp; operator ( sizet i ) const ; <p> Returns a pointer to the ith value in the list . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsErr will be thrown . <p> Applies the user-defined function pointed to by applyFun to every item in the list . This function must have the prototype : <p> void yourFun @ @ @ @ @ @ @ @ @ @ function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> T*&amp; at ( sizet i ) ; T* const ; at ( sizet i ) const ; <p> Returns a pointer to the ith value in the list . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsErr will be thrown . <p> void clear() ; <p> Removes all items from the collection . <p> void clearAndDestroy() ; <p> Removes all items from the collection and deletes them . Do not use this method if multiple pointers to the same object are stored . <p> RWBoolean contains ( const T* a ) const ; <p> Returns TRUE if the list contains an object that is equal to the object pointed to by a , FALSE otherwise . Equality is measured by the class-defined equality operator for type @ @ @ @ @ @ @ @ @ @ T* , void* ) , void* d ) const ; <p> Returns TRUE if the list contains an item for which the user-defined " tester " function pointed to by testFun returns TRUE . Returns FALSE otherwise . The tester function must have the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> sizet entries() const ; <p> Returns the number of items that are currently in the collection . <p> T* find ( const T* target ) const ; <p> Returns a pointer to the first object encountered which is equal to the object pointed to by target , or nil if no such object can be found . Equality is measured by the class-defined equality operator for type T. <p> T* find ( RWBoolean ( *testFun ) ( T* , void* ) , void* d , ) const ; <p> Returns a pointer to the first object encountered for which @ @ @ @ @ @ @ @ @ @ , or nil if no such object can be found . The tester function must have the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> T*&amp; first() ; T* const&amp; first() const ; <p> Returns a pointer to the first item in the list . The behavior is undefined if the list is empty . <p> T* get() ; <p> Returns a pointer to the first item in the list and removes the item . The behavior is undefined if the list is empty . <p> sizet index ( const T* a ) ; <p> Returns the index of the first object that is equal to the object pointed to by a , or RWNPOS if there is no such object . Equality is measured by the class-defined equality operator for type T. <p> sizet index ( RWBoolean ( *testFun ) ( T* , void* ) , void* d ) const @ @ @ @ @ @ @ @ @ @ which the user-defined tester function pointed to by testFun returns TRUE , or RWNPOS if there is no such object . The tester function must have the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> void insert ( T* a ) ; <p> Adds the object pointed to by a to the end of the list . <p> void insertAt ( sizet i , T* a ) ; <p> Adds the object pointed to by a at the index position i . This position must be between zero and the number of items in the list , or an exception of type RWBoundsErr will be thrown . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in the list , FALSE otherwise . <p> T*&amp; last() ; T* const&amp; last() const ; <p> Returns a pointer to the last item in the list . The behavior is @ @ @ @ @ @ @ @ @ @ ( const T* a ) const ; <p> Returns the number of objects in the list that are equal to the object pointed to by a . Equality is measured by the class-defined equality operator for type T. <p> sizet occurrencesOf ( RWBoolean ( *testFun ) ( T* , void* ) , void* d ) const ; <p> Returns the number of objects in the list for which the user-defined " tester " function pointed to by testFun returns TRUE . The tester function must have the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> void prepend ( T* a ) ; <p> Adds the item pointed to by a to the beginning of the list . <p> T* remove ( const T* a ) ; <p> Removes the first object which is equal to the object pointed to by a and returns a pointer to it , or nil if @ @ @ @ @ @ @ @ @ @ by the class-defined equality operator for type T. <p> T* remove ( RWBoolean ( *testFun ) ( T* , void* ) , void* d ) ; <p> Removes the first object for which the user-defined tester function pointed to by testFun returns TRUE and returns a pointer to it , or nil if there is no such object . The tester function must have the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> sizet removeAll ( const T* a ) ; <p> Removes all objects which are equal to the object pointed to by a . Returns the number of objects removed . Equality is measured by the class-defined equality operator for type T. <p> sizet removeAll ( RWBoolean ( *testFun ) ( T* , void* ) , void* d ) ; <p> Removes all objects for which the user-defined tester function pointed to by testFun returns TRUE . Returns the @ @ @ @ @ @ @ @ @ @ the prototype : <p> RWBoolean yourTester ( T* , void* d ) ; <p> This function will be called for each item in the list , with a pointer to the item as the first argument . Client data may be passed through as parameter d . <p> T* removeAt ( sizet i ) ; <p> Removes the object at index i and returns a pointer to it . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> T* removeFirst() ; <p> Removes the first item in the list and returns a pointer to it . The behavior is undefined if the list is empty . <p> T* removeLast() ; <p> Removes the last item in the list and returns a pointer to it . The behavior is undefined if the list is empty . This function is relatively slow because removing the last link in a singly-linked list necessitates access to the next-to-the-last link , requiring that the whole list be searched . <p> Looks @ @ @ @ @ @ @ @ @ @ either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677917 @4377917/ <h> Map and Multimap Operations <p> The member functions provided by the map and multimap data types will shortly be described in more detail . Note that while member functions provide basic operations , the utility of the data structure is greatly extended through the use of the generic algorithms described in Chapters 13 and 14 . <p> The declaration of a map follows the pattern we have seen repeatedly in the standard library . A map is a template data structure , specialized by the type of the key elements , the type of the associated values , and the operator to be used in comparing keys . If your compiler supports default template types ( a relatively new feature in C++ not yet supported by all vendors ) , then the last of these is optional , and if not provided , the less than operator for the key type will be assumed . Maps can be declared with no initial elements , or initialized from another container by providing a pair of iterators . In the latter case the iterators must denote values of type pair @ @ @ @ @ @ @ @ @ @ be a key , while the second field is a value . A copy constructor also permits maps to be created as copies of other maps . <p> The classes map and multimap include a number of type definitions . These are most commonly used in declaration statements . For example , an iterator for a map of strings to integers can be declared in the following fashion : <p> map&lt;string , int&gt; : : iterator location ; <p> In addition to iterator , the following types are defined : <p> keytype <p> The type associated with the keys used to index the map . <p> valuetype <p> The type held by the container , a key/value pair . <p> constiterator <p> An iterator that does not allow modification of the underlying sequence . <p> reverseiterator <p> An iterator that moves in a backward direction . <p> constreverseiterator <p> A combination constant and reverse iterator . <p> reference <p> A reference to an underlying value . <p> constreference <p> A reference to an underlying value that will not permit the element to be modified . <p> sizetype <p> An unsigned @ @ @ @ @ @ @ @ @ @ containers . <p> keycompare <p> A function object that can be used to compare two keys . <p> valuecompare <p> A function object that can be used to compare two elements . <p> differencetype <p> A signed integer type , used to describe the distances between iterators . <p> Values can be inserted into a map or a multimap using the insert() operation . Note that the argument must be a key-value pair . This pair is often constructed using the data type valuetype associated with the map . <p> mapthree.insert ( map&lt;int&gt; : : valuetype ( 5 , 7 ) ) ; <p> Insertions can also be performed using an iterator pair , for example as generated by another map . <p> maptwo.insert ( mapthree.begin() , mapthree.end() ) ; <p> With a map ( but not a multimap ) , values can be accessed and inserted using the subscript operator . Simply using a key as a subscript creates an entry - the default element is used as the associated value . Assigning to the result of the subscript changes the associated binding . <p> Values can be removed @ @ @ @ @ @ @ @ @ @ value . In a multimap the erasure removes all elements with the associated key . An element to be removed can also be denoted by an iterator ; as , for example , the iterator yielded by a find() operation . A pair of iterators can be used to erase an entire range of elements . <p> The member functions begin() and end() produce bidirectional iterators for both maps and multimaps . Dereferencing an iterator for either a map or a multimap will yield a pair of key/value elements . The field names first and second can be applied to these values to access the individual fields . The first field is constant , and can not be modified . The second field , however , can be used to change the value being held in association with a given key . Elements will be generated in sequence , based on the ordering of the key fields . <p> The member functions rbegin() and rend() produce iterators that yield the elements in reverse order . <p> The member function size() will yield the number of elements held by a container @ @ @ @ @ @ @ @ @ @ value if the container is empty , and is generally faster than testing the size against zero . <p> The member function find() takes a key argument , and returns an iterator denoting the associated key/value pair . In the case of multimaps , the first such value is returned . In both cases the past-the-end iterator is returned if no such value is found . <p> The member function lowerbound() yields the first entry that matches the argument key , while the member function upperbound() returns the first value past the last entry matching the argument . Finally , the member function equalrange() returns a pair of iterators , holding the lower and upper bounds . An example showing the use of these procedures will be presented later in this section . <p> The member function count() returns the number of elements that match the key value supplied as the argument . For a map , this value is always either zero or one , whereas for a multimap it can be any nonnegative value . If you simply want to determine whether or not a collection contains an @ @ @ @ @ @ @ @ @ @ often easier than using the find() function and testing the result against the end-of-sequence iterator . <p> The member functions keycomp() and valuecomp() , which take no arguments , return function objects that can be used to compare elements of the key or value types . Values used in these comparisons need not be contained in the collection , and neither function will have any effect on the container . <p> Because maps and multimaps are ordered collections , and because the iterators for maps return pairs , many of the functions described in Sections 13 and 14 are meaningless or difficult to use . However , there are a few notable exceptions . The functions foreach() , adjacentfind() , and accumulate() each have their own uses . In all cases it is important to remember that the functions supplied as arguments should take a key/value pair as arguments . 
@@75677918 @4377918/ <h> 14.4 The Tutorial Model <p> The video store modeled in the tutorials has a database containing only five tables . Three of these tables represent the pool of customers , videos , and video suppliers , and the remaining two represent the transactions of customers renting videos and suppliers providing the videos that the store purchases . The schema of these tables are shown below . <p> NOTE : Before using the tutorials , you should verify that there wo n't be any conflicts with existing tables within your database . <p> For maximum portability , the table names have been chosen to conform with databases that impose an 8-letter maximum on name length . Likewise , column names have been chosen with a 10-letter maximum . Notice that DBTools.h++ itself places no such restriction on name length . <p> The tutorial model provides a separate class for each table in the video store 's databases , as well as a class representing a single row in each table . For example , the table containing the library of video titles is represented by a class called VVVideoRepository @ @ @ @ @ @ @ @ @ @ as well as the basic operations on that table . As a companion to the VVVideoRepository class , there is a class representing one video entry in the table . This class , called VVVideo , has one instance variable for each of the rows in the table . This class also includes member functions appropriate for a representation of a single video . <p> Each of the five tables in the video store 's database uses this model of a pairing of two classes . One class encapsulates the table , and the other class represents one row of the table . <p> The table below illustrates the associations of tables , classes , and files . <p> We developed each of these classes more completely than necessary for use with the tutorials . The tutorials do not exploit all the functionality of these classes . You will find many useful routines implemented in the classes that can be used as example code . <p> All the classes that represent one row of a given table are implemented as collectable , persistable objects according to the method defined by @ @ @ @ @ @ @ @ @ @ use persistence . <p> Exploring the source code of these classes beyond what is used in the tutorials can help you learn both DBTools.h++ and Tools.h++. 
@@75677919 @4377919/ <p> The values in the table are not exact , since they were generated using the built-in base 2 floating point types and have been printed to a limited precision . As you can see , the size of the error decreases as a larger number of bits are used . Unfortunately , it will never be zero for a finite number of bits . As a result , calculations performed using a base 2 representation produce counter-intuitive and problematic results in many circumstances . For example , the following code fragment will result in an error message : 
@@75677921 @4377921/ <h> Friends 50231 @qwx670231 <p> Gadget class . <p> Library : ilvgadgt <p> The IlvMessageLabel class displays a message and an optional bitmap . A message label is a character string that can be translated to various languages to create localized applications . Translated strings are stored in a message database that can be associated with the current instance of IlvDisplay . Both sensitive and insensitive bitmaps can be specified for a message label . The insensitive bitmap will be used when the message label is insensitive . The message label can be placed to any position relative to the bitmap . The default IlvMessageLabel position is IlvCenter . This object has no associated default interactor . <p> A Boolean value specifying whether a message should be copied . If the value is IlFalse , then you must allocate some memory for the message because in any case the message characters are deleted from the memory by the IlvMessageLabel . <p> Initializes a new instance of the IlvMessageLabel class . Since only the position of the object is given , its size is computed according to its contents . @ @ @ @ @ @ @ @ @ @ . <p> message <p> The label of the message label . <p> at <p> The position of the message label . <p> alignment <p> The alignment of the message label inside its bounding box . <p> thickness <p> The thickness of the message label . <p> palette <p> The palette used by the message label . <p> copy <p> A Boolean value specifying whether a message should be copied . If the value is IlFalse , then you must allocate some memory for the message because in any case the message characters are deleted from the memory by the IlvMessageLabel . <p> The insensitive bitmap is displayed by the message label when it is set to insensitive . If only a sensitive bitmap is provided , and if the message label is set to insensitive , a default insensitive bitmap is automatically computed using the sensitive bitmap . <p> Returns : <p> The bitmap used by this message label when set to insensitive or 0 if there is none . <p> The definition of the message stored in this object translated in the current language or 0 if no label @ @ @ @ @ @ @ @ @ @ stored in this object has no translation in the current language , the method simply returns the message itself . <p> A Boolean value specifying whether a message should be copied . If the value is IlFalse , then you must allocate some memory for the message because in any case the message characters are deleted from the memory by the IlvMessageLabel. 
@@75677927 @4377927/ <h> 3 Steps to an Organized Open Source Software Strategy <p> Faster development cycles can be achieved by having a strong strategy and a firm set of standard guidelines as to how your company manages open source software . We all know how much everyone loves faster development cycles , but this is just the tip of the iceberg when it comes to the advantages of having an organized open source strategy . <p> The open source ecosystem is an ever-growing world that is quickly becoming the backbone of corporate development . This rapid rate of growth facilitates the need for a well-defined strategy to choose the right open source software , keep development and operations teams in sync , and create an engaged community . <p> Step 1 - The Search <p> Searching for software is the first step , and whether or not it 's coming from a trusted source is the most important thing to consider . In fact , more often than not , it 's best to try and get the software directly from a vendor 's website . The reason this so criticial @ @ @ @ @ @ @ @ @ @ mitigate the risk of a wide range security issues . You may find that quite a few vendors use source code repositories like Github to manage their codebases while providing a centralized place for you to download their software . You 're development team will still need to ensure that the code they 're downloading is up to your company 's standards , however , beginning your search in reputable places will start your strategy off in the right direction . <p> Step 2 - Understanding <p> A common mistake many companies make during this software acquisition process is not knowing the licenses that the software is bound to . Licenses may require you to visibly attribute the author in some way , while others may not allow you to use the software commercially at all . The broad range of license types can create a potential pitfall to the unknowing development team . When analyzing open source software , there are a few things you can ask yourself to remain generally safe : <p> Open source software gets it 's strength from the people who love and follow it @ @ @ @ @ @ @ @ @ @ help you grow your project and strengthen its codebase . Take Twitter for example . Last year , when Twitter released their user interface framework Twitter Bootstrap to the open source world , developers rushed to add their own plug-ins and new ideas to the codebase . Another example is the enormous popularity of Node.js . This can be directly attributed to their efforts in the open source community to drive engagement . Here are some of the stats for top Github open source projects - ( forks are people who have made their own version of the codebase to contribute to the project ) <p> Twitter Bootstrap - 8,566 forks <p> Node.js - 2,452 forks <p> JQuery - 2,249 forks <p> Right away these companies were able to improve their offering and position in the open source world with little assistance from their own development team . Another direct impact of community engagement is a " cult-like " following . When developers like software , they tell other developers about it who get excited about getting involved . This creates an army of people who may not work for @ @ @ @ @ @ @ @ @ @ your codebase better . It 's a win-win situation . <p> These are just a few of the ways anyone from large organizations to small businesses can participate in the open source community with a clear , well-defined strategy . Agreeing on suitable vendors , keeping track of licenses , and monitoring your community engagement are vital ingredients to an organized and efficient open source strategy . Pick a strategy that works well for your team and watch your project reach new heights . 
@@75677929 @4377929/ <p> **28;10248;TOOLONG is an ordered collection . That is , the items in the collection have a meaningful ordered relationship with respect to one another and can be accessed by an index number . The order is set by the order of insertion . Duplicates are allowed . The class is implemented as a vector , allowing efficient insertion and retrieval from the end of the collection , but somewhat slower from the beginning of the collection . <p> Note that an ordered vector has a length ( the number of items returned by length() or entries() ) and a capacity . Necessarily , the capacity is always greater than or equal to the length . Although elements beyond the collection 's length are not used , nevertheless , in a value-based collection , they are occupied . If each instance of class T requires considerable resources , then you should ensure that the collection 's capacity is not much greater than its length , otherwise unnecessary resources will be tied up . <p> Sets self to a copy of c . The copy constructor of all elements in @ @ @ @ @ @ @ @ @ @ same capacity and number of members as the old vector . <p> T&amp; operator() ( sizet i ) ; const T&amp; operator() ( sizet i ) const ; <p> Returns the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one . No bounds checking is performed . <p> T&amp; operator ( sizet i ) ; const T&amp; operator ( sizet i ) const ; <p> Returns the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsErr will be thrown . <p> Appends the value a to the end of the vector . The collection will automatically be resized if this causes the number of items in the collection to exceed the capacity . <p> T&amp; at ( sizet i ) ; const T&amp; at ( @ @ @ @ @ @ @ @ @ @ in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between 0 and the length of the vector less one or an exception of type RWBoundsErr will be thrown . <p> void clear() ; <p> Removes all items from the collection . <p> RWBoolean contains ( const T&amp; a ) const ; <p> Returns TRUE if the collection contains an item that is equal to a . A linear search is done . Equality is measured by the class-defined equality operator . <p> const T* data() const ; <p> Returns a pointer to the raw data of the vector . The contents should not be changed . Should be used with care . <p> sizet entries() const ; <p> Returns the number of items currently in the collection . <p> RWBoolean find ( const T&amp; target , T&amp; ret ) const ; <p> Performs a linear search and returns TRUE if the vector contains an object that is equal to the object target and puts a copy of the matching object into ret . Returns FALSE @ @ @ @ @ @ @ @ @ @ by the class-defined equality operator . <p> T&amp; first() ; const T&amp; first() const ; <p> Returns the first item in the collection . An exception of type RWBoundsErr will occur if the vector is empty . <p> sizet index ( const T&amp; a ) const ; <p> Performs a linear search , returning the index of the first item that is equal to a . Returns RWNPOS if there is no such item . Equality is measured by the class-defined equality operator . <p> void insert ( const T&amp; a ) ; <p> Appends the value a to the end of the vector . The collection will automatically be resized if this causes the number of items in the collection to exceed the capacity . <p> void insertAt ( sizet i , const T&amp; a ) ; <p> Inserts the value a into the vector at index i . The item previously at position i is moved to i+1 , etc . The collection will automatically be resized if this causes the number of items in the collection to exceed the capacity . The index i must be between @ @ @ @ @ @ @ @ @ @ an exception of type RWBoundsErr will occur . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in the collection , FALSE otherwise . <p> T&amp; last() ; const T&amp; last() const ; <p> Returns the last item in the collection . If there are no items in the collection then an exception of type RWBoundsErr will occur . <p> sizet length() const ; <p> Returns the number of items currently in the collection . <p> sizet occurrencesOf ( const T&amp; a ) const ; <p> Performs a linear search , returning the number of items that are equal to a . Equality is measured by the class-defined equality operator . <p> void prepend ( const T&amp; a ) ; <p> Prepends the value a to the beginning of the vector . The collection will automatically be resized if this causes the number of items in the collection to exceed the capacity . <p> RWBoolean remove ( const T&amp; a ) ; <p> Performs a linear search , removing the first object which is equal to the object a and returns TRUE . Returns FALSE if @ @ @ @ @ @ @ @ @ @ the class-defined equality operator . <p> sizet removeAll ( const T&amp; a ) ; <p> Removes all items which are equal to a , returning the number removed . Equality is measured by the class-defined equality operator . <p> T removeAt ( sizet i ) ; <p> Removes and returns the object at index i . An exception of type RWBoundsErr will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> T removeFirst() ; <p> Removes and returns the first object in the collection . An exception of type RWBoundsErr will be thrown if the list is empty . <p> T removeLast() ; <p> Removes and returns the last object in the collection . An exception of type RWBoundsErr will be thrown if the list is empty . <p> void resize ( sizet N ) ; <p> Changes the capacity of the collection to N. Note that the number of objects in the collection does not change , just the capacity . <p> Looks at the next object on the input stream @ @ @ @ @ @ @ @ @ @ and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677931 @4377931/ <p> Class RWBinaryTree represents a group of ordered elements , internally sorted by the compareTo() function . Duplicates are allowed . An object stored by an RWBinaryTree must inherit abstract base class RWCollectable . <p> Redefined from class RWCollection to apply the user-supplied function pointed to by ap to each member of the collection , in order , from smallest to largest . This supplied function should not do anything to the items that could change the ordering of the collection . <p> void balance() ; <p> Special function to balance the tree . In a perfectly balanced binary tree with no duplicate elements , the number of nodes from the root to any external ( leaf ) node differs by at most one node . Since this collection allows duplicate elements , a perfectly balanced tree is not always possible . Preserves the order of duplicate elements . <p> Returns the number of nodes between the root node and the farthest leaf . A RWBinaryTree with one entry will have a height of 1 . Note that the entire tree is traversed to discover this value . <p> @ @ @ @ @ @ @ @ @ @ from class RWCollection . Inserts the item c into the collection and returns it . Returns nil if the insertion was unsuccessful . The item c is inserted according to the value returned by compareTo(). insert() does not automatically balance the RWBinaryTree . Be careful not to insert() a long sequence of sorted items without calling balance() since the result will be very unbalanced ( and therefore inefficient ) . 
@@75677932 @4377932/ <h> Service Manager - SOA Policy Management and Governance <p> Service Manager is the industrys leading SOA management and security product . It follows the SOA Infrastructure Reference Model delivering comprehensive standards-based security , routing , mediation , monitoring , and management for SOA and Web services . It is the industry 's most scalable and high performance SOA infrastructure product . <p> Service Manager is deployed together with Policy Managerproviding the industrys broadest and deepest SOA Management and SOA Security solution . It implements and enforces policies from Policy Manager , and generates usage , performance and policy compliance metrics that it reports to Policy Manager to enable a closed-loop process for auditing that policies are being correctly enforced . <p> Service Managers intermediaries provide the foundation for SOA management , security , and run-time policy enforcement . They cover the widest possible surface area of applications and offer the broadest and deepest functionality of any SOA intermediaries on the market . <p> The Agents deploy into the container to ensure last-mile security and policyenforcement for services . Akana offers agents for most common Java application servers , @ @ @ @ @ @ @ @ @ @ tools . The agents are fully functional , platform-native , and non-invasive offering complete last-mile policy enforcement including on-board cryptographic operations without having to change any deployed applications or services . <p> The Network Director is a stand-alone smart service router that deploys into the network supporting a wide range of intermediary patterns for routing , service virtualization , **32;10278;TOOLONG and others . It is fully stateless , offering exceptional performance and scalability combined with unique capabilities for mediation , routing , and policy enforcement . <p> The Delegate is a client-side intermediary that deploys seamlessly into consumer applications to abstract the application from the location , transport , and policies required by the services it will consume . Akana offers delegates for Java applications and . NET , and packages the delegate in a wide range of forms with simple , non-invasive deployment options for most common service platforms and containers , including ESBs and business process management tools . <p> Ensure that policies are being effectively enforced with a comprehensive metrics collection model <p> Capture performance and usage metrics according to policies <p> Statistically and algorithmically capture comprehensive @ @ @ @ @ @ @ @ @ @ exceptions <p> Compare and reconcile collected metrics with policies for audit purposes <p> Enforce policies managed by a centralized governance solution <p> Consistently enforce policies across all popular service containers including , Java and . NET app servers , ESBs , mainframe , and packaged applications <h> Mediation <p> Service Manager offers comprehensive SOA mediation capabilities to ensure that the broadest possible set of consumers can access published services for which they have access rights . It provides : <p> Mediation between consumer capabilities and provider security policies - e.g. it can take a request from a consumer that only supports Kerberos and generate a SAML assertion for a service that requires SAML <p> Standards mediation mediate between the various different but similar standards , and the various different versions of the same standard <h> Management and Routing <p> Service Manager provides powerful service monitoring , management , and routing capabilities . It decouples the management model from the development process , allowing developers to focus on their business logic and interfaces , delegating the implementation and enforcement of security , reliability , and messaging policies to the infrastructure . @ @ @ @ @ @ @ @ @ @ : <p> Performance , throughput , and reliability monitoring of services provided both internally and externally <h> Security <p> Service Manager provides the industrys most comprehensive SOA security solution for trust enablement of Web services providers and consumers . It decouples the security model from the development process , allowing developers to focus on their business logic and interfaces . It offers : <p> Comprehensive end-to-end security of Web services messages <p> Authentication supporting a wide range of different credential types and authentication providers <p> Authorization via an internal access control system and certified integration with leading identity and access management systems <p> Privacy encryption and decryption using the XML-Encryption standard and built-in PKI <p> Non-repudiation signature and signature verification using the XML-DigitalSignature standard <p> Service Managers intermediaries provide the foundation for SOA management , security , and run-time policy enforcement . They cover the widest possible surface area of applications and offer the broadest and deepest functionality of any SOA intermediaries on the market . <p> Consistent policy enforcement and implementation for all popular service containers including Java and . NET app servers , ESBs , mainframe , and packaged applications 
@@75677933 @4377933/ <h> On-Demand Webinar : A Comparison of Open Source Software ESB Solutions <p> The case for implementing a Service-Oriented Architecture ( SOA ) with an Enterprise Service Bus ( ESB ) backbone is clear , and enterprises today have many open source ESB options to choose from . In this webinar Rod Cope , CTO and Founder of OpenLogic , provides a comparison of the leading open source ESB solutions , including JBoss ESB , Mule ESB , Open ESB , Petals , ServiceMix , and Synapse . Rod discusses which ESB options are best suited to different enterprise SOA needs as well as how to approach migrations from commercial ESB solutions like Oracle ESB. 
@@75677934 @4377934/ <p> RWDBCritFormDefinition is a base class for a family of classes which provide an extensible mechanism that an application can use to define functional notation for RWDBCriterion . RWDBCritFormDefinition allows a programmer to create an object that will translate into an RWDBCriterion and eventually be expanded into an SQL string . The object will allow up to four expressions to be embedded into the resultant string . <p> An RWDBCritFormDefinition object is instantiated with a format string . The format string may contain placeholders for up to four positional parameters , which are labeled %0 through %3 . An object defined in this way may subsequently be referenced in the same way that predefined functions like rwdbMax and rwdbAvg are referenced . <p> When an RWDBCritFormDefinition object is expanded by the asString() method of an RWDBCriterion , each instance of %0 is replaced with the first actual argument , each instance of %1 is replaced with the second actual argument , and so on . There can be multiple instances of a placeholder in the format string , and the placeholders may occur in any order . This allows @ @ @ @ @ @ @ @ @ @ losing compile-time checking on the number of arguments actually passed . To enable compile-time checking on the number of actual arguments , at the cost of some flexibility , use the RWDBCritFuncDefn classes . <p> Imagine that a database vendor 's SQL variant provides the boolean function VALIDNAME(string) , which can be used in a WHERE clause . DBTools.h++ has no direct support for this function , yet we would like to use it without losing the benefits of high-level constructs for data manipulation . To do so , we can use a function which we define ourselves : <p> RWDBCritFuncDef0 , RWDBCritFuncDef1 , RWDBCritFuncDef2 , RWDBCritFuncDef3 , and RWDBCritFuncDef4 are derived from RWDBCritFormDefinition . They provide a simplified interface for functions requiring 0-4 arguments , respectively , and do not require positional placeholders. 
@@75677935 @4377935/ <p> Returns a reference to the value associated with key . If there is no element with key key , then a new association with that key is created and inserted into self . Prior to assignment , the value part of this association is garbage . <p> Applies the user-defined function pointed to by appFn to every item in the collection . Client data may be passed through parameter d . <p> clear() ; <p> Clears the collection by removing all pairs from self . <p> RWBoolean contains ( const K&amp; a ) const ; <p> Returns TRUE if there exists a pair in self with key k such that the expression ( *k == *a ) is TRUE . Otherwise , returns FALSE . <p> sizet entries() const ; <p> Returns the number of items in self . <p> RWBoolean find ( const K&amp; a , K&amp; retKey ) const ; <p> If there exists a pair in self with key k such that the expression ( k == a ) is TRUE , places the found key in retKey and returns TRUE . Otherwise , returns @ @ @ @ @ @ @ @ @ @ K&amp; retKey , V&amp; retval ) const ; <p> If there exists a pair in self with key k such that the expression ( k == a ) is TRUE , places the key part of the pair in retKey , the value part of the pair in retval and returns TRUE . Otherwise , returns FALSE . <p> RWBoolean findValue ( const K&amp; a , K&amp; retVal ) const ; <p> If there exists a pair in self with key k such that the expression ( k == a ) is TRUE , places the value part of the pair in retVey . Otherwise , returns FALSE . <p> void insertKeyAndValue ( const K&amp; k , const V&amp; v ) ; <p> If find(k) would fail , inserts a new pair holding k and v ; otherwise , replaces with v the value associated with k . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in the collection , FALSE otherwise . 
@@75677937 @4377937/ <p> **27;10312;TOOLONG is a pointer-based sorted collection . That is , the items in the collection have a meaningful ordered relationship with respect to each other and can be accessed by an index number . In the case of **27;10341;TOOLONG , objects are inserted such that objects " less than " themselves are before the object , objects " greater than " themselves after the object . An insertion sort is used . Duplicates are allowed . <p> Stores a pointer to the inserted item into the collection according to an ordering determined by the less-than ( &lt; ) operator . <p> The class T must have : <p> well-defined equality semantics ( T : : operator== ( const T&amp; ) ) ; <p> well-defined less-than semantics ( T : : operator&lt; ( const T&amp; ) ) ; <p> Although it is possible to alter objects that are referenced by pointers within a **27;10370;TOOLONG , it is dangerous since the changes may affect the way that operator&lt; ( ) and operator== ( ) behave , causing the **27;10399;TOOLONG to become unsorted . <p> Sets self to a shallow copy @ @ @ @ @ @ @ @ @ @ the two collections . <p> T*&amp; operator() ( sizet i ) ; T* const&amp; operator() ( sizet i ) const ; <p> Returns a pointer to the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one . No bounds checking is performed . When used as an lvalue , care must be taken so as not to disturb the sortedness of the collection . <p> T*&amp; operator ( sizet i ) ; T* const&amp; operator ( sizet i ) const ; <p> Returns a pointer to the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsError will be thrown . When used as an lvalue , care must be taken so as not to disturb the sortedness of the collection . <p> Returns a pointer @ @ @ @ @ @ @ @ @ @ variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsError will be thrown . When used as an lvalue , care must be taken so as not to disturb the sortedness of the collection . <p> void clear() ; <p> Removes all items from the collection . <p> void clearAndDestroy() ; <p> Removes all items from the collection and deletes them . Do not use this method if multiple pointers to the same object are stored . <p> RWBoolean contains ( const T* a ) const ; <p> Returns TRUE if the collection contains an item that is equal to the object pointed to by a , FALSE otherwise . A binary search is done . Equality is measured by the class-defined equality operator for type T. <p> T* const * data() const ; <p> Returns a pointer to the raw data of the vector . The contents should not be changed . Should be used with care . <p> sizet entries() const @ @ @ @ @ @ @ @ @ @ collection . <p> T* find ( const T* target ) const ; <p> Returns a pointer to the first object encountered which is equal to the object pointed to by target , or nil if no such object can be found . A binary search is used . Equality is measured by the class-defined equality operator for type T. <p> T* const&amp; first() const ; <p> Returns a pointer to the first item in the vector . An exception of type RWBoundsError will occur if the vector is empty . <p> sizet index ( const T* a ) const ; <p> Performs a binary search , returning the index of the first object that is equal to the object pointed to by a , or RWNPOS if there is no such object . Equality is measured by the class-defined equality operator for type T. <p> void insert ( T* a ) ; <p> Performs a binary search , inserting the object pointed to by a after all items that compare less than or equal to it , but before all items that do not . " Less than " is @ @ @ @ @ @ @ @ @ @ T. The collection will be resized automatically if this causes the number of items to exceed the capacity . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in the collection , FALSE otherwise . <p> T* const&amp; last() const ; <p> Returns a pointer to the last item in the collection . If there are no items in the collection then an exception of type RWBoundsError will occur . <p> sizet length() const ; <p> Returns the number of items currently in the collection . <p> sizet occurrencesOf ( const T* a ) const ; <p> Performs a binary search , returning the number of items that are equal to the object pointed to by a . Equality is measured by the class-defined equality operator for type T. <p> T* remove ( const T* a ) ; <p> Performs a binary search , removing the first object which is equal to the object pointed to by a and returns a pointer to it , or nil if no such object could be found . Equality is measured by the class-defined equality operator for type T. @ @ @ @ @ @ @ @ @ @ Performs a binary search , removing all objects which are equal to the object pointed to by a . Returns the number of objects removed . Equality is measured by the class-defined equality operator for type T. <p> T* removeAt ( sizet i ) ; <p> Removes the object at index i and returns a pointer to it . An exception of type RWBoundsError will be thrown if i is not a valid index . Valid indices are from zero to the number of items in the list less one . <p> T* removeFirst() ; <p> Removes the first item in the collection and returns a pointer to it . An exception of type RWBoundsError will be thrown if the list is empty . <p> T* removeLast() ; <p> Removes the last item in the collection and returns a pointer to it . An exception of type RWBoundsError will be thrown if the list is empty . <p> void resize ( sizet N ) ; <p> Changes the capacity of the collection to N. Note that the number of objects in the collection does not change , just the capacity @ @ @ @ @ @ @ @ @ @ stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677940 @4377940/ <h> Member Functions <p> The RWServerPool object is an RWRunnableServer that manages a " pool " of other RWRunnableServer instances that are used to start runnable objects submitted for execution by other threads . A server pool object , when started , waits for other threads to enqueue runnable objects that they would like to have executed . Each runnable object that the server finds in its internal queue is dequeued and is passed to the next available runnable server from the pool . This process continues until the server pool object is interrupted , canceled , or stopped . <p> Runnables may be enqueued with a guard functor , or a priority value , or both . <p> The guard functor is used by the server to determine whether the associated runnable is currently eligible for retrieval and execution . A guarded runnable is not retrieved by the server until that runnable is the first runnable in the queue whose guard evaluates to TRUE . Using guards to block runnable execution is important when implementing active objects ; guards can be used to insure that the active object @ @ @ @ @ @ @ @ @ @ The priority value is used during write operations to determine a runnable 's insertion point within the server 's input queue , such that the set of un-processed and eligible runnables will be retrieved in priority order by the server . <p> The number of runnable servers to create for the internal pool may be specified when the server pool instance is created . A server pool instance does not create the RWRunnableServer instances for the pool , and does not process any enqueued runnables until the start() member is called . No runnables may be enqueued until the server pool is started . <p> The size of the runnable server pool may be adjusted after construction using the resize() member . <p> The stop() member is used to initiate server pool shutdown . The server pool will continue to dispatch any runnables already enqueued when stop() is called , but no additional runnables may be enqueued after that point . Once the pending runnables have been dispatched , the server pool thread will stop and join with the runnable servers in the pool and then exit . The stop @ @ @ @ @ @ @ @ @ @ to wait for the server pool thread to complete its shutdown exit , use the join() function . <p> The RWRunnable : : requestCancellation() function should be used if the server thread is to stop execution as soon as possible without dequeuing and dispatching any additional runnables . <p> The RWRunnable : : requestInterrupt() function can be used to temporarily suspend execution of the server thread . <p> Gets a handle to the thread attribute instance specified during server pool construction or the instance specified in the last call to setPoolAttribute() . <p> static RWServerPool make ( sizet numThreads ) <p> Makes a runnable server pool instance with the specified number of pool threads . The server pool 's main thread and its pool threads will be created with default thread attributes . <p> static RWServerPool make ( sizet numThreads , sizet maxCapacity ) <p> Makes a runnable server pool instance with the specified number of pool threads and whose input queue has the specified maximum capacity . The server pool 's main thread and its pool threads will be created with default thread attributes . <p> Makes a server @ @ @ @ @ @ @ @ @ @ specified thread attributes , and whose pool will contain numThreads threads , each created with a default set of thread attributes . <p> Makes a server pool instance whose main thread will be created with the specified thread attributes , whose pool will contain numThreads threads , each created with a default set of thread attributes , and whose input queue has the specified maximum capacity . <p> Makes a server pool instance whose main thread will be created with default thread attributes , whose pool will contain numThreads threads , each created with the specified set of thread attributes , and whose input queue has the specified maximum capacity . <p> Makes a server pool instance whose main thread will be created with the thread attributes specified by the first thread attribute object , and whose pool will contain numThreads threads , each created with the thread attributes specified by the second thread attribute object . <p> Makes a server pool instance whose main thread will be created with the thread attributes specified by the first thread attribute object , whose pool will contain numThreads threads , each created @ @ @ @ @ @ @ @ @ @ object , and whose input queue has the specified maximum capacity . <p> Changes the number of threads within the thread pool . If the new thread pool size is less than the current size , then a sufficient number of threads will be destroyed but only after they have completed execution of any assigned runnable object . If the size is greater than the current size , the pool server thread will create a sufficient number of new threads and add them to the pool . <p> Changes the thread attribute instance used to initialize new runnable server objects as they are created for the thread pool . Changing the pool thread attributes after the server has started will only affect new threads started by the pool server in response to a request for a larger pool size ; existing threads will continue with their original attributes . <p> Returns the target size for the thread pool . May be less than or greater than the actual number of runnable server instances in the pool , since the pool server thread may not yet have completed a previously requested expansion or contraction of the thread pool . 
@@75677942 @4377942/ <p> Class RWBTree represents a group of ordered elements , not accessible by an external key . Duplicates are not allowed . An object stored by class RWBTree must inherit abstract base class RWCollectable -- the elements are ordered internally according to the value returned by virtual function compareTo() ( see class RWCollectable ) . <p> This class has certain advantages over class RWBinaryTree . First , the B-tree is automatically balanced . ( With class RWBinaryTree , you must call member function balance() explicitly to balance the tree . ) Nodes are never allowed to have less than a certain number of items ( called the order ) . The default order is 50 , but may be changed by resetting the value of the static constant " order " in the header file &lt;rw/btree.h&gt; and recompiling . Larger values will result in shallower trees , but less efficient use of memory . <p> Because many keys are held in a single node , class RWBTree also tends to fragment memory less . <p> Returns TRUE if self is a subset of btr . That is , for @ @ @ @ @ @ @ @ @ @ in btr that compares equal . Note : If you inherit from RWBTree in the presence of the Standard C++ Library , we recommend that you override this operator and explicitly forward the call . Overload resolution in C++ will choose the Standard Library provided global operators over inherited class members . These global definitions are not appropriate for set-like partial orderings . <p> RWBoolean operator== ( const RWBTree&amp; btr ) const ; <p> Returns TRUE if self and btr are equivalent . That is , they must have the same number of items and for every item in self , there must be an item in btr that compares equal . <p> Redefined from class RWCollection to apply the user-supplied function pointed to by ap to each member of the collection , in order , from smallest to largest . This supplied function should not do anything to the items that could change the ordering of the collection . <p> Special member function of this class . Returns the height of the tree , defined as the number of nodes traversed while descending from the root node to an @ @ @ @ @ @ @ @ @ @ ( RWCollectable* c ) ; <p> Redefined from class RWCollection . Inserts the item c into the collection and returns it . The item c is inserted according to the value returned by compareTo() . If an item is already in the collection which isEqual to c , then the old item is returned and the new item is not inserted . Otherwise returns nil if the insertion was unsuccessful . 
@@75677943 @4377943/ <p> Class RWSet represents a group of unordered elements , not accessible by an external key , where duplicates are not allowed . It corresponds to the Smalltalk class Set . <p> An object stored by RWSet must inherit abstract base class RWCollectable , with suitable definition for virtual functions hash() and isEqual() ( see class RWCollectable ) . The function hash() is used to find objects with the same hash value , then isEqual() is used to confirm the match . <p> An item c is considered to be " already in the collection " if there is a member of the collection with the same has value as c for which isEqual(c) returns TRUE . In this case , method insert(c) will not add it , thus insuring that there are no duplicates . <p> Returns TRUE if self and h have the same number of elements and if for every key in self there is a corresponding key in h which isEqual . <p> RWBoolean operator ! = ( const RWSet&amp; h ) ; <p> Returns the negation of operator== ( ) , above . <p> @ @ @ @ @ @ @ @ @ @ TRUE if self is a subset of h , that is , every element of self has a counterpart in h which isEqual . Note : If you inherit from RWSet in the presence of the C++ Standard Library , we recommend that you override this operator and explicitly forward the call . Overload resolution in C++ will choose the Standard Library provided global operators over inherited class members . These global definitions are not appropriate for set-like partial orderings . <p> RWBoolean operator&lt; ( const RWSet&amp; h ) ; <p> Returns TRUE if self is a proper subset of h , that is , every element of self has a counterpart in h which isEqual , but where the two sets are not identical . <p> Redefined from class RWCollection to apply the user-supplied function pointed to by ap to each member of the collection in a ( generally ) unpredictable order . This supplied function must not do anything to the items that could change the ordering of the collection . 
@@75677944 @4377944/ <h> 2.2 Description of the Core Classes <p> This section describes the core classes in the public interface of the Objective Grid for Microsoft . NET control . All of the classes are contained in the Stingray.Grid namespace . <h> Table 3 : Most Commonly Used Classes <p> GridControl <p> The GridControl class represents and embodies an Objective Grid for Microsoft . NET grid control . The GridControl custom control is added to the Visual Studio . NET toolbox when Objective Grid for Microsoft . NET is installed . When a GridControl is dragged onto a Windows Form , an instance of the GridControl class is created . The GridControl class contains a rich public interface , a rich set of public events , a number of properties , and a customizable virtual method interface . <p> Cell <p> The Cell class represents a single cell in the grid . A cell is referenced by a row offset and a column offset . The Cell class contains properties for the cell 's row , column , text , and style . <p> Range <p> The Range class represents a @ @ @ @ @ @ @ @ @ @ can be used for operations that apply to a group of cells . <p> Style <p> The Style class is central to formatting cells in the grid . A style object can be seen as an object that completely defines a cell . This means that the style object has all the information necessary for the grid object to draw the cell and manage its interaction with users . This information includes the font used to draw the cell , the color of the cell 's interior , the size of the font , the value displayed , and the type of control in the cell . Style objects for each cell are stored internally by the grid . The format of a grid cell can be changed programmatically through the manipulation of the style property of the cell . <p> Param <p> The Param ( short for Parameter ) class stores all data necessary for persisting the state of a grid object . Parameter objects can be stored in documents and serialized , or used as members of other classes . Parameter objects can also be shared between grid @ @ @ @ @ @ @ @ @ @ in the grid control . A cell is referenced using row and column offsets into the grid . By default , the grid reserves the first row for column headers and the first column for row headers , as shown in Figure 1 . The header row and column are numbered row 0 and column 0 , respectively . <p> In Figure 1 , the cell at row 1 and column A has row and column offsets 1 , 1 . This cell is referenced in source code as follows : <p> C# : <p> Cell cell = gridControl11,1 ; cell.Style.Value = " Hello " ; <p> Visual Basic : <p> Dim cell As Cell cell = GridControl1 ( 1 , 1 ) cell.Style.Value = " Hello " <p> The Cell class is included in the Stingray.Grid namespace . To reference the Cell class as shown above , this namespace must be opened for use as follows : <p> C# : <p> using Stingray.Grid ; <p> Visual Basic : <p> Imports Stingray.Grid <p> Instances of the Cell class can be obtained only through an instance of the GridControl class . @ @ @ @ @ @ @ @ @ @ the GridControl from which the cell was obtained . This allows the Cell instance to be used to change the properties of the referenced cell in the referenced grid . Cell instances can be used to change the style , text , formula , and other properties of a given grid cell . For example , the following code changes the cell at row 1 and column 2 so that it is read-only and is displayed using the Courier font . <p> For efficiency , changes to individual attributes of the cell style are not applied to the grid cell immediately . Instead , style changes must be made as shown above . All desired changes to the cell style are performed in sequence . These changes are not visible in the grid cell until the cell style is applied back to the cell through an assignment of the updated cell style object . <p> For a complete description of the public interface to Cell , see the Objective Grid for Microsoft . NET Reference Guide . <p> The Range class represents a rectangular range of cells in the grid @ @ @ @ @ @ @ @ @ @ , an entire row , or the entire table . Explicit coordinates can also be initialized with the top , bottom , left , and right members of a Range object . <p> Range objects appear frequently in the interface to GridControl . Ranges are used for assigning styles and values to ranges of cells . Ranges are also used to hide , clear , move , copy , and select ranges of cells . <p> For a complete description of the public interface to Range , see the Objective Grid for Microsoft . NET Reference Guide . <h> Table 6 : Range Class Public Methods <p> Creates a range from left , top , right , and bottom row and column indexes <p> IntersectRange <p> Determines if two ranges intersect <p> InvalidRange <p> Returns an empty range <p> Row <p> Returns a range consisting of one row <p> Rows <p> Returns a range of the specified rows <p> Table <p> Creates a range that references an entire table <p> UnionRange <p> Calculates the union of two ranges <p> Clone <p> Creates a copy of this Range <p> Equals <p> @ @ @ @ @ @ @ @ @ @ ExpandRange <p> Sets the range based on the top , left corner of the range , and the number of rows and columns in the range . <p> GetFirstCell <p> Gets the first cell in a range <p> GetHashCode <p> Calculates the hash code for this range <p> GetNextCell <p> Overloaded . Gets the next cell in a range in row order <p> InsertCols <p> Inserts columns into a range at a specified starting location <p> InsertRows <p> Inserts rows into the range at the specified location <p> IntersectRange <p> Determines if this range intersects with a specified range <p> IsCellInRange <p> Returns true if and only if a specified cell coordinate is within this range <p> Use the Cells() method to specify a rectangular range of cells with well-defined top-left and bottom-right cells . <p> Use the Rows() , Cols() , and Table() methods to define regions without definite top-left or bottom-right coordinates . These methods define the range as being entire rows , entire columns , or the entire table , independent of the actual grid dimensions . This means that as the dimensions of the grid grow @ @ @ @ @ @ @ @ @ @ grow or shrink . For example , a grid with 10 rows , 10 columns , and a range defined using Cols(2,4) has the realized coordinates of top = 0 , bottom = 10 , left = 2 , and right = 4 , as shown in Figure 2 . <p> If the last three rows of the grid are removed , the realized coordinates of the same range are now top = 0 , bottom =7 , left = 2 , and right = 4 . No changes were made to the original range . It is still defined as Cols(2,4) . <p> Ranges do not change when rows or columns are inserted into or deleted from the grid . In the example above , if we insert a new column between columns three and four , the range does not expand to reflect the addition . The range is still Cols(2,4) . <p> Calls to Rows() , Cols() , Cells() , and Table() are not cumulative . You can not combine successive calls to these methods to define more complex range of cells . A call to any @ @ @ @ @ @ @ @ @ @ calling Rows(4,7) followed by Cols(2,5) results in a range of Cols(2,5) , not the intersection or union of the two ranges . <p> The Style class encapsulates all of the information required to format a cell in a grid control . In addition to formatting information , styles also define most of the grid 's behavior . The style information for a cell or a range of cells can be obtained from a Cell object . Style objects can also be applied to a cell or range of cells to change the format of that cell or range . The following code snippets show the use of a style object to format a range of cells in a grid control . <p> The Style class supports combining style objects . For example , you can copy from one style to a second style only the properties that are not initialized in the second style . This feature allows you to combine styles and is analogous to the concept of inheritance in programming languages . You can specify a base style from which other styles can inherit properties at run time @ @ @ @ @ @ @ @ @ @ an include bit . This include bit is true when a property is initialized . If it is false , the property is not initialized . When drawing the grid , Objective Grid for Microsoft . NET fills up all uninitialized properties of the cell style object with values inherited from the base styles . <p> Making a change to a cell 's style is an expensive operation . Because changes to a cell 's style are automatically updated when assigned , making many changes sequentially can decrease your application 's performance . The following code shows this penalty : <p> An instance of the Param class contains or points to all necessary data for persisting the state of the grid object . Parameter objects can be stored in documents and serialized , or can be used as members of other classes . Parameter objects can also be shared between grid objects . <p> For a complete description of the public interface to Param , see the Objective Grid for Microsoft . NET Reference Guide . <h> Table 10 : Public Instance Methods <p> Method <p> Description <p> EnableTrackingColWidth <p> @ @ @ @ @ @ @ @ @ @ widths for the end user . <p> EnableTrackingRowHeight <p> Overloaded . Specifies the options for or disables changing row heights for the end user . <p> Finalize <p> Destructor . <p> ReInitializeData <p> Reinitializes the embedded OGData and OGParam objects . <h> Table 11 : Public Instance Properties <p> Property <p> Description <p> CellActivationMode <p> Determines the options for activating/editing the current cell . <p> DrawOrder <p> Gets or sets the drawing order . <p> EnableHorizontalSorting <p> Gets or sets row sorting when double clicked . <p> EnableVerticalSorting <p> Gets or sets column sorting when double clicked . <p> ExcelLikeCurrentCell <p> Gets or sets the default Objective Grid or Excel-like behavior of the current cell . <p> ExcelLikeHeaders <p> Gets or sets the Excel-like behavior of the headers . <p> ExcelLikeScrolling <p> Gets or sets scroll behavior to mimic Excel scroll behavior . <p> ExcelLikeSelectionFrame <p> Gets or sets the option to draw a small frame around the selected range of cells . <p> The GridControl class encapsulates the Objective Grid for Microsoft . NET custom control . It is derived from the Windows.Forms.Panel class ( which is derived from @ @ @ @ @ @ @ @ @ @ , properties , and events from its base class . It also adds a rich public interface , a number of properties , and many events of its own . <p> Windows Forms custom controls allow you to quickly create user interfaces by re-using existing controls . The Objective Grid for Microsoft . NET custom control is an example of the benefits of this programming paradigm . To use the GridControl , you drag a GridControl from the Toolbox in Visual Studio onto a Windows form , and an instance of GridControl is created and displayed for design-time editing . The public properties and events defined for GridControl appear in the property grid for design-time manipulation . <p> For a complete description of the public interface to GridControl , see the Objective Grid for Microsoft . NET Reference Guide . <p> The Windows Forms Designer generates the code needed to instantiate , initialize , format ( according to the selected design-time property settings ) , and display the grid . All of the following code is generated by the Windows Forms Designer : <p> GridControl defines a number of public @ @ @ @ @ @ @ @ @ @ you to handle grid events in one of two ways . <p> You can derive a new control class from GridControl , override the virtual event handler methods , and include custom event-handling logic for the events . This technique must be used when you want to completely avoid executing the base class ( GridControl ) event-handling logic for an event . Do not call the base class event handler . <p> The base class event handler must be called in order to invoke any delegates attached to the event . <p> You can attach delegates to the events and handle the events in those delegates . This mechanism is convenient , particularly when using the Windows Forms Designer . You can double-click the name of the event to be handled , and the Windows Forms Designer automatically generates a delegate stub and attaches it to the event . You then write the event-handling logic in the generated delegate stub . <p> Using delegates does not give you any control over how or when the base class event-handling logic is executed ( except in special cases where event-handling options are @ @ @ @ @ @ @ @ @ @ <p> Once the GridControl is placed into a Windows Form and all desired design-time configurations are complete , you can use the public interface to the GridControl to programmatically control the grid and respond to grid events . <p> This section describes the methods of the GridControl class . Table 12 lists public and protected methods available for GridControl . <h> Table 12 : GridControl Public and Protected Methods <p> Method <p> Description <p> BeginInit <p> Implements ISupportInitialize . <p> CalcClientColFromPt <p> Determines the column for the point . <p> CalcClientRowFromPt <p> Determines the row for the point . <p> CalcRectFromRowColEx <p> Overloaded . Computes the window-area for the given range of cells . <p> CalcSumOfColWidths <p> Overloaded . Computes the total width of the given columns . If the total width exceeds nAbortAt , the method aborts and returns the value that is greater than nAbortAt . <p> CalcSumOfRowHeights <p> Overloaded . Computes the total height of the given rows . <p> CanClear <p> Determines if the currently selected range of cells can be cleared . <p> CanCopy <p> Determines if the currently selected range of cells can be @ @ @ @ @ @ @ @ @ @ range of cells can be cut . <p> CanPaste <p> Determines if a range of cells on the clipboard can be pasted into the grid . <p> CanSelectCurrentCell <p> Determines if the new current cell can be selected or the old current cell deselected . <p> ClearCells <p> Overloaded . Clears a range of cells . <p> ConvertClientCol <p> Converts the specified column index into a relative index . <p> ConvertClientRow <p> Converts the specified row index into a relative index . <p> ConvertCol <p> Converts the specified column index into an absolute index . <p> ConvertRow <p> Converts the specified row index into an absolute index . <p> CopyCells <p> Overloaded . Copies a range of cells to a specified location in the grid . <p> DelayFloatCells <p> Overloaded . Recalculates floating cells . <p> DelayMergeCells <p> Overloaded . Recalculates merge cells . <p> DesignTimeInitialize <p> Performs some specialized design-time grid initialization . <p> EndInit <p> Implements ISupportInitialize . <p> GetColWidth <p> Gets the column width , in pixels , of the specified column . If it is 0 then the column is hidden . <p> GetExpressionRowCol <p> Gets @ @ @ @ @ @ @ @ @ @ <p> Returns the height of the standard-style font in pixels . <p> GetFontWidth <p> Returns the average width of the standard-style font in pixels . <p> GetGridRect <p> Returns the window area for the grid . <p> GetRowHeight <p> Gets the row height , in pixels , of the specified column . If it is 0 , the row is hidden . <p> GetSelectedCols <p> Overloaded . Returns an array containing the selected column IDs . <p> GetSelectedRows <p> Overloaded . Returns an array containing the selected row IDs . <p> GetValueRowCol <p> Gets the value stored in a cell . <p> HeightDPtoLP <p> Divides the pixel-value by the value determined through GetFontHeight . <p> HeightLPtoDP <p> Multiplies the logical value with the value determined through GetFontHeight . <p> HideCols <p> Overloaded . Hides the specified columns . <p> HideRange <p> Hides a range of cells . <p> HideRows <p> Overloaded . Hides the specified rows . <p> HitTest <p> Determines the type of information displayed at a window coordinate ( pt ) . <p> Initialize <p> Initializes a GridControl object state at runtime . <p> InitParamObject <p> Initializes the @ @ @ @ @ @ @ @ @ @ columns . <p> InsertRows <p> Overloaded . Inserts rows . <p> IsActiveCurrentCell <p> Returns true if the current cell is active . <p> IsColHidden <p> Determines if the specified column is hidden . <p> IsCurrentCell <p> Overloaded . Determines if a current cell is selected or is the specified cell . <p> IsRowHidden <p> Determines if the specified row is hidden . <p> LockUpdate <p> Overloaded . Prevents display of updates until lockUpdate(false) is called . <p> MoveCells <p> Overloaded . Moves a range of cells . <p> MoveCols <p> Overloaded . Moves the specified block of columns to another location . <p> MoveCurrentCell <p> Overloaded . Selects a new current cell based on an offset from the existing current cell . <p> MoveRows <p> Overloaded . Moves the specified block of rows to another location . <p> OnClear <p> Overloaded . Raises the Clear event . <p> OnCopy <p> Raises the Copy event . <p> OnCut <p> Raises the Cut event . <p> OnFind <p> Raises the Find event . <p> OnGetStyleRowCol <p> Raises the GetStyleRowCol event . <p> OnPaste <p> Raises the Paste event . <p> OnPrint <p> @ @ @ @ @ @ @ @ @ @ Raises the PrintPreview event . <p> OnRedo <p> Raises the Redo event . <p> OnReplace <p> Raises the Replace event . <p> OnUndo <p> Raises the Undo event . <p> RedrawGrid <p> Overloaded . Redraws the whole grid . <p> RedrawRowCol <p> Overloaded . Redraw the specified range of cells . <p> RegisterControl <p> Registers a . NET control for use as a Objective Grid for Microsoft . NET cell editor . <p> RemoveCols <p> Overloaded . Removes a block of columns . <p> RemoveRows <p> Overloaded . Removes a block of rows . <p> ResetCurrentCell <p> Overloaded . Deactivates the current cell . <p> ScrollCellInView <p> Overloaded . Scrolls the cell into the view if it is outside the visible area . <p> SelectRange <p> Overloaded . Selects or deselects a range of cells . <p> SetColCount <p> nColsthe number of columns for the grid rFlagsthe RedrawFlags for the operation <p> SetColWidth <p> Overloaded . Sets the column-widths for specific columns in pixels . <p> SetCoveredCellsRowCol <p> Overloaded . Sets the covered cells-range for a cell . <p> SetExpressionRowCol <p> Overloaded . Stores the expression in the specified cell @ @ @ @ @ @ @ @ @ @ of floating cells in the grid . <p> SetGridLineStyle <p> Set the grid line style . <p> SetGridRect <p> Overloaded . Sets the grid rectangle for the window . <p> SetMergeCellsMode <p> Turns on and off the calculation of merge cells in the grid . <p> SetRowCount <p> Sets the number of rows in the grid . <p> SetRowHeight <p> Overloaded . Sets the row-heights for specific rows in pixels . <p> SetStyleRange <p> Overloaded . Applies cell formatting to the specified range of cells . <p> SetValueRange <p> Overloaded . Sets a range of cells with the specified value . <p> TransferCurrentCell <p> Overloaded . Stores and deactivates the current cell or actualizes the current cell 's contents . <p> UseControl <p> Uses the named CellControl in the grid at the named row and column location . <p> WidthDPtoLP <p> The method divides the pixel-value by the value determined through GetFontWidth . <p> WidthLPtoDP <p> The method multiplies the logical value with the value determined through GetFontWidth . <p> Finalize <p> Destructor . <p> UpdateFrozenCols <p> Overloaded . Updates the window after freezing columns . <p> UpdateFrozenRows <p> Overloaded @ @ @ @ @ @ @ @ @ @ 13 lists the virtual event handlers that are available with GridControl . Each of these methods raises its corresponding event ( to invoke any attached delegates ) when it is invoked . When overriding these methods , the base ( GridControl ) implementation of the method must be invoked from the derived class implementation , in order to invoke any attached delegates . <p> This section lists the events available to be handled in the GridControl class . <p> Each event has an associated virtual event handler , whose name is prefixed with " On " . The grid-specific event handlers ( those not inherited from the Windows.Forms.Control class ) accept an event arguments object whose type name is formed by the name of the event plus the text " EventArgs " . For example , the CancelEditing event has an associated event handler named " OnCancelEditing " , and the argument passed to " OnCancelEditing " is of type " CancelEditingEventArgs " . <p> A delegate attached to grid-specific events accepts two arguments : an object and an event arguments object of the same type as supplied to the @ @ @ @ @ @ @ @ @ @ the signature of a delegate for the CancelEditing event would appear as follows : 50236 @qwx670236 
@@75677946 @4377946/ <p> RWDBResult represents a sequence of zero or more RWDBTables . An RWDBResult instance is returned whenever a database operation may potentially produce multiple SQL table expressions . This is most obviously the case when using the RWDBDatabase : : executeSql() method to submit arbitrary SQL for execution . However , DBTools.h++ recognizes that some database vendors provide : <p> Stored procedures that can execute more than one SELECT statement . <p> Triggers that can cause results to be generated as a result of an INSERT , DELETE , or UPDATE statement . <p> For this reason , each of the above execute() methods returns an RWDBResult instance . An application that knows that its database does not provide these capabilities is not obliged to check for multiple results . <p> Every RWDBResult instance has an RWDBConnection . Passing an RWDBConnection to an execute() method causes the RWDBResult to acquire the passed connection . Calling execute() without an RWDBConnection causes the RWDBResult to acquire a default connection from the caller 's RWDBDatabase . In each case , the connection is held by the RWDBResult until the RWDBResult is destroyed @ @ @ @ @ @ @ @ @ @ in order . Each call to RWDBResult : : table() causes unprocessed rows from any previous table to be flushed . <p> RWDBResult is designed around the Interface/Implementation paradigm . An RWDBResult instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBResult implementation is a base class from which a family of database-specific result implementations is derived . <p> The default constructor creates an RWDBResult whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience , for example , for declaring an array of RWDBResults . Usable RWDBResults are obtained from execute() methods . <p> Returns TRUE if the object is in ready state , indicating that accessing the object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if the status of self is RWDBStatus : : ok , otherwise returns FALSE . <p> long rowCount() const ; <p> Returns the number of rows in the database affected by the most recent activity through self 's connection . This @ @ @ @ @ @ @ @ @ @ without such a call return -1 . Typically , this method only returns a valid value after updating , inserting , or deleting rows . Errors always return -1 . <p> The following code determines the number of rows updated through an RWDBUpdater . <p> Installs handler as self 's error handler . The supplied handler is inherited by all objects produced by self . By default , an RWDBResult error handler is inherited from the object which produced it ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : <p> typedef void ( *ErrorHandler ) ( const RWDBStatus&amp; ) ; <p> RWDBStatus status() const ; <p> Returns the current status of self . <p> RWDBTable table() ; <p> Returns the next RWDBTable in the sequence of tables represented by self . When there are no more tables , returns a table whose status is RWDBStatus : : endOfFetch . This function can behave asynchronously if executed using an asynchronous connection , or if self uses an asynchronous connection . 
@@75677947 @4377947/ <p> All the representation update requests issued by the server are processed by the representation model interpreter supplied by the Rogue Wave- Server component library . <p> For each incoming representation update request , this interpreter decodes the representation object identifier as well as the attribute identifier , if any , so as to select the appropriate function to be applied to the representation object . <p> These functions and their association with runtime representation attributes must have been previously declared to the interpreter . <p> Just as the server classes are declared to a server model interpreter , the representation object classes " the bridge classes " must be declared to the representation model interpreter using a set of macros . This declaration has to be made only once and should occur in the file tha implements the bridge classes . <p> Example <p> The code sample below shows how to declare the TreeR and TreeItemR classes : <p> ILSRPOBJECTBEGIN(TreeR) <p> ILSRPATTRSTRING ( TreeR , label , setLabel ) <p> ILSRPOBJECTEND(TreeR) <p> **27;10428;TOOLONG <p> **25;10457;TOOLONG , label , setLabel ) <p> LONG ... <p> LONG ... <p> **25;10484;TOOLONG @ @ @ @ @ @ @ @ @ @ declare the following constructors : <p> **28;10511;TOOLONG rp , const IlsRpObjModel&amp; m ) ; <p> and <p> **32;10541;TOOLONG rp , const IlsRpObjModel&amp; m ) ; <p> to the representation model interpreter . Each time the interpreter receives a request for the creation of a TreeR or TreeItemR object , it executes the corresponding constructor . <p> Note : If the interpreter receives a request for creation of an object whose type is unknown , it executes the virtual function IlsRepresentation : : newRpObject on the representation to which the new object will belong . <p> Declaring Runtime Representation Attributes <p> A runtime attribute of a representation object class is declared to the representation model interpreter through a macro that takes a label and an editing function as parameters . This macro must appear between the BEGIN and END macros of the representation object class . <p> In our example , the class TreeR declares a string-typed attribute named label , associated with the editing function setLabel . The label attribute does not need to be the identifier of a data member of the class TreeR . This name is used @ @ @ @ @ @ @ @ @ @ Each time the server sends a request for the modification of the attribute label of a TreeR representation object , the representation interpreter executes the function setLabel on this representation object . Actually , the label of the attribute is not transmitted with the request but only its internal identifier of type IlsRpAttributeId . <p> A label attribute is also declared for the TreeItemR part along with two other attributes : <p> ownerTree : a reference attribute of type TreeR* associated with the function setOwner(TreeR*) , and <p> ownerItem : a reference attribute of type TreeItemR* associated with the function setOwner(TreeItemR*) . <p> As for the attribute label , each time the server sends a request for the modification of one of the reference attributes ownerTree or ownerItem of a TreeR representation object , the representation interpreter executes the relevant function setOwner on the object , passing the new reference target as the argument . <p> Note : If the interpreter receives a request for modification of an attribute whose label is unknown , it first looks for a default modifier declared for the type of the attribute ( see @ @ @ @ @ @ @ @ @ @ . If no such default modifier is declared , the interpreter executes the virtual update function declared in the IlsRpObject class that corresponds to the attribute type ( see the functions IlsRpObject : : setBoolean , setChar , setLong , etc. in the Reference Manual ) . <p> Creating a New Object from a Server Request <p> This section discusses the whole process of creating a new TreeItemR object from a server request . <p> First , the constructor TreeItemR is executed and an empty TreeItemR object is created . This object has no label yet ( except the default label ) and is not attached to its owner . The creation of a new gadget item in the tree requires to execute the function addItem on the owner tree gadget or tree gadget item . Therefore , the gadget item and the TreeItemR object can not be created simultaneously . In other words , a new gadget item can not be created before one of the setOwner functions has been called as a reference to the owner . <p> A solution is to create the gadget item inside the @ @ @ @ @ @ @ @ @ @ implement the setOwner function with a TreeItemR as its parameter : <p> In the above example , we assume that the owner is set before the label , so that the gadget item is created with a default label at first . This solution relies on the fact that attributes are notified by the server according to their order in the dynamic-view type specification . <p> A more common solution is to wait for all the attribute values to be set before creating the graphic object . This implies that these values be buffered until the object is complete . At that time , Rogue Wave Server always calls the virtual function IlsRpObject : : endS2CUpdate on the representation object . This is the empty function implemented by the class IlsRpObject by default , but you can override it for your own purpose . <p> Thus , the TreeItemR class is completed as follows : <p> class TreeItemR <p> ... <p> void LONG ... <p> private : <p> static TreeR* curtTreeOwner ; <p> static TreeItemR* curtItemOwner ; <p> static IlsString curtLabel ; <p> ; <p> The static data members curtTreeOwner @ @ @ @ @ @ @ @ @ @ attribute values set by the setOwner and setLabel functions in the context of new object creation . <p> For instance , the code for the function setOwner is then : <p> void TreeItemR : : setOwner ( TreeItemR* owner ) <p> <p> if ( ! gadgetItem ) <p> // this is the creation phase <p> curtItemOwner=owner ; <p> <p> else <p> // this is a cut/paste <p> .... <p> <p> l <p> Note : This very simple implementation is not multithread safe . A safer solution would be to store this data at the representation level . See Deriving a Tree Representation Type for details . <p> The gadget item is created by the endS2CUpdate function , as shown by the following code sample : 
@@75677948 @4377948/ <p> Iterator for class RWTPtrSlist&lt;T&gt; , allowing sequential access to all the elements of a singly-linked parameterized list . Elements are accessed in order , from first to last . <p> Like all Rogue Wave iterators , the " current item " is undefined immediately after construction -- you must define it by using operator() or some other ( valid ) operation . <p> If the slist is modified , the iterator is no longer valid . In addition , once the iterator has advanced beyond the end of the collection it is no longer valid--continuing to use it will bring undefined results . <p> Returns a pointer to the collection over which this iterator is iterating . <p> T* findNext ( const T* a ) ; <p> Advances the iterator to the first element that is equal to the object pointed to by a and returns a pointer to it . If no item is found , returns nil and the position of the iterator will be undefined . Equality is measured by the class-defined equality operator for type T. <p> T* findNext ( RWBoolean ( *testFun ) @ @ @ @ @ @ @ @ @ @ Advances the iterator to the first element for which the tester function pointed to by testFun returns TRUE and returns a pointer to it . If no item is found , returns nil and the position of the iterator will be undefined . <p> void insertAfterPoint ( T* a ) ; <p> Inserts the object pointed to by a into the iterator 's associated collection in the position immediately after the iterator 's current position which remains unchanged . <p> T* key() const ; <p> Returns a pointer to the object at the iterator 's current position . The results are undefined if the iterator is no longer valid . <p> T* remove() ; <p> Removes and returns the object at the iterator 's current position from the iterator 's associated collection . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . This function is relatively inefficient for a singly-linked list . <p> T* removeNext ( const T* a ) ; <p> Advances the iterator to the first @ @ @ @ @ @ @ @ @ @ a , then removes and returns it . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . Equality is measured by the class-defined equality operator for type T. <p> T* removeNext ( RWBoolean ( *testFun ) ( T* , void* ) , void* ) ; <p> Advances the iterator to the first element for which the tester function pointed to by testFun returns TRUE , then removes and returns it . Afterwards , the iterator will be positioned at the element immediately before the removed element . Returns nil if unsuccessful in which case the position of the iterator is undefined . <p> void reset() ; <p> Resets the iterator to the state it had immediately after construction . 
@@75677950 @4377950/ <h> Question <p> How to format a section of text in IlvAnnoText with different font and color ? <h> Answer <p> Each IlvATZone instance of an IlvAnnoText object is associated with a text palette ( IlvATPalette ) to draw the textual information contained in the text zone . To change the font and color of a particular section or zone of text in the IlvAnnoText object , you need to manipulate the IlvPalette object of the text palette for that particular zone . See attached sample AnnoTextColor.cpp for more detail implementation . 
@@75677953 @4377953/ <h> 4.8 Define and Map Filters <p> To configure a filter , a web.xml file first defines the filter instance , then maps one or more URL patterns to the instance . This section describes how to configure a filter within a web.xml file . For a discussion of programming a filter , see Section 6.6 . <p> The filter element of a web.xml file defines a filter instance . The filter element always contains a filter-name element and a filter-class element , and may contain initialization parameters . <p> The filter-name element declares a name for this particular filter instance . Each filter instance in a context must have a unique name . However , the name is only used to associate URL mappings with this instance . Therefore , the name need not correspond to the name of the filter class . The name is completely arbitrary . <p> The filter-class element tells the servlet container how to load the filter . There are two components to this element . The element contains the base name of the DLL that contains the servlet , and the name @ @ @ @ @ @ @ @ @ @ servlet . The components of the element are separated by a single period . For example , the value **30;10575;TOOLONG contains the base name compressFilters and the function name createCompress . <p> The base name of a DLL is the name of the library without the platform-specific prefix ( if any ) , without the suffix specified on the HydraExpress command line , and without the platform-specific extension . See Appendix C for information on library name mappings for each platform that HydraExpress supports . <p> The function name in the filter-class element must match the function name defined in the filter implementation . The RWSFDEFINEFILTER macro in the implementation source code defines the function name , as described in Section 6.5 . Note that the name of this function must be a legal C++ identifier . <p> The filter element below defines a filter named compressResponse . The compiled filter is in a DLL with the base name compressFilters . The container calls the function createCompress to create the servlet instance . <p> Again , the name of the filter instance need not correspond to the class name . @ @ @ @ @ @ @ @ @ @ the container , use another filter element with a different filter-name . The example below shows a fragment of a web.xml file that defines two different instances of the same filter class : <p> Each filter element may contain any number of init-param elements . The container passes the parameters to the filter in much the same way that command line parameters are passed to a complete program . The exact names and values of the parameters depend on the individual servlet . The example below shows a fragment of a web.xml file that defines two different instances of the same filter class . The container starts each instance with different parameters . <p> The filter-mapping element maps a URL pattern or servlet name to an instance of a filter . The filter-mapping always contains a filter-name element and a url-pattern element . <p> The filter-name element must match a filter-name defined in a filter element elsewhere in the web.xml file . Since a servlet container may have multiple instances of the same servlet running , the servlet container uses the filter-name to associate a mapping with a filter . @ @ @ @ @ @ @ @ @ @ . Therefore , each filter-mapping contains a single url-pattern element . Notice that the url-pattern for a filter need not exactly match the url-pattern in any particular servlet-mapping . <p> For example , the web.xml fragment below maps the URL /status/compressed/* to a filter named compressResponse . If the servlet is defined in the examples context of a servlet container at http : //example.roguewave.com/ , then this element tells the container that the compressResponse filter will process any requests beginning with LONG ... <p> Any number of instances within a context may be mapped to the same URL pattern . Filters are added to the filter chain in the order in which the filter-mapping appears in the web.xml file . For example , the web.xml fragment below defines two filters for servlets located at /status/compressed/* : <p> Both Uncompress and Authenticate appear on the filter chain for servlets located at /status/compressed/* . The Uncompress filter precedes the Authenticate filter in the chain because the Uncompress filter appears before the Authenticate filter in the web.xml file . 
@@75677955 @4377955/ <p> Class RWSlistCollectables represents a group of ordered elements , without keyed access . Duplicates are allowed . The ordering of elements is determined externally , by the order of insertion and removal . An object stored by RWSlistCollectables must inherit abstract base class RWCollectable . <p> The virtual function isEqual() ( see class RWCollectable ) is required to find a match between a target and an item in the collection <p> Class RWSlistCollectables is implemented as a singly-linked list , which allows for efficient insertion and removal , but efficient movement in only one direction . This class corresponds to the Smalltalk class LinkedList . <p> Redefined from class RWSequenceable . The index i must be between 0 and the number of items in the collection less one , or an exception of type RWBoundsErr will be thrown . Note that for a linked list , these functions must traverse all the links , making them not particularly efficient . <p> Redefined from class RWSequenceable . Returns the index of the first item that isEqual to the item pointed to by c . If there is no such @ @ @ @ @ @ @ @ @ @ RWCollectable* c ) ; <p> Redefined from class RWCollection . Adds the item to the end of the collection and returns it . Returns nil if the insertion was unsuccessful . <p> void insertAt ( sizet indx , RWCollectable* e ) ; <p> Redefined from class RWSequenceable . Adds a new item to the collection at position indx . The item previously at position i is moved to i+1 , etc . The index indx must be between 0 and the number of items in the collection , or an exception of type RWBoundsErr will be thrown . 
 the selection below . <p> There are a number of options here as Fortran does n't have an intrinsic " UNIQUE " function . Have a look at ORDERPACK 2.0 which contains links to source and includes a unique ranking and unique sorting subroutines . <p> The first 90% of the code accounts for the first 90% of the development time . The remaining 10% of the code accounts for the other 90% of the development time . <p> So , does that mean I should include the whole source code into my program in order to use those subroutines ? <p> You do n't have to include it all . But if you look at the source for UNISTA , you 'll find that it calls UNIINV . It probably is just easiest to include the large orderpack.f90 source code in your project , however , unless you want to split out only the functions you 'll use . <p> The first 90% of the code accounts for the first 90% of the development time . The remaining 10% of the code accounts for the other 90% of the development @ @ @ @ @ @ @ @ @ @ or JMSL ) that returns the unique elements of a vector , but it 's not hard to write yourself . The basic methodology would be similar for any language , however : sort the array and accumulate values that are not equal to a neighbor . If you look at the Orderpack source , it 's focus is largely on the sorting algorithm , but you 'll see the ' unique ' part in UNISTA . <p> The concern is often around performance . For example , you do n't know the size of the output array before hand , so in Java should you use a regular double array and trim it down later ? Or should you use an ArrayList or Vector and grow it with each new unique item found ? <p> Working on the premise that it 's faster to track unique elements in a boolean array and then loop through again , here 's some Java code that 'll work well . 
@@75677957 @4377957/ <h> 2.3 Representing Text in Computers <p> Fundamentally , computers just deal with numbers . To store letters and other characters , computers must assign a number to each one . There are hundreds of different encoding systems currently in use around the world for assigning these numbers . <p> The sections that follow provide a conceptual framework for understanding how these encodings work . <p> A character is an abstract , atomic unit of communication . For example , the letter Q is a character in English . <p> Characters and glyphs are distinct concepts . A glyph is a particular image that represents a character or part of a character . Many glyphs may be used to denote the same character ; for example , QQQQQ . Although recognizably different , these glyphs all represent the same abstract character Q. Similarly , some characters are represented by different glyphs depending on context , such as whether they occur in isolated , initial , medial , or final position . <p> A character set ( or abstract character repertoire ) is an unordered set of characters . The @ @ @ @ @ @ @ @ @ @ system , or the publication of a standard . Examples of character sets include the Western European alphabets and symbols of Latin-1 , the POSIX portable character repertoire , the Windows Western European repertoire , the Japanese syllabaries and ideographs of JIS X 02081 , and so forth . <p> A coded character set ( also called a character encoding , coded character repertoire , or code page ) is a mapping from a set of abstract characters to a set of non-negative integers . The result is a set of encoded characters that can be represented numerically within the computer . The range of integers need not be contiguous . Examples of coded character sets include ISO/IEC 8859-1 ( Latin-1 ) , Windows Code Page 1252 ( same repertoire as 8859-1 ) , the Unicode Standard , and so forth . <p> The integer associated with an abstract character in a coded character set is called the code point for the character . <p> A code unit is the fundamental binary width used in a computer architecture for representing character data , such as 7 bits , 8 bits @ @ @ @ @ @ @ @ @ @ the character encoding form used , each code point in a coded character set may be represented internally by one or more such code units . <p> A character encoding form whose code unit sequences are all of the same length is known as a fixed width encoding . For example , single-byte character sets ( SBCS ) are fixed width . If a double-byte character set ( DBCS ) always uses two code units to represent a code point , then it is also fixed width . <p> A character encoding form whose sequences are not all of the same length is known as a variable width encoding . If a double-byte character set uses one or two code units to represent a code point , then it is a variable width encoding . Multibyte character sets ( MBCS ) are variable width . <p> A coded character scheme is a character encoding form plus byte serialization . It is a mapping of code units into serialized byte sequences . Whereas a character encoding form maps code points to code units , a character encoding scheme maps code units @ @ @ @ @ @ @ @ @ @ encoding form for Unicode 3.0 has two character encoding schemes , UTF-16BE and UTF-16LE , which specify whether the two bytes used to represent UTF-16 code units are serialized in big-endian or little-endian format , respectively . <p> The complete mapping from abstract characters to code points to code units to bytes ( see Section 2.3.2 through Section 2.3.5 ) is called a character map . A character map thus implicitly includes a coded character set , a character encoding form , and a character encoding scheme . <p> The charset identifiers recognized by the Internet Assigned Numbers Authority ( IANA ) refer to character maps . 
@@75677959 @4377959/ <h> 4.3 Servlet and Filter Initialization Parameters <p> Some servlets and filters require initialization parameters . The init-param element within a filter or servlet definition element contains initialization parameters for that filter or servlet instance . These are distinct from context parameters , discussed in Section 4.7 . Each init-param contains a param-name element and a param-value element . Although the servlet container does not interpret the contents of the param-name and param-value , the contents of these elements must be legal XML . If the web.xml file is in UTF-16 , the servlet container transcodes the contents of the param-name and param-value to UTF-8 . <p> The web.xml snippet below defines two initialization parameters for a servlet , greeting and fontsize , and two for a filter , request and response . <p> The Rogue Wave name and logo are registered trademarks of Rogue Wave Software , and HydraExpress is a trademark of Rogue Wave Software . All other trademarks are the property of their respective owners.Contact Rogue Wave about documentation or support issues . 
@@75677960 @4377960/ <h> 14.5 Objective Grid Formulas <p> Formulas establish and calculate mathematical relationships between elements of the spreadsheet . Whereas numeric entries remain the same until you change them , cells defined by formulas are automatically changed to reflect changes in referenced cells even where there are complex interdependencies among cells . <p> Objective Grid formulas can calculate with numbers , text , logical values , cell references , and other formulas . For example , you can easily calculate the sum of a series of cells , the total of values in a column , a minimum or maximum value within a range , the rounded result of another formula , or the absolute value of a cell entry . Formulas can express complex interdependencies among cells , and they can define constraints on the calculation , such as limits on acceptable values or specific conditions under which a calculation should take place . <p> Once entered in a cell , formulas are hidden behind the scenes , perform their work in the background , and display only the result of their calculation . To view the formula in @ @ @ @ @ @ @ @ @ @ Grid provides an option that let 's you make all formula expression visible ( via CGXGridParam : : mnDisplayExpression ) . <p> Objective Grid also provides a wide array of functions that perform certain tasks . Functions can be used alone or in conjunction with formulas and other functions . Objective Grid provides many specialized functions in addition to those that are found in typical financial spreadsheets . See Section 14.3.5 , " Built-in Functions . " <p> The general form of an Objective Grid formula is : = expression ; constraint expression // comment <p> In the above formula , expression defines the calculations needed to generate the cell 's value , constraint expression places limits on acceptable values or the circumstances under which the calculation should take place , and comment is any text you want to attach to the cell . <p> The expression part of Objective Grid formulas looks just like an algebraic formula ; it contains values and operators that define the relationships between values . <p> Objective Grid uses the following conventions for formulas : <p> A formula must begin with an equal ( = @ @ @ @ @ @ @ @ @ @ , Objective Grid automatically assumes that you are typing a formula if you start with one of the following characters : <p> 0 1 2 3 4 5 6 7 8 9 . - @ =+ <p> Formulas can have as many as 511 characters . You can type spaces if you wish , but Objective Grid automatically removes them . <p> Objective Grid also provides two operatorsexponentiation ( ** ) and percent ( % ) that are not available in the C language . It does not support the C address operators or the operators that have side effects , such as ++ . <p> Objective Grid formulas can contain the following operators to define relationship between values . <h> Table 19 : Operator Precedence Definition <p> Operator <p> Definition <p> % 14 <p> Unary percent <p> ** 13 <p> Exponentiation <p> + 12 <p> Unary plus <p> - 12 <p> Unary minus <p> 12 <p> Bitwise complement ( integer ) <p> ! 12 <p> Logical not <p> * 11 <p> Multiplication <p> / 11 <p> Division <p> % 11 <p> Remainder ( integer ) <p> + 10 <p> @ @ @ @ @ @ @ @ @ @ Shift left ( integer ) <p> &gt;&gt; 9 <p> Shift right ( integer ) <p> &lt; 8 <p> Less Than <p> &gt; 8 <p> Greater Than <p> &lt;= 8 <p> Less Than or Equal <p> &gt;= 8 <p> Greater Than or Equal <p> == 7 <p> Equal <p> ! = 7 <p> Not Equal <p> &amp; 6 <p> Bitwise And , or String Concatenation <p> 5 <p> Bitwise Exclusive-Or ( integer ) <p> 4 <p> Bitwise Or <p> &amp;&amp; 3 <p> Logical And <p> 2 <p> Logical Or <p> ? : 1 <p> Conditional <p> In formulas with more than one operator , Objective Grid evaluates operators in the order of precedence presented above , with highest precedence first . That is , AND/OR/NOT operators are evaluated after inequality operators in a logical expression , and multiplication/division operations are performed before subtraction/addition operations in an arithmetic expression . Operators at the same precedence level are evaluated from left to right . <p> The precedence of operators can be overridden by using parentheses to explicitly specify the order of evaluation . <p> Here are some special notes about Objective Grid operators @ @ @ @ @ @ @ @ @ @ in Table 19 automatically convert their operands to integers . <p> The &amp; operator performs double duty : as a bit-wise and if the operands are numbers or as a string concatenation operator joining two strings together if the operands are text . <p> Concatenation is linking two strings together . For example , if you concatenate ( A1&amp;A2 ) the string " John " in cell A1 with the string " Smith " in cell A2 , the result is the value " John Smith . " <p> The % operator also performs double duty : as the percent operator when appended to a number or numeric expression , or as the C-style modulus operator when applied between two integer expressions . <p> Operators that define equality/inequality relationships ( such as == and &lt; ) can be used to compare text strings lexically ( alphabetically ) . <p> The conditional operator returns its second operand if its first operand evaluates True ( non-zero ) and returns its third operand if it evaluates False , ( zero ) . <p> In formulas with conditional operators , the second and third @ @ @ @ @ @ @ @ @ @ ranges . For example , the expression =@SUM ( A1 ? B1 .. C20 : C10 .. D15 ) returns the sum of B1 .. C20 if A1 evaluates to non-zero ; otherwise it returns the sum of C10 .. D15 . <p> Objective Grid accepts most arithmetic operators used in other spreadsheets like MS Excel , but there are a few differences in syntax and precedence . <p> Type the row and column coordinates of two cells in opposite corners of the block to be referenced , with two periods ( .. ) between the coordinates . For example , to reference the first five columns and the first five rows of the spreadsheet , type A1 .. E5 . <p> This differs from Microsoft Excel . The equivalent Excel syntax would be A1:A5 . <p> Relative references are cell or range references that are interpreted relative to the current position of the cell containing the formula . Relative references are updated whenever a cell is copied or moved , to reflect the new position of the cell . By default , Objective Grid considers references to be relative @ @ @ @ @ @ @ @ @ @ its position relative to the formula cell , not by its address . For example , if the formula in cell A1 references cell B2 , Objective Grid remembers that the referenced cell is one row down and one column right . If you copy the formula in cell A1 to another location ( e.g. , D17 ) , the formula will reference the cell one row down and one column right of the new location ( e.g. , E18 ) . <p> Absolute references are references to cells or ranges that remain fixed , no matter where the cell containing the formula is moved or copied . They are preceded with the dollar sign ( $ ) before each coordinate to be fixed , such as $A1 , A$1 , or $A$1 . <p> Absolute references remain the same , no matter where you move or copy the original formula . For example , if the formula in cell A1 references cell B2 , and you copy the formula in cell A1 to another location ( e.g. D17 ) , the formula still references cell B2 . To specify @ @ @ @ @ @ @ @ @ @ $ ) before the address coordinate to be fixed , or before both coordinates if both the row and column coordinates are to be fixed . For example : $B$2 . <p> To specify all or part of a cell address to be absolute , insert a dollar sign ( $ ) before the address coordinate to remain fixed . For example : <p> To assign a name to a cell or range of cells , use the SetRangeName() command . To reference a cell or range by name , type the pre-assigned name of the cell or cell block into the formula . <p> Cell ranges are also relative , so when you move a cell range , references in formulas within that range are updated to reflect their new location . To specify an absolute range reference , insert dollar signs ( $ ) before the coordinates in the formula . For example , to make the range A1 .. D5 absolute , type the reference as $A$1 .. $D$5 . <p> To specify part of a cell range to be absolute , insert dollar signs only before @ @ @ @ @ @ @ @ @ @ .. $D5 will fix the column coordinates of cell references but adjust the row coordinates to reflect the new location . <p> An indirect reference is a unique cell referencing technique in Objective Grid that allows you to refer to cells by row and/or column offset values relative to the current cell . This can be used anywhere a cell reference is expected : <p> References to cells in the neighborhood of the current cell are made with offset values enclosed in braces ( ) following the pound sign # which identifies the current cell . The offsets tell Objective Grid where to look , in relation to the current cell , for the cell being referenced . A negative row offset indicates a row above the current row . A negative column offset indicates a column to the left of the current column . Likewise , positive offset numbers for the row and column indicate a row below and a column to the right of the current cell . <p> The format is as follows : <p> #column offset , row offset <p> If you include only one value @ @ @ @ @ @ @ @ @ @ a column offset . For example , the offset reference #-1 tells Objective Grid to look to the column just left of the current cell . <p> The offset values may be constants or expressions . <p> Examples : <p> #0 , -1 refers to the cell above the current cell . <p> #-2 refers to the cell two columns to the left of the current cell . <p> #1 refers to the cell to the right of the current cell . <p> #0,1 refers to the cell below the current cell . <p> @CSUM ( C4 .. C100 , #-1 == " Joe " ) calculates the sum of all the values in the range C4 .. C100 for which the cell in the column to the left contains the string " Joe " . <p> @CCOUNT ( C4 .. C100 , # #0 , -1 ) counts all the cells in the range C4 .. C100 whose value is greater than the contents of the cell immediately above . <p> @XVALUE ( " master.xs3 " , # ) returns the value of the same cell reference in which @ @ @ @ @ @ @ @ @ @ Constraints are limitations or conditions placed on the variables in your spreadsheet . They are expressed as algebraic statements appended to formulas . You can attach a constraint expression to any formula , by typing a semicolon ( ; ) and the constraint conditions after the formula . <p> Constraint expressions establish conditions under which a formula operates or boundaries for valid results of the formula . Constraint expressions may be simple equality/inequality relationships , or they can be arbitrary formulas . Any valid Objective Grid expression that returns a numeric value is also a valid constraint expression . However , unlike the expression that defines a cell value , a constraint expression can reference the cell in which it resides , using the symbol # . <p> For example , the formula =A1 + A2 ; #&gt;2 &amp;&amp; #&lt;=B5 #==C7 means " the value of the current cell is the sum of cells A1 and A2 , and that value must be either greater than 2 and less than or equal to the value of cell B5 , or equal to the value of cell C7 " . <p> @ @ @ @ @ @ @ @ @ @ conditional statistical functions . The benefit of constraint expressions is maximized when combined with current cell reference support ( # ) as indicated in the above example . <p> There may be instances where you need to force a recalculation when certain cell values change , when there is no implicit dependency in the formula that would trigger an automatic recalculation . This explicit dependency option is indicated by appending a backslash ( ) to the end of the dependent formula . For example , the formula =@SUM ( A1 .. A20 ) D50 instructs Objective Grid to recalculate @SUM ( A1 .. A20 ) whenever the contents of D50 change . <p> This feature is particularly important when you have a constraint expression containing an offset reference that produces a cell reference outside the cell range referenced in a dependent formula . Under these circumstances , Automatic Recalculation would not necessarily be triggered . In the above example , @CCOUNT ( C4 .. C100 , # #0 , -1 ) counts all the cells in the range C4 .. C100 whose value is greater than the contents of the @ @ @ @ @ @ @ @ @ @ be evaluated , it must be compared to C3 - which is not part of the explicit range , C4 .. C100 . Without indicating an explicit dependency , C4 would never be evaluated properly . So , in this case , we would indicate the dependency as follows : <p> @CCOUNT ( C4 .. C100 , # #0 , -1 ) C3 .. C99 <p> which tells Objective Grid to recalculate whenever any cell in the range C3 .. C99 changes . 50236 @qwx670236 
@@75677961 @4377961/ <h> 5.5 Cell and Window Coordinates <p> Cell and window coordinates are related to each other . It is possible to compute the cell coordinate from a given window point or to compute the window rectangle for a given cell . Hit-Testing is used for determining what is located under a given window coordinate . <p> The user can scroll the data rows in the view . Column and row headers are fixed at the top and left margins of the window . Optionally , several rows or columns can be frozen so that they never scroll out of the view . <p> The grid maintains the number of frozen rows and columns and the cell coordinate of the top-left cell . The top-left cell is always located in the first scrollable row and column . All other cell coordinates can be derived from these parameters . <p> The grid component distinguishes between two coordinate systems : <p> Relative cell coordinates are numbered from 0 to n in the current visible view . <p> Absolute cell coordinates are unique identifiers for rows and columns , independent of the current @ @ @ @ @ @ @ @ @ @ rows and columns is that both relative and absolute coordinates are the same value : <p> Row headers are at column 0 . <p> Column headers are at row 0 . <p> Frozen rows are at row 1 to s , where s equals the number of frozen rows . <p> Frozen columns are at column 1 to z , where z equals the number of frozen columns . <p> All column widths , row heights , and font heights are specified in pixels . A typical VGA screen has a resolution of 800x600 or 1024x768 pixels . A printer normally has a considerably higher resolution . To avoid generating much smaller output when printing versus drawing to the screen , Windows uses a technique called coordinate mapping . Objective Grid uses coordinate mapping extensively with its device context . <p> All drawing operations in Microsoft Windows are done through a device context that contains information about the coordinate mapping and drawing attributes , such as font and color . The grid component initializes the mapping mode with 72 pixels per inch for printer output . This is the same @ @ @ @ @ @ @ @ @ @ does not have to consider whether the grid is being displayed to a printer or to the screen when drawing . The coordinate mapping mode for the device context is initialized in CGXGridCore : : OnPrepareDC() . <p> Row heights are determined with the overridable method CGXGridCore : : GetRowHeight() . Column widths are determined with CGXGridCore : : GetColWidth() . <p> Row and column widths are stored internally as logical values . This makes it possible to adapt these values to a change of the zooming factor or standard font size . The following methods in the grid component perform these conversions : CGXGridCore : : HeightLPtoDP() and CGXGridCore : : WidthLPtoDP() convert logical values to pixel values . CGXGridCore : : HeightDPtoLP() and CGXGridCore : : WidthDPtoLP() convert pixel values to logical values . <p> Furthermore , GetRowHeight() and GetColWidth() call the overridable method CGXGridcore : : IsRowVisible() or CGXGridCore : : IsColVisible() to determine if the specified row or column is visible . In a splitter window , for example , the row headers of the right pane are not visible . <p> It is possible to @ @ @ @ @ @ @ @ @ @ height and width for each row and column is known . Conversely , it is also possible to determine the cell displayed at a given point . <p> The following CGXGridCore methods perform the necessary calculations : <p> CalcClientColFromPt() <p> Computes the column index for the column displayed at a given window point . <p> CalcClientRowFromPt() <p> Computes the row index for the row displayed at a given window point . <p> CalcRectFromRowCol() <p> Computes the window rectangle for the given range of cells . <p> CalcRectFromRowColEx() <p> Computes the window rectangle for the given range of cells , making sure that covered cells are not cut off . <p> CalcSumOfColWidths() **26;10607;TOOLONG <p> Add the width of several columns . <p> CalcSumOfRowHeights() **27;10635;TOOLONG <p> Add the height of several rows . <p> GetGridRect() <p> Returns the window area where the grid is drawn . Normally , GetGridRect() determines drawing area by calling the MFC-method GetClientRect() . If the drawing area has been explicitly restricted with SetGridRect() or if the grid is in printing-mode , GetGridRect() returns an internally stored rectangle . <p> Hit-testing is used to determine what is located @ @ @ @ @ @ @ @ @ @ : HitTest() computes a hit value for a given point . <p> The following hit values are defined : <p> GXHORZLINE - The point is on the gridline of a row header . <p> GXVERTLINE - The point is on the gridline of a column header . <p> GXHEADERHIT - The point is on the interior rectangle of a row or column header . <p> GXCELLHIT - The point is on the interior rectangle of a cell . <p> GXSELEDGEHIT - The point is on the edge of a selection . This hit value will only be generated if mbHitTestSelEdge is TRUE . <p> GXNOHIT - No information is displayed at the point <p> One use of HitTest() is for a context-sensitive mouse cursor . Whenever the mouse is moved , the grid calls HitTest() and changes the mouse cursor as necessary . <p> GetRowCount() and GetColCount() are used extensively to validate values within routines . In addition , because HitTest() is called repeatedly on every mouse move and because this method touches a lot of grid code , including GetRowCount() , it is not unusual for GetRowCount() to be @ @ @ @ @ @ @ @ @ @ . Because GetRowCount() and GetColCount() are called quite often , your overrides of these methods are not an appropriate place to do extensive calculation . 50236 @qwx670236 
@@75677962 @4377962/ 50231 @qwx670231 <p> Extension class . <p> Library : ivstudio <p> To add some new features to Rogue Wave Views Studio , you need to define a new extension . To initialize a new extension and add it to Rogue Wave Views Studio , you have to derive a class from IlvStExtension defining a set of methods that will be invoked in a predefined sequence.Note : An extension must not be explicitly deleted . <h> Constructor &amp; Destructor Documentation <p> This constructor adds the new instance to the extension list of the editor . You must create an instance of your extension before initializing the Studio instance . When the editor is deleted , this instance is deleted . An extension must not be explicitly deleted . 
@@75677963 @4377963/ <p> Initializes a new instance of the class IlvToggle with a label . The label is copied . The size of the toggle button is automatically computed from label . If you want to specify its size , use the constructor that takes a rectangle as parameter . <p> Initializes a new instance of the class IlvToggle with a bitmap . The bitmap is locked . The size of the toggle button is automatically computed from the bitmap size . If you want to specify its size , use the constructor that takes a rectangle as parameter . 50234 @qwx670234 <p> display <p> The connection to the display . <p> point <p> The position of the toggle button . <p> bitmap <p> The bitmap of the toggle button . <p> thickness <p> The thickness of the toggle button . <p> palette <p> The palette used by the toggle button . <h> Member Function Documentation <p> virtual void IlvToggle : : activate <p> ( <p> ) <p> virtual <p> Is called by the interactor when the state of the toggle button changes . <p> The default implementation calls the main @ @ @ @ @ @ @ @ @ @ the state of the toggle button should be indeterminate . <p> When isIndeterminateMode returns IlTrue the state of the toggle button is set to indeterminate if value is set to IlTrue . If value is set to IlFalse , you must call IlvToggle : : getState to specify its state . If the toggle button is not in the indeterminate mode , this method does nothing . <p> Warning : <p> note A toggle button with a radio look must be used inside an IlvSelector and therefore its state can never be indeterminate . 50234 @qwx670234 <p> value <p> A Boolean value specifying whether the state of the toggle button should be indeterminate ( IlTrue ) or not ( IlFalse ) . 
@@75677964 @4377964/ <h> Rogue Wave Services <p> Rogue Wave is the leader in building cross-platform development tools , enterprise PHP , embeddable components , open source support and auditing , and static code analysis solutions . Combining this expertise with decades of experience helping customers in all industry segments , we offer a full range of services that not only enable you to get the most out of our products but also to guide application architecture , modernization , performance , and security from start to finish . <p> Our application audit services look inward to analyze internally-developed software for both known and unknown open source packages to create comprehensive bill of materials ( BOM ) and bill of licenses to meet legal and compliance obligations and eliminate security risks . Learn how Rogue Wave services can help . <p> Whether you 're looking for help migrating RHEL/Linux to CentOS , need to ensure that your applications are running on the most secure and best-performing platforms , or need to transform legacy code to address modern requirements , Rogue Wave has experts on hand to identify requirements , plan strategy , and @ @ @ @ @ @ @ @ @ @ about our migration and modernization services . <p> Rogue Wave services help you implement continuous delivery , at any stage , through our continuous delivery blueprint . By delivering an adoption roadmap and recommendations for the best technology investments , your team is guided through all elements of configuration management , build workflows , automated testing and deployment , continuous integration , application performance , and more . Learn more . <p> Get the most from your static code analysis ( SCA ) efforts . Create a powerful combination of advanced technology and services to maximize your commitment to great , secure code . Our static code analysis services help find the right checkers for your organization , your projects and your teams , ensure reports tell you what you need to know , and get everyone on the same page . We also help migrate from your existing test solution , including other SCA tools , to Klocwork . Learn more . <p> Receive training and certification on PHP , Zend Framework , and open source technologies from the basics through cutting-edge topics . Each interactive course offers real-life @ @ @ @ @ @ @ @ @ @ you to sharpen your skills and add new development practices . Learn more about Rogue Wave software training services . <p> Our architects ensure that your application follows established best practices of software design through a comprehensive evaluation of application code and workflows , focusing on scalability , supportability , and cloud readiness . Rogue Wave architects are experts in their fields , with many years of experience solving functional , performance , and security problems for enterprises . Learn more about our architecture consulting services . <p> Receive training and certification on PHP , Zend Framework , and open source technologies from the basics through cutting-edge topics . Each interactive course offers real-life examples to provide a robust and hands-on training experience allowing you to sharpen your skills and add new development practices . Learn how you can how minimize your security risk with Rogue Wave security audits . <p> Our consultants work with your developers and IT staff on evaluating the web transactions and overall behavior of your PHP , Java , and open source applications . The outcome is a comprehensive report that includes the analysis results @ @ @ @ @ @ @ @ @ @ any architecture challenges . Learn more about Rogue Wave performance optimization services . 
@@75677965 @4377965/ <h> 13.2 Class RWDBTBuffer&lt;T&gt; <p> RWDBTBuffer&lt;T&gt; is a template class designed to provide a type-safe encapsulation of a pointer to data or to an array of data . It is used to provide information about your program variables to class RWDBOSql , as explained in Section 13.1.4 . <p> Because RWDBTBufferis a template class , you instantiate the class on a particular type , the type pointed to by the pointer that the class encapsulates . To demonstrate how to instantiate RWDBTBuffer , we first create a pointer to some data : <p> long *pLong = new long ; <p> Next , we create an RWDBTBuffer , specifically an RWDBTBuffer&lt;long&gt; , to encapsulate the pointer : <p> RWDBTBuffer&lt;long&gt; aBuffer(pLong) ; <p> If we want our RWDBTBuffer to encapsulate a pointer to an array of objects rather than a single object , we pass in the number of elements in the array : <p> Since we allocated our own memory for data buffers in the previous section , we are now responsible for deallocating it . Of course , we can always use delete to deallocate the memory directly . @ @ @ @ @ @ @ @ @ @ deallocate storage automatically by using a constructor that does n't take a pointer to our data . Allowing RWDBTBuffer to manage its own memory frees us from explicitly managing memory ourselves , and simplifies our code in many cases . <p> To take advantage of automatic memory management , we simply construct the RWDBTBuffer , specifying only the number of elements to allocate . When we need access to the data , we use the overloaded operator , as shown in this example : <p> In this example , the destructor of RWDBTBuffer automatically destroys the 100 RWDates allocated by the constructor . Had we passed in a pointer to our own array in the RWDBTBuffer constructor , it would not have been deallocated , because it is not owned by the RWDBTBuffer instance . RWDBTBuffer deletes only the data it owns . <p> Now that you know how to encapsulate buffers with RWDBTBuffer , let 's see how to associate RWDBTBuffers with an RWDBOSql so that the results produced by executing an SQL statement are placed into the buffer . This procedure is also known as output binding and @ @ @ @ @ @ @ @ @ @ use operator and operator &gt;&gt; , which allow us to specify a particular result set and result column on which to bind a buffer . Let 's look at an example : <p> On //1 , we create a statement that returns a result set with two columns : one column of the string type of our database , and one column of the unsigned integral type of our database . On //2 and //3 , we create 10-element RWDBTBuffers , which we bind to the result set , one RWDBTBuffer per column . On //4 , we bind nameBuffer and hireBuffer to the 0th result set , as the comment indicates . <p> When the statement has executed , we can fetch the results using the fetch() method . Calling fetch() causes as much data as possible , for the current result set , to be fetched into the output buffers . <p> If our query produces fewer rows than the number of elements in the RWDBTBuffers , then the buffers are not entirely filled by the fetch() call . <p> If our query produces more rows than the @ @ @ @ @ @ @ @ @ @ to capacity . <p> In the previous example , the capacity is 10 rows , so rows still remain for us to fetch . Subsequent calls to fetch() would result in more rows being fetched into the buffers , and overwriting the data present there . <p> On //1 , we create an RWDBDatabase in order to connect to our database . On //2 , we create an RWDBOSql that encapsulates a query that should return a single-column result set . For this example , we assume I 'd is an unsigned integer column . On //3 , we execute the query using the execute() method . Note that no output buffers are bound at this time ; you can choose to bind your output RWDBTBuffers either before or after execution . Of course , you must bind the output buffers before calling fetch() , or there is no place into which to fetch the data ! <p> On //4 , we call isValid() to check that no error occurred . We also call RWDBOSql : : hasResult() to check that results were actually produced . The method hasResult() returns TRUE @ @ @ @ @ @ @ @ @ @ yet processed . <p> On //5 , we create an array of 100 unsigned longs on the stack . On //6 , we encapsulate the array in an RWDBTBuffer , idBuffer , so that the array can be used as an output binding . On //7 , we bind idBuffer to the first column in the 0th result set , the I 'd column specified in our SELECT . <p> Line //8 begins the results processing loop . In the while expression , we call fetch() to fetch data , and exit the loop if rowsFetched() returns 0 . As long as rowsFetched() remains greater than 0 , indicating that there is result data , the function printInventoryIDs() prints the result data that is fetched . <p> On each call to fetch() , RWDBOSql fetches as many rows as possible from the result set . In this case , the output binding holds 100 entries , so at most 100 rows are fetched . If fewer rows are available in the result set , all the rows are fetched . After each call to fetch() , the function rowsFetched() returns the @ @ @ @ @ @ @ @ @ @ the array contains fetched data . When all the result data is exhausted , calling fetch() returns no rows and rowsFetched() returns 0 , which tells us to exit the loop . <p> In many cases , when you are designing or coding an application , you know the form of an SQL statement to be executed , but not the data . Perhaps you expect the data to vary during execution . For example , knowing the schema of a database table , you know that a certain object in your program must always execute the statement : <p> However , the data that should take the place of the ? s in this statement wo n't be known until runtime . You could construct a new statement each time your object performs this operation , and include the data in the text of your statement , but this procedure would be highly inefficient . Instead , you can use RWDBTBuffers to bind data into your statement where needed . Assigning data to a variable at runtime is known as input binding . It is a feature provided by @ @ @ @ @ @ @ @ @ @ we first create an SQL statement like the one above , with the data left unspecified . Instead of the data , we use a placeholder , a piece of vendor-specific syntax that indicates that data will be provided through input binding . The access library guide from your database vendor should provide details on this feature , including placeholder syntax . For example , on Oracle , we would create the above statement using this syntax : <p> Once you 've created a statement with the proper syntax , you simply construct RWDBTBuffers for the data that should be provided for these placeholders , and use operator&lt;&lt; to bind them into your RWDBOSql instance . Invoking execute() will cause the statement , along with the current value of your bound-in data , to be sent to your database for execution . Let 's look at an example , using Oracle syntax : <p> On //1 , we create an RWDBDatabase to establish database connectivity . On //2 , we create an RWDBOSql to encapsulate the SQL statement we 'll use for renaming entries in our INVENTORY table . On @ @ @ @ @ @ @ @ @ @ placeholder in our renamer , and on //4 , we bind the RWDBTBuffers to the RWDBOSql . Note that operator&lt;&lt; works positionally , in the sense that each call to operator&lt;&lt; advances the position to the next placeholder in our SQL statement . <p> Lines //5 and //6 set the values used for the first execution of the statement , which is actually performed on //7 . The string " Gadget-O-Matic " on //5 is substituted for : ph0 in the original Oracle SQL statement , and the string " Gadget2000 " is substituted for : ph1 . Please note that RWDBOSql does not itself replace the placeholders in the SQL statement with the provided values . The statement and the data are simply provided to the database . The database interprets the statement , finds the placeholders in the statement , and matches them with the provided data . <p> On //8-//10 , new data is provided , and the UPDATE is re-executed with that data . For most databases , this operation is much faster than creating and executing a new statement because the database does n't need @ @ @ @ @ @ @ @ @ @ of single values to placeholders , some databases allow arrays of data to be bound into an SQL statement . When an array is bound , the SQL statement is executed once for each array entry . This operation is often termed bulk binding or array binding . Since RWDBTBuffer can encapsulate either a single value or an array , using the array binding capabilities of your database is simply a matter of supplying RWDBTBuffers with more than one entry . Here 's an example using Sybase syntax : <p> On //1 , we create an array of RWCStrings , which is populated on //2 by a function defined elsewhere . On //3 , we create an RWDBOSql , which will be used for inserting the data into the STRINGS table . On //4 , an RWDBTBuffer is created to encapsulate the array created earlier , and on //5 , the RWDBTBuffer is bound into the RWDBOSql . Line //6 executes the statement , causing all 1000 entries to be inserted into the STRINGS table . <p> If you bind multiple RWDBTBuffers to an RWDBOSql with multiple placeholders , the @ @ @ @ @ @ @ @ @ @ many times to execute its encapsulated SQL statement . For example , consider a statement with three placeholders , and three RWDBTBuffers of lengths 20 , 40 , and 50 , respectively . In this case , only the first 20 entries of each buffer are used when execute() is invoked , because the length of the smallest buffer is 20. 
@@75677966 @4377966/ <p> Most database vendors supply one or more datatypes that can store binary data of any length . These datatypes are commonly known as Binary Large Objects , or Blobs . DBTools.h++ stores data of these types as RWDBBlob . Class RWDBBlob provides storage and rudimentary access to the binary data . Applications may want to derive from RWDBBlob to add semantics to the data . <p> This class is implemented using a technique called copy on write . With this technique , the copy constructor and assignment operators still reference the old object and hence are very fast . An actual copy is made only when a write is performed , that is , if the object is about to be changed . The net result is excellent performance , but with easy-to-understand value semantics . <p> The member function putBytes() is used to populate an RWDBBlob . This method is safe and robust , but can be inconvenient in cases where large objects have already been loaded into memory . The constructor RWDBBlob ( void*data , sizet length ) is provided to allow applications to wrap existing @ @ @ @ @ @ @ @ @ @ this constructor do not manage the memory addressed by the data pointer ; your application continues to be responsible for it . <p> RWDBBlob inherits from class RWCollectable . The virtual functions of the base class RWCollectable have been redefined . <p> Creates a blob which has an initial capacity to store size bytes of binary data . The length is set to zero . <p> RWDBBlob ( void* data , sizet length ) ; <p> Creates a blob using the data block provided . The caller retains ownership of the data , and is responsible for providing an accurate length , for ensuring that the data pointer is valid for the lifetime of the blob , and for deallocation of the data , if necessary . <p> RWDBBlob ( const RWDBBlob&amp; blob ) ; <p> Copy constructor . The created blob shares data with blob until the data is modified . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until the mutex is released . This function can be called from a const object . @ @ @ @ @ @ @ @ @ @ a no-op . <p> virtual RWspace binaryStoreSize()const ; <p> Returns the number of bytes needed to store self . <p> sizet capacity()const ; <p> Returns the current capacity of self in bytes . This is the number of bytes self can hold without resizing . <p> void clear ( sizet size=0 ) ; <p> Replaces this blob 's data with a new blob whose length and capacity are zero . The previously held blob is deallocated if needed . <p> virtual int compareTo ( const RWCollectable* c ) const ; <p> Redefined from RWCollectable . Returns 0 , if self and c share data ; returns 1 , if self has length greater than c ; returns -1 , if c has length greater than self . Otherwise , returns an integer less than , greater than , or equal to zero , depending upon whether self 's data is less than , greater than , or equal to c 's data , according to the semantics of the standard C library function memcmp() . <p> unsigned char* data() const ; <p> Provides access to the blob 's data as @ @ @ @ @ @ @ @ @ @ is owned by the RWDBBlob and may not be changed or deleted . If the data must be manipulated , the application should derive from RWDBBlob to gain access to the protected data storage and controls . <p> void getBytes ( void* buffer , sizet size , sizet offset = 0 ) const ; <p> Copies size bytes starting at self 's offset to buffer . The buffer is assumed to be large enough to contain the bytes . Failure to provide a large enough buffer will result in a memory overwrite , which may have unpredictable results . <p> virtual unsigned hash()const ; <p> Redefined from RWCollectable . Returns a hash value for use in collection classes . <p> Copies size bytes from buffer into self starting at self 's offset . Exactly size bytes are copied , and therefore buffer is assumed to contain at least size bytes . Self 's capacity is enlarged by multiples of resize bytes if the existing capacity is insufficient . <p> void release() const ; <p> Releases a previously acquired mutex . This function can be called from a const object . @ @ @ @ @ @ @ @ @ @ a no-op . <p> virtual void restoreGuts ( RWFile&amp; file ) const ; <p> Redefined from RWCollectable . Reads file , replacing the contents of self . <p> virtual void **27;10664;TOOLONG stream ) const ; <p> Redefined from RWCollectable . Reads stream , replacing the contents of self . 
@@75677967 @4377967/ <p> Specifies whether the entire contents of a view frame is drawn when the view frame is moved or resized. 50231 @qwx670231 <p> Container class . <p> Library : ilvadvgdt <p> The IlvViewFrame class defines a special container that encapsulates a client view . It adds a title bar composed of an icon , a label , and several buttons to the client view . The client view is added to the view frame by creating it as a child view of the view frame . A frame can be in one of the three following states : normal , maximized , or minimized . <h> Constructor &amp; Destructor Documentation <p> Initializes a new instance of the class IlvViewFrame as a child view of parent . 50234 @qwx670234 <p> parent <p> The parent view of the view frame . <p> title <p> The view frame title . This title is displayed in the title bar of the view frame . <p> rect <p> The size and position of the view frame . <p> visible <p> A Boolean value specifying whether the view frame should be visible . <p> Warning @ @ @ @ @ @ @ @ @ @ be linked to an IlvDesktopManager object . If this is not the case , a desktop manager is automatically created by this constructor . <h> Member Function Documentation <p> virtual void IlvViewFrame : : closeFrame <p> ( <p> ) <p> virtual <p> Is called when the user closes the view frame . <p> The default implementation calls the destroy callbacks associated with the frame and its client view . To handle the destruction of a view frame you can either override this method in your own subclass of IlvViewFrame , or use a destroy callback . <p> A client view will forward some events to its view frame . This method is automatically called on the main client view of the view frame . You need to call this method if your main client view contains subviews . In this case , call this method giving each subview as parameter . 
@@75677968 @4377968/ <p> This class maintains a pointer-based collection of associations of type pair&lt;K* const , T*&gt; . The first part of the association is a key of type K* , the second is its associated item of type T* . Order is determined by the key according to a comparison object of type C. C must induce a total ordering on elements of type K via a public member <p> bool operator() ( const K&amp; x , const K&amp; y ) <p> which returns true if x and its partner should precede y and its partner within the collection . The structure less&lt;T&gt; from the C++-standard header file &lt;functional&gt; is an example . Note that keys will be dereferenced before being compared . <p> RWTPtrMap&lt;K , T , C&gt; will not accept a key that compares equal to any key already in the collection . ( RWTPtrMultiMap&lt;K , T , C&gt; may contain multiple keys that compare equal to each other . ) Equality is based on the comparison object and not on the == operator . Given a comparison object comp , keys a and b are equal if @ @ @ @ @ @ @ @ @ @ comp ( b , a ) . <p> The value type must have operator== and operator&lt; defined . This requirement is imposed by the Standard C++ Library . <p> Class RWTPtrMultiMap&lt;K , T , C&gt; offers the same interface to a pointer-based collection that accepts multiple keys that compare equal to each other . RWTPtrSet&lt;T , C&gt; maintains a pointer-based collection of keys without the associated items . <p> Class map&lt;K* , T* , derefcompare&lt;C , K , allocator&gt; &gt; is the C++-standard collection that serves as the underlying implementation for this collection . <p> Destroys all associations in self and replaces them by copying all associations from m . <p> bool operator&lt; ( const RWTPtrMap&lt;K , T , C&gt;&amp; m ) const ; <p> Returns true if self compares lexicographically less than m , otherwise returns false . Keys in each collection are dereferenced before being compared . Assumes that type K has well-defined less-than semantics . <p> bool operator== ( const RWTPtrMap&lt;K , T , C&gt;&amp; m ) const ; <p> Returns true if self compares equal to m , otherwise returns false . Two collections are equal @ @ @ @ @ @ @ @ @ @ iterating through both collections produces , in turn , individual keys that compare equal to each other . Keys are dereferenced before being compared . <p> T*&amp; operator ( const K* key ) ; <p> Looks up key and returns a reference to its associated item . If the key is not in the dictionary , then it will be added with an associated uninitialized pointer of type T* . Because of this , if there is a possibility that a key will not be in the dictionary , then this operator should only be used as an lvalue . <p> This is a deprecated version of the apply member above . It behaves exactly the same as apply . <p> iterator begin() ; <p> constiterator begin() const ; <p> Returns an iterator positioned at the first pair in self . <p> void clear() ; <p> Clears the collection by removing all items from self . <p> void clearAndDestroy() ; <p> Removes all associations from the collection and uses operator delete to destroy the objects pointed to by the keys and their associated items . Do not use this method @ @ @ @ @ @ @ @ @ @ ( This could happen even if keys all compare different , since items are not considered during comparison . ) <p> bool contains ( const K* key ) const ; <p> Returns true if there exists a key j in self that compares equal to *key , otherwise returns false . <p> bool contains ( bool ( *fn ) ( valuetype , void* ) , void* d ) const ; <p> Returns true if there exists an association a in self such that the expression ( ( *fn ) ( a , d ) ) is true , otherwise returns false . fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( valuetype a , void* d ) ; 50233 @qwx670233 <p> iterator end() ; <p> constiterator end() const ; <p> Returns an iterator positioned " just past " the last association in self . <p> sizetype entries() const ; <p> Returns the number of associations in self . <p> const K* find ( const K* key ) const ; <p> If there exists a key j in self that compares equal to *key @ @ @ @ @ @ @ @ @ @ . <p> valuetype find ( bool ( *fn ) ( valuetype , void* ) , void* d ) const ; <p> If there exists an association a in self such that the expression ( ( *fn ) ( a , d ) ) is true , then returns a . Otherwise , returns pair&lt;rwnil , rwnil&gt;. fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( valuetype a , void* d ) ; 50233 @qwx670233 <p> T* findValue ( const K* key ) ; <p> const T* findValue ( const K* key ) const ; <p> If there exists a key j in self that compares equal to *key , returns the item associated with j . Otherwise , returns rwnil . <p> const K* findKeyAndValue ( const K* key , T*&amp; tr ) ; <p> const K* findKeyAndValue ( const K* key , const T*&amp; tr ) const ; <p> If there exists a key j in self that compares equal to *key , assigns the item associated with j to tr , and returns j . Otherwise , returns rwnil and leaves @ @ @ @ @ @ @ @ @ @ K* key , T* a ) ; <p> Adds key with associated item a to the collection . Returns true if the insertion is successful , otherwise returns false . The function will return true unless the collection already holds an association with the equivalent key . <p> bool insertKeyAndValue ( K* key , T* a ) ; <p> This is a deprecated version of the insert member above . It behaves exactly the same as insert . <p> bool isEmpty() const ; <p> Returns true if there are no items in the collection , false otherwise . <p> Returns the number of associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( valuetype a , void* d ) ; 50233 @qwx670233 <p> K* remove ( const K* key ) ; <p> Removes the first association with key j in self that compare euqal to *key and returns j . Returns rwnil if there is no such association . <p> K* remove ( @ @ @ @ @ @ @ @ @ @ void* d ) ; <p> Removes the first association a in self such that the expression ( ( *fn ) ( a , d ) ) is true and returns its key . Returns rwnil if there is no such association . fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( valuetype a , void* d ) ; 50233 @qwx670233 <p> sizetype removeAll ( const K* key ) ; <p> Removes all associations with key j in self that compare equal to *key . Returns the number of associations removed . <p> sizetype removeAll ( bool ( *fn ) ( valuetype , void* ) , void* d ) ; <p> Removes all associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . Returns the number removed . fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( valuetype a , void* d ) ; 50233 @qwx670233 <p> containertype std() ; const containertype std() const ; <p> Returns a reference to the underlying C++-standard collection that serves @ @ @ @ @ @ @ @ @ @ next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677969 @4377969/ <p> As part of its pattern-matching capability , the Essential Tools Module supports simple and extended regular expression searches through its new RWTRegex&lt;T&gt; interface . Using RWTRegex&lt;T&gt; gives you access to wchart support , m , n cardinality constraint ability , and improved performance . <p> Extended regular expressions are the regular expressions used in the UNIX utilities lex and awk . Extended regular expressions can be any length , although limited by available memory . You will find details of the regular expression syntax in the Essential Tools ModuleReference Guide under RWTRegex&lt;T&gt; . ( Also , see the Bibliography . ) <p> RWTRegex&lt;T&gt; is based on the POSIX.2 standard for regular expressions . POSIX.2 includes notations for basic regular expressions ( BREs ) and extended regular expressions ( EREs ) . RWTRegex&lt;T&gt; is based on the ERE standard to support the wide character searches required by many non-Latin languages . <p> NOTE -- If your regular expression search requires the usage of backreferences , you will need to use RWCRegexp , rather than RWTRegex&lt;T&gt; . <p> In order to offer backwards-compatibility with RWCRegexp and RWCRexpr regular expression syntax @ @ @ @ @ @ @ @ @ @ . For detail , see the Essential Tools ModuleReference Guide under RWTRegex&lt;T&gt; . <p> RWTRegexTraits&lt;T&gt; defines the character traits for regular expression characters of a specified type . <p> RWTRegexResult&lt;T&gt; encapsulates the result of a pattern matching operation . It stores the starting offset and length of the overall match , as well as all sub-expression matches . <p> RWTRegexErr is used to report pattern compilation errors . <p> The two regular expression classes in previous releases -- RWCRegexp and RWCRExpr -- are now deprecated . However , if your program requires the use of backreferences , you must use RWCRegexp , as the newer RWTRegex&lt;T&gt; does not include that functionality . ( Backreferences allow you to match new text with previously-matched text in a regular expression , even if you do n't know the text itself . <p> The results of performance tests show that the new RWTRegex&lt;T&gt; interface performs matching operations approximately seven to eight times faster than did the previous interface . Compiling the original pattern is , however , slightly slower . <p> To maximize efficiency when pattern matching , first instantiate RWTRegex&lt;T&gt; to compile the @ @ @ @ @ @ @ @ @ @ 
@@75677970 @4377970/ <h> Understanding the lmstat output <p> You need to pay attention to two keywords : <p> The server keyword shows total build license consumption . <p> The client keyword shows total user license consumption . <p> Note : The label used for the license type may differ in your license file . The examples here use " server " and " client " . Your license file may use other labels , such as " fixserver " , " fixclient " and " client " . <h> Example lmstat output <p> Here 's an example snippet from the lmstat output , showing total build and user license consumption : <p> The line Users of server : ( Total of 5 licenses issued ; Total of 4 licenses in use ) shows that four out of the five available fixed server licenses are currently in use . Below the Users of client line , license usage details by user and host are displayed . The line beginning with " tyoung " shows us that user " tyoung " checked out a build license on the machine named " host01 " @ @ @ @ @ @ @ @ @ @ build licenses are node-locked , the user " jfall " has consumed three build licenses -- one for each machine they 're using . <p> Five out of the 10 client licenses are currently in use . User licenses are reserved for a unique user . <p> Note : The output of lmstat will show other license features like kwadmin , review and kwcheck . With the exception of language and optional stand-alone features , these are sub-features of the server and user licenses . <h> Check license usage by feature <p> You can check how many licenses are in use for a Klocwork feature ( or component ) , such as Klocwork Static Code Analysis by using the -f &lt;featurename&gt; option with lmstat. 
@@75677973 @4377973/ <h> 6.4 Copying Collection Classes <p> Copying classes is a common software procedure . It happens every time a copy constructor is applied , or whenever a process needs a copy to work on . Copying value-based collection classes is straightforward . But special considerations arise in copying reference-based classes , and we deal with them here . <p> What happens when you make a copy of a reference-based collection class , or any class that references another object , for that matter ? It depends which of the two general approaches you choose : shallow copying or deep copying . <p> A shallow copy of an object is a new object whose instance variables are identical to the old object . For example , a shallow copy of a Set has the same members as the old Set , and shares objects with the old Set through pointers . Shallow copies are sometimes said to use reference semantics . <p> The copy constructors of all reference-based Rogue Wave collection classes make shallow copies . <p> A deep copy of an object is a new object with entirely new @ @ @ @ @ @ @ @ @ @ old . For example , a deep copy of a Set not only makes a new Set , but also inserts items that are copies of the old items . In a true deep copy , this copying is done recursively . Deep copies are sometimes said to use value semantics . <p> Note that some reference-based collection classes have a copyContentsTo() member function that returns a new object with entirely new instance variables . This copying is not done recursively , and the new instance variables are shallow copies of the old instance variables . <p> Here is a graphical example of the differences between shallow and deep copies . Imagine Bag , an unordered collection class of objects with duplicates allowed , that looks like this before a copy : <p> Making a shallow copy and a deep copy of Bag would produce the following results : <p> You can see that the deep copy copies not only the bag itself , but recursively all objects within it . <p> The copying approach you choose is important . For example , shallow copies can be useful and fast @ @ @ @ @ @ @ @ @ @ be careful because two collections now reference the same object . If you delete all the items in one collection , you will leave the other collection pointing into nonsense . <p> You also need to consider the approach when writing an object to disk . If an object includes two or more pointers or references to the same object , it is important to preserve this morphology when the object is restored . Classes that inherit from RWCollectable inherit algorithms that guarantee to preserve an object 's morphology . You 'll see more on this in Chapter 8 . <p> that is , an ordered vector template instantiated for RWCString . In this case , each string is embedded within the collection . When a copy of the collection class is made , not only the collection class itself is copied , but also the objects in it . This results in distinct new copies of the collected objects : 50235 @qwx670235 
@@75677975 @4377975/ <p> Class RWCollection is an abstract base class for the Smalltalk-like collection classes . The class contains virtual functions for inserting and retrieving pointers to RWCollectable objects into the collection classes . Virtual functions are also provided for storing and reading the collections to files and streams . Collections that inherit this base class will typically redefine one or more of these functions . <p> In the documentation below , pure virtual functions are indicated by " = 0 " in their declaration . These functions must be defined in derived classes . For these functions the description is intended to be generic -- all inheriting collection classes generally follow the described pattern . Exceptions are noted in the documentation for the particular class . <p> For many other functions , a suitable definition is provided by RWCollection and a deriving class may not need to redefine the function . Examples are contains() or restoreGuts() . <p> Adds or removes , respectively , each item in the argument to or from self . Using operator+= ( somePreSortedCollection ) on an RWBinaryTree can cause that tree to become unbalanced ; @ @ @ @ @ @ @ @ @ @ function applies the user-supplied function pointed to by ap to each member of the collection . This function should have prototype <p> void **32;10722;TOOLONG ctp , void* ) ; <p> The function yourApplyFunction() can perform any operation on the item at address ctp that does not change the hash value or sorting order of the item . Client data may be passed to this function through the second argument . <p> Allows any collection to be converted to an RWBag , RWSet , RWOrdered , or an RWBinaryTree . Note that the return value is a copy of the data . This can be very expensive for large collections . You should consider using operator+= ( ) to insert each item from this collection into a collection of your choice . Also note that converting a collection containing data which is already sorted to a RWBinaryTree via the asSortedCollection() or asBinaryTree() methods will build a very unbalanced tree . <p> Removes all objects from the collection . Does not delete the objects themselves . <p> virtual void clearAndDestroy() ; <p> Removes all objects from the collection and deletes them . @ @ @ @ @ @ @ @ @ @ deletes them once . However , it does not take into account objects shared between different collections . Either do not use this function if you will be sharing objects between separate collections , or put all collections that could be sharing objects into one single " super-collection " and call clearAndDestroy() on that . <p> Returns TRUE if the collection contains an item where the virtual function find() returns non-nil . <p> virtual sizet entries() const = 0 ; <p> Returns the total number of items in the collection . <p> virtual RWCollectable* find ( const RWCollectable* target ) const = 0 ; <p> Returns a pointer to the first item in the collection which " matches " the object pointed to by target or nil if no item was found . For most collections , an item " matches " the target if either isEqual() or compareTo() find equivalence , whichever is appropriate for the actual collection type . However , the " identity collections " ( i.e. , RWIdentitySet and RWIdentityDictionary ) look for an item with the same address ( i.e. , " is identical to @ @ @ @ @ @ @ @ @ @ the collection which are " matches " t . See function find() for a definition of matches . <p> virtual void restoreGuts(RWFile&amp;) ; <p> Redefined to repeatedly call the global operator <p> RWFile&amp; operator&gt;&gt; ( RWFile&amp; , RWCollectable*&amp; ) ; <p> followed by insert(RWCollectable*) for each item in the collection . <p> virtual void **28;10756;TOOLONG ; <p> Redefined to repeatedly call the global operator <p> RWvistream&amp; operator&gt;&gt; ( RWvistream&amp; , RWCollectable*&amp; ) ; <p> followed by insert(RWCollectable*) for each item in the collection . <p> RWCollectable* remove ( const RWCollectable* target ) = 0 ; <p> Removes and returns a pointer to the first item in the collection which " matches " the object pointed to by target . Returns nil if no object was found . Does not delete the object . <p> virtual void removeAndDestroy ( const RWCollectable* target ) ; <p> Removes and deletes the first item in the collection which " matches " the object pointed to by target . <p> RWCollection* select ( RWtestCollectable tst , void* x ) const ; <p> Evaluates the function pointed to by tst for each item in the collection @ @ @ @ @ @ @ @ @ @ TRUE into a new collection allocated off the heap of the same type as self and returns a pointer to this new collection . Because the new collection is allocated off the heap , you are responsible for deleting it when done . This is not a virtual function . 
@@75677976 @4377976/ <p> Override the OnCreateClient() virtual function of the CMainFrame class for SDI application , or override the CChildFrame class for MDI applications and implement the function as shown below . In addition , include the header file for our view class , GridDSplitView.h , at the top of the mainfrm.cpp file . After you add the include , add a forward declaration of the CGridDSplitDoc class to the top of CGridDSplitView class . <p> Implement the DoInitialUpdate() function used in OnInitialUpdate() . The implementation of this function is almost an exact copy of the OnInitialUpdate() method in the CGXGridView class , which is a class in the Objective Grid library . Notice that in the preceding implementation , we used some protected member variables of the CGXGridCore class . To give your view class access these variables , you need to make your view class a friend of CGXGridCore . <p> Let 's add an empty derived classcore to the top of the DoInitialUpdate() function . <p> If you compile and run the application now , you will have a grid application with dynamic splitter support . If you @ @ @ @ @ @ @ @ @ @ splitter window at work . Two sets of scrollbars will be displayed . To hide one set of the scroll bars , you need to make a small change to your code . 50236 @qwx670236 
@@75677977 @4377977/ <h> 2.2 Interface and Implementation Classes <p> The design of the DB Interface Module uses the Interface/Implementation paradigm . Interface classes model objects in the application domain . Each interface class has an associated implementation class , which is used to implement the semantics defined by the interface class . <p> Interface classes are public , and model objects in the application domain . Implementation classes are private , and implement the semantics of their associated interface classes . <p> This paradigm is familiar to most C++ programmers . For example , many beginning texts present examples of simple classes like string that follow the paradigm . A typical string class might be designed as an interface class that defines the semantics of the class and contains a pointer to a reference-counted implementation class , which provides the services of data storage , memory management , and so on . <p> The public class hierarchy of the DB Interface Module consists of a set of interface classes that are concrete , as opposed to abstract . These concrete classes function as is without requiring further derivation . As interface @ @ @ @ @ @ @ @ @ @ themselves . Instead , each interface class instance consists of a pointer to an implementation class instance , and forwards all function calls to it . The implementation classes are not part of the public hierarchy . Only the interface classes are visible to the application programmer . <p> The interface classes are divided into classes that contain a pointer to a database-dependent implementation and those that do not . In general , classes that model database concepts , like RWDBTable and RWDBSelector , have pointers to database-dependent implementations , while classes that model database-independent concepts , like RWDBBlob and RWDBExpr , do not . Table 1 shows the class hierarchy of the public classes of the DB Interface Module . Note that the class implementations may also use private inheritance . <p> Note that all implementation classes of the DB Interface Module database-dependent classes can be considered abstract classes , containing virtual functions . These virtual functions will be overridden in the derived classes that make up the database-dependent Access Modules . <p> For example , class RWDBDatabase is an abstraction that represents a database . It offers a @ @ @ @ @ @ @ @ @ @ objects like tables , views , and stored procedures ; you can manage multiple connections ; and you can use database definition language ( DDL ) constructs , among other things . <p> These semantic elements represent features common to all databases . However , the way a feature is implemented for any particular database depends heavily upon the API provided by the database manufacturer . Consequently , RWDBDatabaseImp , the implementation class associated with RWDBDatabase , is an abstract base class for a family of database-dependent implementation classesone implementation class for each database manufacturer that SourcePro DB supports . These database-dependent implementation classes make up the Access Module for the particular database . Figure 2 shows this relationship . <p> Notice also from Figure 2 that classes RWDBDatabase and RWDBDatabaseImp reside in the DB Interface Module , while RWDBSybCtLibDatabaseImp and RWDBOCIDatabaseImp reside in separate DB Access Modules . This is the key to database portability in SourcePro DB . The DB Interface Moduleand therefore , your applicationdoes n't care which databases it works with . The Interface Module serves as a software backplane for plugging in different Access Libraries @ @ @ @ @ @ @ @ @ @ can even plug in Access Libraries at runtime without relinking your application . 50235 @qwx670235 
@@75677978 @4377978/ <h> Public Member Functions <p> Attaches the map information to manager . The map information will be automatically saved with the manager . This method returns the instance of IlvMapInfo that was previously attached to the manager or 0 if none . It also notifies the listeners that have been attached to the manager by the AddMapInfoListener() static method . . 50231 @qwx670231 <p> This class is used to attach map information to an IlvManager . This information is persistent and is automatically saved when the manager is saved . When an IlvMapInfo is attached to an IlvManager , the manager becomes georeferenced . The points of the manager can be interpreted in terms of distances . Heterogeneous map data can be potentially loaded into the manager because the Cartesian coordinate system of the manager ( specified by a projection ) is known . In addition to enabling applications to save georeferencing information , the IlvMapInfo class provides additional services , such as directly converting latitude and longitude into points expressed in the manager coordinate system , converting mouse events into latitude and longitude , or setting the scale @ @ @ @ @ @ @ @ @ @ to manager . The map information will be automatically saved with the manager . This method returns the instance of IlvMapInfo that was previously attached to the manager or 0 if none . It also notifies the listeners that have been attached to the manager by the AddMapInfoListener() static method . . <p> Warning : <p> When map information is attached to a manager , the manager becomes the owner of the map information , and will delete it in its destructor . <p> The scale is the ratio between the size of the objects drawn in view and the size of these objects in the geographic Cartesian coordinate system , which could be called the real size of these objects . <p> Warning : <p> note The computation of the scale depends on the size of the screen where view is displayed . The getScale method tries to determine this size , but the platform API to get this size often returns inaccurate results . For a more precise scale management , you can specify the size of the screen using the SetScreenSize() static function . 
@@75677979 @4377979/ <h> Introducing Rogue Wave JViews Enterprise <p> Rogue Wave JViews Enterprise provides a large collection of Java-based graphical components used to create highly visual and interactive desktop or Web and Ajax applications . The product is made of dedicated point-and-click design tools and full-featured software development kits ( SDKs ) that Java developers can use to add intuitive , graphical displays to their mission-critical and business-critical applications . <p> The following families of graphical components come with Rogue Wave- JViews Enterprise : <p> Diagrams in Java <p> Diagrams show the interconnections among objects in displays such as entity-relation diagrams , communications networks , PERT charts , and process flowcharts . This type of graphic models a business system to help manage its assets by providing a physical or logical view . Diagrams can be automatically created from data models . They implement dedicated visuals authored by using JViews design tools . This type of component is managed by the JViews Diagrammer part of Rogue Wave- JViews Enterprise . See Rogue Wave JViews Diagrammer . <p> Modeling a business process in Rogue Wave- JViews Enterprise <p> Dashboard and monitoring panels @ @ @ @ @ @ @ @ @ @ that require realistic or symbolic displays for detecting and solving problems . These displays are often referred to as business dashboards in the business intelligence domain . Users can use them to monitor key performance indicators ( KPIs ) of business processes . Users in industrial domains refer to these displays as industrial schematics and process control or supervisory control and data acquisition ( SCADA ) applications . These applications are used to show the current status of physical equipment , such as machines , tanks , production processes , and transport pipelines . This type of display is covered by the Dashboard part of JViews Diagrammer . See Rogue Wave JViews Diagrammer . <p> Traffic-flow monitoring showing a gauges dashboard <p> Map displays <p> Map displays are very useful for showing and managing all kinds of geo-referenced assets in logistics , road and air traffic systems , or network management . Common to all of these assets is the placement of symbols over a custom map and their synchronization with domain-specific data or information computed by the system . Rogue Wave- JViews Enterprise supports the geographical aspects of maps @ @ @ @ @ @ @ @ @ @ the graphical technology to overlay rich symbols . This type of display is covered by the JViews Maps part of Rogue Wave- JViews Enterprise . See Rogue Wave JViews Maps . <p> Map with overlaid symbols <p> Gantt charts <p> This type of chart provides dedicated visuals to manage time-based schedules , projects , tasks , and resources . Gantt charts are particularly useful for scheduling applications and project management activities . They can be used for pure visualization and also for interactive editing . They can be found in the JViews Gantt part of Rogue Wave- JViews Enterprise . See Rogue Wave JViews Gantt . <p> Gantt chart samples <p> Charts <p> Charts are very popular for monitoring operations and analyzing data in every type of business . Whenever you have a list of static or live data , a chart is the obvious way to visualize the information . They are managed by the JViews Charts part of Rogue Wave- JViews Enterprise . See Rogue Wave JViews Charts . 
@@75677980 @4377980/ <h> 4.10 Stored Procedures <p> Many modern RDBMS implementations include a mechanism to enforce database policy through stored procedures . Database administrators may require users to do much of their data manipulation through stored procedures in order to restrict access to the underlying tables . <p> Class **26;10786;TOOLONG database stored procedures . Class RWDBStoredProc supports creating and deleting stored procedures , retrieving stored procedure definitions , executing stored procedures , and processing the results returned from these executions . Parameters may be passed to an RWDBStoredProc prior to execution , and the values of output parameters may be retrieved . If a stored procedure can return multiple sets of results , RWDBStoredProc can also access each result set in turn . <p> Unfortunately , the standards bodies have had little to say about stored procedures , so stored procedure implementations vary widely among RDBMS vendors . If an RWDBStoredProcfeature is not supported by the underlying database , DBTools.h++ reports an RWDBStatus : : notSupported error . <p> RWDBStoredProcinstances are obtained from RWDBDatabaseinstances by invoking the latter 's storedProc() method with the stored procedure 's name . RWDBStoredProc contains an @ @ @ @ @ @ @ @ @ @ is necessary for the library to successfully match actual arguments supplied by your application with the procedure 's formal parameter list . The schema information is fetched automatically whenever an RWDBStoredProc is instantiated , so instantiating an RWDBStoredProc is a more expensive proposition than instantiating most DBTools.h++ objects . <p> Since the storedProc() method of RWDBDatabase involves a database access , it has a variant with which you can specify the connection to use . If only the procedure name is provided , a default connection is used . <p> The insertion operator &lt;&lt; is used to pass actual parameters to an RWDBStoredProc . Use it to insert actual values if the stored procedure expects IN parameters , or to insert pointers to values if the stored procedure expects OUT or IN/OUT parameters and your application needs to obtain results through the parameters . It is an error to insert a NULL pointer ; if you do , the status of RWDBStoredProc changes to RWDBStatus : : nullReference . A NULL value can be inserted using rwdbNull . <p> The indexing operator can be used to access a particular parameter @ @ @ @ @ @ @ @ @ @ procedure myStoredProc , which expects the parameters number and name in that order , the following notations are equivalent : <p> RWDBStoredProcdoes not check actual parameters for type ; instead , it allows the database to do type conversion where possible . If there is a type incompatibility , DBTools.h++ passes along whatever the database reports . <p> DBTools.h++ produces an RWDBStatus : : invalidPosition error if too many arguments are inserted into an RWDBStoredProc . No check is made for too few arguments , since the underlying database may supply defaults . If it does not , DBTools.h++ passes along any errors reported by the database . <p> In the next example , suppose there is a database procedure called squareRoot that expects two parameters : an integer x , and a floating point number y . The procedure is supposed to compute the square root of x . If no error occurs , it places the result in y and returns 0 ; otherwise it returns -1 and leaves y unchanged . <p> On //1 , an RWDBStoredProcinstance is obtained from the database . This involves using a @ @ @ @ @ @ @ @ @ @ for information about the procedure 's parameters . <p> The first argument to squareRoot is an IN parameter , and the second is an OUT parameter used for obtaining the data . The parameters are passed on //2 . First the IN parameter is inserted , followed by the address of the OUT parameter . <p> The call to execute() on //3 causes the stored procedure to be executed by the database server . As usual , the execute() method returns an RWDBResult , which we have elected to ignore in this case . Starting on //4 , we check the procedure 's return value . If the return value is zero , the result of the computation is in the variable y . <p> As an example of a stored procedure that does multiple SELECT statements , let 's consider the Sybase stored procedure sphelp , which displays information about database objects . This example also demonstrates how to use class RWDBValueto handle data without knowing its type . <p> In this example , the result of the execute() method is examined , rather than discarded . Each table @ @ @ @ @ @ @ @ @ @ which simply converts tabular data to strings and prints them out . On our system , four tables of results are processed by this program . 
@@75677981 @4377981/ <p> Indicates whether the selection drawing is handled by the matrix item . <p> Returns : <p> IlTrue if the selection drawing is handled by the matrix item and not by the matrix to which it belongs . In this case , the member function IlvMatrix : : drawSelection is not called . The default implementation returns IlFalse . <p> Reads an object description from the file input . It reads the information that was saved by the member function write to be able to create a new instance of this object . Usually , because of the availability of the constructor that expects an IlvInputFile , readItem should be equivalent to : <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvAbstractMatrixItem. 
@@75677983 @4377983/ <h> Irdeto and Rogue Wave Software team up to provide secure open API offerings for banks and payment service providers <p> AMSTERDAM " 5/9/2017 <h> Partnership provides end-to-end protection against a wide variety of attacks and allows financial institutions to comply with PSD2 requirements <p> Irdeto , the world leader in digital platform security , and Rogue Wave Software , maker of Akana and a leading provider of API management , API security , and microservices solutions for digital businesses , have announced a partnership to help banks and payment service providers ( PSPs ) protect their open APIs . The partnership brings to the market a solution to securing open APIs , combining products that offer protection from the API gateway through to the end-users device or application . In addition to providing end-to-end protection , the partnership also helps banks and PSPs comply with PSD2s Access to Account ( XS2A ) and Common and Secure Communication ( CSC ) requirements . <p> The payments and banking industry is undergoing digital disruption as financial institutions open their services to third-parties through open APIs . While this open banking @ @ @ @ @ @ @ @ @ @ also introduces a variety of security vulnerabilities . The partnership between Irdeto and Rogue Wave addresses those vulnerabilities by providing services and tools to help protect APIs and applications against a wide variety of attacks , including Denial of Service ( DoS ) , SQL Injections ( SQLi ) , Man-in-the-Middle ( MitM ) attacks , malware injections , and more . <p> " A successful cyberattack has the potential to permanently damage a financial institutions reputation , " said Ian Goldsmith , vice president of Akana product management , Rogue Wave . " Protecting open APIs is a critical step banks and PSPs must take to succeed in the ever-evolving financial landscape . Our partnership with Irdeto helps guide the financial industry through digital disruption to securely accelerate innovation . " <p> While open APIs connect financial enterprises with mobile apps and a large community of developers , these APIs also need to be scalable , reliable , and secure . As banks and PSPs expand their services across digital channels they need to become more vigilant about security and protect their APIs against threats and cyberattacks . <p> @ @ @ @ @ @ @ @ @ @ cybercriminals look at different ways to exploit vulnerabilities from APIs , " said David W. Jones , global head of payments &amp; banking , Irdeto . " In order to adequately protect customers sensitive financial information , banks and PSPs must secure their entire infrastructure from the API gateway to the end device or application . By partnering with Rogue Wave , we are providing financial institutions with the peace-of-mind needed to innovate freely . " <p> Cloakware for Payments &amp; Banking by Irdeto helps banks and PSPs capitalize on digital disruption by taking security to the next level , enabling new services and accelerating innovation . Irdetos unique solutions for Payments &amp; Banking help financial institutions prevent MitM attacks and mitigate tampering-based attacks . Irdeto protects and hardens applications and APIs from the client to the server , across all devices , browsers , interfaces , and gateways , completely in-line with PSD2 and PCI security standards . <h> About Irdeto <p> Irdeto is a pioneer in digital platform and application security , with its software security technology and cyber services protecting over 5 billion devices and applications against @ @ @ @ @ @ @ @ @ @ For nearly 50 years , Irdeto has worked with software application providers , connected device manufacturers , pay media operators and content creators to secure their products and business models . Combining proven technologies and services , Cloakware for Payments &amp; Banking solutions enable banks and PSPs to deliver a convenient and safe digital shopping or banking experience by safeguarding customer data even in the most hostile environments . Irdeto , a subsidiary of Naspers ( JSE : NPN ) , is headquartered in the Netherlands with more than 15 locations worldwide . Please visit Irdeto at www.irdeto.com . <h> About Rogue Wave Software <p> Rogue Wave helps thousands of global enterprise customers tackle the hardest and most complex issues in building , connecting , and securing applications . Since 1989 , our platforms , tools , components , and support have been used across financial services , technology , healthcare , government , entertainment , and manufacturing , to deliver value and reduce risk . From API management , web and mobile , embeddable analytics , static and dynamic analysis to open source support , we have the software essentials to innovate with confidence . 
@@75677985 @4377985/ <p> Class rwhashmap&lt;K , V , Hash , EQ&gt; maintains a collection of mappings between K and V , implemented as a hash table of pair&lt;const K , V&gt;. operator== must be defined for type V. Pairs with duplicate keys are not allowed . Two pairs having duplicate keys is the result of the EQ comparison , applied to the first element of each , is TRUE . Since this is a value based collection , objects are copied into and out of the collection . As with all classes that meet the ANSI associative container specification , rwhashmap provides for iterators that reference its elements . Operations that alter the contents of rwhashmap may invalidate other iterators that reference the container . Since the contents of rwhashmap are in pseudo-random order , the only iterator ranges that will usually make sense are the results of calling equalrange(key) , and the entire range from begin() to end() . <p> Construct an rwhashmap&lt;K , V , Hash , EQ&gt; with sz slots , using h as the hash object , and eq as the equality comparator , containing a copy @ @ @ @ @ @ @ @ @ @ and bounded by bound . <p> Construct an rwhashmap&lt;K , V , Hash , EQ&gt; with sz slots , using h as the hash object , and eq as the equality comparator , containing a copy of each pair referenced by the range starting with first and bounded by bound . If there are items in the range for which the K parts of the pairs match EQ , then only the first such item will be inserted into self . <p> Sets self to have the same capacity , Hash and EQ as rhs , removes all self 's current contents , and replaces them with copies of the elements in rhs . <p> bool operator== ( const rwhashmap&lt;K , V , Hash , EQ&gt; &amp; rhs ) const ; <p> Returns true if self and rhs have the same number of elements , and for each valuetype in self , there is a valuetype in rhs that has a first part for which the EQ object in self returns true , and a second part for which operator== ( ) returns true . The need to test both @ @ @ @ @ @ @ @ @ @ method equalbykeys() described below . <p> V&amp; operator ( const keytype&amp; key ) ; <p> Returns a reference to the V part of a pair held in self which has a part EQ to key , either by finding such a pair , or inserting one ( in which case the reference is to an instance of V created by its default constructor ) . <p> The iterator returned references the first item in self . If self is empty , the iterator is equal to end() . Note that because items are stored in pseudo-random order , this iterator might reference any item that has been stored in self . <p> constiterator begin() const ; <p> The iterator returned references the first item in self . If self is empty , the iterator is equal to end() . Note that because items are stored in pseudo-random order , this iterator might reference any item that has been stored in self . <p> iterator end() ; <p> The iterator returned marks the location " off the end " of self . It may not be dereferenced . <p> constiterator end() @ @ @ @ @ @ @ @ @ @ off the end " of self . It may not be dereferenced . <p> If there is a pair in self for which the first part is EQ to key , that pair is removed , and 1 is returned . Otherwise , 0 is returned . <p> iterator erase ( iterator iter ) ; <p> Removes the element referenced by iter and returns an iterator referencing the " next " element . If iter does not reference an item in self , the result is undefined . <p> iterator erase ( iterator first , iterator bound ) ; <p> Removes each element in the range which begins with first and is bound by bound . Returns an iterator referencing bound . If first does not reference an item in self ( and if first and bound are not equal ) , the effect is undefined . <p> pair&lt;iterator , bool&gt; insert ( const valuetype&amp; val ) ; <p> If there is no pair in self with first part EQ to the first part of val then inserts val , returning a pair with an iterator referencing the new element @ @ @ @ @ @ @ @ @ @ iterator referencing the matching valuetype and false . <p> sizetype insert ( iterator ignore , const valuetype&amp; val ) ; <p> If there is no pair in self with first part EQ to the first part of val then inserts val , returning 1 . Otherwise , does nothing and returns 0 . Note that the first argument is provided only for conformance with the ANSI associative container specification , and is ignored by the method , since hash table look up can be done in constant time . <p> sizetype insert ( const valuetype* first , const valuetype* bound ) ; <p> For each element in the range beginning with first and bounded by bound , if there is no pair in self with first part EQ to the first part of that element , the element is copied into self , or if there is such a pair , the element is skipped . Returns the number of elements inserted . <p> sizetype insert ( constiterator first , constiterator bound ) ; <p> For each element in the range beginning with first and bounded by bound , if @ @ @ @ @ @ @ @ @ @ to the first part of that element , the element is copied into self , or if there is such a pair , the element is skipped . Returns the number of elements inserted . <p> void swap ( rwhashmap&lt;K , V , Hash , EQ&gt;&amp; other ) ; <p> Exchanges the contents of self with other including the Hash and EQ objects . This method does not copy or destroy any of the items exchanged but exchanges the underlying hash tables . <p> Returns 1 if self contains a pair with its first element EQ to key , else 0 . <p> bool equalbykeys ( const rwhashmap&lt;K , V , Hash , EQ&gt;&amp; rhs ) const ; <p> Returns true if self and rhs have the same size , and if for each valuetype in self , there is a valuetype in rhs such that the EQ object in self returns true when called for the first parts of those pairs . Note that this method does not compare the V ( second ) part of the pair of the items , so it will run slightly faster than @ @ @ @ @ @ @ @ @ @ key ) const ; <p> Returns a constiterator referencing the pair with key as its first element if such a pair is contained in self , else returns end() . <p> iterator find ( const keytype&amp; key ) ; <p> Returns an iterator referencing the pair with key as its first element , if such a pair is contained in self , else returns end() . <p> void resize ( sizetype sz ) ; <p> Resizes self 's hash table to have sz slots ; and re-hashes all self 's elements into the new table . Can be very expensive if self holds many elements . 
@@75677987 @4377987/ <p> Returns true if self compares equal to vec , otherwise returns false . Two collections are equal if both have the same number of entries , and iterating through both collections produces , in turn , individual elements that compare equal to each other . <p> T&amp; operator() ( sizetype i ) ; const T&amp; operator() ( sizetype i ) const ; <p> Returns a reference to the ith element of self . Index i should be between 0 and one less then the number of entries , otherwise the results are undefined--no bounds checking is performed . <p> T&amp; operator ( sizetype i ) ; const T&amp; operator ( sizetype i ) const ; <p> Returns a reference to the ith element of self . Index i must be between 0 and one less then the number of entries in self , otherwise the function throws an exception of type RWBoundsErr . <p> If there exists an element t in self such that the expression ( ( *fn ) ( t , d ) ) is true , assigns t to k and returns true . Otherwise @ @ @ @ @ @ @ @ @ @ . fn points to a user-defined tester function which must have prototype : <p> bool yourTester ( const T&amp; a , void* d ) ; 50233 @qwx670233 <p> reference first() ; constreference first() const ; <p> Returns a reference to the first element of self . <p> sizetype index ( constreference a ) const ; <p> Returns the position of the first item t in self such that ( t == a ) , or returns the static member npos if no such item exists . <p> sizetype index ( bool ( *fn ) ( constreference , void* ) , void* d ) const ; <p> Returns the position of the first item t in self such that ( ( *fn ) ( t , d ) ) is true , or returns the static member npos if no such item exists . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool insert ( constreference a ) ; <p> Adds the item a to the end of the collection . Returns true . <p> void insertAt ( sizetype i , constreference @ @ @ @ @ @ @ @ @ @ of the item at position i in self . This position must be between 0 and the number of entries in the collection , otherwise the function throws an exception of type RWBoundsErr . <p> bool isEmpty() const ; <p> Returns true if there are no items in the collection , false otherwise . <p> Returns the number of elements t in self such that the expression ( ( *fn ) ( t , d ) ) is true . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> void prepend ( constreference a ) ; <p> Adds the item a to the beginning of the collection . <p> bool remove ( constreference a ) ; <p> Removes the first element t in self such that the expression ( t == a ) is true and returns true . Returns false if there is no such element . <p> bool remove ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes the first element t in self such that the expression ( ( *fn ) @ @ @ @ @ @ @ @ @ @ true . Returns false if there is no such element . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> sizetype removeAll ( constreference a ) ; <p> Removes all elements t in self such that the expression ( t == a ) is true . Returns the number of items removed . <p> sizetype removeAll ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes all elements t in self such that the expression ( ( *fn ) ( t , d ) ) is true . Returns the number of items removed . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> valuetype removeAt ( sizetype i ) ; <p> Removes and returns the item at position i in self . This position must be between 0 and one less then the number of entries in the collection , otherwise the function throws an exception of type RWBoundsErr . <p> valuetype removeFirst() ; <p> Removes and returns the first item in the collection . <p> @ @ @ @ @ @ @ @ @ @ in the collection . <p> sizetype **25;10814;TOOLONG oldVal , constreference newVal ) ; <p> Replaces all elements t in self such that the expression ( t == oldVal ) is true with newVal . Returns the number of items replaced . <p> Replaces all elements t in self such that the expression ( ( *fn ) ( t , d ) ) is true . Returns the number of items replaced . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> void resize ( sizetype n ) ; <p> Modify the capacity of the vector to be at least as large as n . The function has no effect if the capacity is already as large as n . <p> void sort() ; <p> Sorts the collection using the less-than operator to compare elements . <p> vector&lt;T , allocator&gt;&amp; std() ; const vector&lt;T , allocator&gt;&amp; std() const ; <p> Returns a reference to the underlying C++-standard collection that serves as the implementation for self . This reference may be used freely , providing access to the C++-standard interface as well as interoperability @ @ @ @ @ @ @ @ @ @ collections . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75677988 @4377988/ <h> Tales from the sprint : Lost in code <p> In the open development area of a high-tech software company , our hero , Eli , is racing against time to complete his code before the end of the sprint when disaster strikes ! The build system breaks , compliance tests are down , and there is no automated testing . What 's our hero to do ? With MISRA monsters and verification vampires swarming , can Eli save the day and avoid the donuts ... ? <p> Ready to see how your team ranks for code confidence and whether there are areas where you can level up ? Take our self assessment here . 
@@75677990 @4377990/ <h> Friends 50231 @qwx670231 <p> Port class . <p> Library : display <p> Instances of the IlvBitmap class are rectangular areas that store a group of pixels that make an image . These images can be in full color . In this case , each pixel value represents a color index when your display system has no true-color capabilities . To find the exact color that will be displayed for this pixel , the system lookup table is consulted . If your display system has true color capabilities , then each pixel of the bitmap stores its complete color information . <p> Also , images can be monochrome . In this case , there is only one bit per pixel , and the drawing of these one-bit-deep bitmaps will take place by setting the 1 pixels to the foreground color of the palette that is used , and the 0 pixels will be set to the background color of this palette or left unchanged . <p> A colored bitmap can be associated a mask . A mask is a monochrome bitmap that indicates which of the pixels in the @ @ @ @ @ @ @ @ @ @ the bitmap that correspond to ' 0 ' bits in the mask will be capable of not being displayed , achieving the effect of a transparent bitmap , that is , a color bitmap that has transparent parts . <p> Because IlvBitmap derives from IlvPort , you can actually draw into bitmap using the member functions of its parent classes . Most of the time , though , a bitmap is made from the conversion of a data file using an IlvBitmapStreamer . <h> Constructor &amp; Destructor Documentation <p> Initializes an empty image . Its content is unpredictable but the memory area to hold a future valid image is allocated and made available . 50234 @qwx670234 <p> display <p> The display where this bitmap is created . <p> width <p> The width of this new bitmap . <p> height <p> The height of this new bitmap . <p> depth <p> The depth of this new bitmap , that is , how many bits should be used to hold the pixel value of each individual image element . This can be either 1 for monochrome bitmaps , or the depth of @ @ @ @ @ @ @ @ @ @ <p> The initial data that initializes the bitmap pixel . This data must respect the following rules : <p> The whole image is given as a series of scan lines from image top to bottom . <p> The pixel values are packed into bytes from left to right , and each scan line must be padded to padding bits . <p> The bits are packed into padding bit words from left to right with a bit order defined by bitOrder . <p> The data may be composed in three different ways - either successive bytes or successive 32-bit integers - depending on the display depth : <p> If depth is 1 , the data must be made of successive bytes , where each bit describes a pixel of the image . <p> If depth is greater than 1 but less than or equal to 8 , the bitmap uses a lookup color table ( also called color map ) and each byte of data gives the index in this color map where the actual color value can be found . <p> If depth is strictly greater than 8 , the @ @ @ @ @ @ @ @ @ @ format . In that case , each of the three color components consists of 8-bits . These three bytes must be packed into 32 bits in this way : <p> value = ( red &lt;&lt; 16 ) ( green &lt;&lt; 8 ) blue <p> bitOrder <p> Indicates the bit order of the data . The data bits are considered most significant bits first if bitOrder is IlTrue , or least significant bits first if bitOrder is set to IlFalse . <p> padding <p> The padding value . The length of each scan line in data must be a multiple of this value . <p> Initializes a bitmap that has the indicated size and depth . The initial contents are unpredictable . 50234 @qwx670234 <p> display <p> The display where this bitmap is created . <p> width <p> The width of this new bitmap . <p> height <p> The height of this new bitmap . <p> depth <p> The depth of this new bitmap , that is , how many bits should be used to hold the pixel value of each individual image element . This can be either 1 for @ @ @ @ @ @ @ @ @ @ returned by calling **25;10868;TOOLONG . <h> Member Function Documentation <p> This member function computes a monochrome mask of the image currently stored in this bitmap . This mask is used to draw this bitmap transparently . The mask has the same dimensions as this bitmap , but every pixel of the original image that matches the transparent color index will be converted to a ' 0 ' bit in the output mask ( see setTransparentColorIndex ) . All other pixels will result in a ' 1 ' in the mask . The original image may be modified after a call to computeMask . <p> Returns : <p> IlTrue if the mask is successfully computed ( that is , there is a transparent color index that was used to compute the image mask ) . If the original bitmap is monochrome , or if the transparent color index has not been set , then this member function returns IlFalse . <p> The index of the color that must be considered as transparent in the bitmap . This index will be used to compute the image mask when the bitmap is first @ @ @ @ @ @ @ @ @ @ updated when creating the bitmap from a bitmap file that stores the transparent color information . A returned value of -1 means that this bitmap has no transparent color . <p> The description of this IlvBitmap image will be stored in XBM ( black and white ) or XPM ( color ) format . This makes it easier , for example , to transfer your images from one site to another . The IlvDisplay class has a member function that let 's you read from this new format ( see IlvDisplay : : readAsciiBitmap ) . 
@@75677992 @4377992/ <p> Returns a pointer to the collection over which this iterator is iterating . <p> RWBoolean findNext ( const T&amp; a ) ; <p> Advances the iterator to the first element that is equal to a and returns TRUE , or FALSE if there is no such element . Equality is measured by the class-defined equality operator for type T. <p> RWBoolean findNext ( RWBoolean ( *testFun ) ( const T&amp; , void* ) , void* ) ; <p> Advances the iterator to the first element for which the tester function pointed to by testFun returns TRUE and returns TRUE , or FALSE if there is no such element . <p> void insertAfterPoint ( const T&amp; a ) ; <p> Inserts the value a into the iterator 's associated collection in the position immediately after the iterator 's current position . <p> T key() const ; <p> Returns the value at the iterator 's current position . The results are undefined if the iterator is no longer valid . <p> RWBoolean remove() ; <p> Removes the value from the iterator 's associated collection at the current position of the @ @ @ @ @ @ @ @ @ @ Afterwards , if successful , the iterator will be positioned at the element immediately before the removed element . <p> RWBoolean removeNext ( const T&amp; a ) ; <p> Advances the iterator to the first element that is equal to a and removes it . Returns TRUE if successful , FALSE otherwise . Equality is measured by the class-defined equality operator for type T. Afterwards , if successful , the iterator will be positioned at the element immediately before the removed element . <p> RWBoolean removeNext ( RWBoolean ( *testFun ) ( const T&amp; , void* ) , void* ) ; <p> Advances the iterator to the first element for which the tester function pointed to by testFun returns TRUE and removes it . Returns TRUE if successful , FALSE otherwise . Afterwards , if successful , the iterator will be positioned at the element immediately before the removed element . <p> void reset() ; <p> Resets the iterator to the state it had immediately after construction . 
@@75677993 @4377993/ <p> The Sybase SQL Server usertype value , if available , is used to differentiate standard and national character stings . See Section 2.7.1 on return types . <p> 2 <p> See previous footnote . <p> When an application uses DBTools.h++ to create an SQL server table , the RWDBValue : : ValueType is used to define the table 's schema . Table 2 shows how DBTools.h++ maps its datatypes to SQL server datatypes when defining a schema <p> DBTools.h++ determines client and server support for the decimal and numeric datatypes , however not all combinations of clients and servers will be successful in data conversions . Applications that want to take full advantage of these datatypes should verify that both clients and servers support the decimal and numeric datatypes . This means that both the client and the server must be Sybase version 10.0. x or above . <p> Sybase DB-Library and servers place restrictions when using certain datatypes . Where possible , DBTools.h++ tries to be flexible about datatypes . However , there are some situations where conversions are not possible , and in these cases your @ @ @ @ @ @ @ @ @ @ which certain datatypes can be used . Table 3 outlines the restrictions associated with each DBTools.h++ type . <p> Sybase SQL servers support identity columns from release 10.0 . Identity columns can be used within DBTools.h++ , following the restrictions specified by the Sybase documentation . For more information , see Sybase SQL Server Transact-SQL User 's Guide . <p> Applications can create tables with identity columns by providing the native SQL statement then executing it with RWDBDatabase : : executeSql() . <p> Applications can also acquire the schema of a table that contains an identity column . The schema will return identity columns as RWDBValue : : Decimal datatypes , however there is no way to determine if the column is actually an identity column . Applications must know which column is the identity column of a table to use it correctly . <p> New rows can be inserted into tables by not providing values for identity columns . This effectively allows the SQL server to provide values . Values for identity columns should only be provided if an application demands a specific value . All values must follow @ @ @ @ @ @ @ @ @ @ identity columns is strictly forbidden by the SQL server . 
@@75677994 @4377994/ <h> set and multiset Operations <p> The member functions provided by the set and multiset data types will shortly be described in more detail . Note that while member functions provide basic operations , the utility of these data structures is greatly extended through the use of the generic algorithms described in Chapters 13 and 14 . <p> A set is a template data structure , specialized by the type of the elements it contains , and the operator used to compare keys . The latter argument is optional , and , if it is not provided , the less than operator for the key type will be assumed . The element type can be a primitive language type ( such as integer or double ) , a pointer type , or a user-defined type . The element type must recognize both the equality testing operator ( operator == ) and the less than comparison operator ( operator &lt; ) . <p> Sets can be declared with no initial elements , or they can be initialized from another container by providing a pair of iterators . An optional argument @ @ @ @ @ @ @ @ @ @ value overrides the value provided by the template parameter . This mechanism is useful if a program contains two or more sets with the same values but different orderings , as it prevents more than one copy of the set member function from being instantiated . The copy constructor can be used to form a new set that is a clone , or copy , of an existing set . <p> The classes set and multiset include a number of type definitions . The most common use for these is in a declaration statement . For example , an iterator for a set of integers can be declared in the following fashion : <p> set&lt;int&gt; : : iterator location ; <p> In addition to iterator , the following types are defined : <p> valuetype <p> The type associated with the elements the set maintains . <p> constiterator <p> An iterator that does not allow modification of the underlying sequence . <p> reverseiterator <p> An iterator that moves in a backward direction . <p> constreverseiterator <p> A combination constant and reverse iterator . <p> reference <p> A reference to an underlying @ @ @ @ @ @ @ @ @ @ element that will not permit modification . <p> sizetype <p> An unsigned integer type , used to refer to the size of containers . <p> valuecompare <p> A function that can be used to compare two elements . <p> differencetype <p> A signed integer type , used to describe the distance between iterators . <p> Unlike a list or vector , there is only one way to add a new element to a set . A value can be inserted into a set or a multiset using the insert() member function . With a multiset , the function returns an iterator that denotes the value just inserted . Insert operations into a set return a pair of values , in which the first field contains an iterator , and the second field contains a boolean value that is true if the element was inserted , and false otherwise . Recall that in a set , an element will not be inserted if it matches an element already contained in the collection . <p> Insertions of several elements from another container can also be performed using an iterator pair : <p> @ @ @ @ @ @ @ @ @ @ data structure is a tuple of values . The first value is accessed through the field name first , while the second is , naturally , named second . A function named makepair() simplifies the task of producing an instance of class pair . <p> In determining the equivalence of keys , for example , to determine if the key portion of a new element matches any existing key , the comparison function for keys is used , and not the equivalence ( == ) operator . Two keys are deemed equivalent if the comparison function used to order key values yields false in both directions . That is , if Compare ( key1 , key2 ) is false , and if Compare ( key2 , key1 ) is false , then key1 and key2 are considered equivalent . <p> Values are removed from a set using the member function erase() . The argument can be either a specific value , an iterator that denotes a single value , or a pair of iterators that denote a range of values . When the first form is used on a multiset @ @ @ @ @ @ @ @ @ @ and the return value indicates the number of elements that have been erased . <p> The member function size() will yield the number of elements held by a container . The member function empty() will return a boolean true value if the container is empty , and is generally faster than testing the size against zero . <p> The member function find() takes an element value , and returns an iterator denoting the location of the value in the set if it is present , or a value matching the end-of-set ( the value yielded by the function end() ) if it is not . If a multiset contains more than one matching element , the value returned can be any appropriate value . <p> The member functions lowerbound() and upperbound() are most useful with multisets , as with sets they simply mimic the function find() . The member function lowerbound() yields the first entry that matches the argument key , while the member function upperbound() returns the first value past the last entry matching the argument . Finally , the member function equalrange() returns a pair of iterators , @ @ @ @ @ @ @ @ @ @ function count() returns the number of elements that match the argument . For a set this value is either zero or one , whereas for a multiset it can be any nonnegative value . Since a non-zero integer value is treated as true , the count() function can be used to test for inclusion of an element , if all that is desired is to determine whether or not the element is present in the set . The alternative , using find() , requires testing the result returned by find() against the end-of-collection iterator . <p> The member functions begin() and end() produce iterators for both sets and multisets . The iterators produced by these functions are constant to ensure that the ordering relation for the set is not inadvertently or intentionally destroyed by assigning a new value to a set element . Elements are generated by the iterators in sequence , ordered by the comparison operator provided when the set was declared . The member functions rbegin() and rend() produce iterators that yield the elements in reverse order . <p> The traditional set operations of subset test , set @ @ @ @ @ @ @ @ @ @ provided as member functions , but are instead implemented as generic algorithms that will work with any ordered structure . These functions are described in more detail in Chapter 14 ( Set Operations ) . The following summary describes how these functions can be used with the set and multiset container classes . <h> Subset test <p> The function includes() can be used to determine if one set is a subset of another ; that is , if all elements from the first are contained in the second . In the case of multisets the number of matching elements in the second set must exceed the number of elements in the first . The four arguments are a pair of iterators representing the ( presumably ) smaller set , and a pair of iterators representing the ( potentially ) larger set . <p> The less than operator ( operator &lt; ) will be used for the comparison of elements , regardless of the operator used in the declaration of the set . Where this is inappropriate , an alternative version of the includes() function is provided . This form takes @ @ @ @ @ @ @ @ @ @ to order the elements in the two sets . <h> Set Union or Intersection <p> The function setunion() can be used to construct a union of two sets . The two sets are specified by iterator pairs , and the union is copied into an output iterator that is supplied as a fifth argument . To form the result as a set , an insert iterator must be used to form the output iterator . ( See Chapter 2 : Insert Iterators for a discussion of insert iterators . ) If the desired outcome is a union of one set with another , then a temporary set can be constructed , and the results swapped with the argument set prior to deletion of the temporary set . <p> The function setintersection() is similar , and forms the intersection of the two sets . <p> As with the includes() function , the less than operator ( operator &lt; ) is used to compare elements in the two argument sets , regardless of the operator provided in the declaration of the sets . Should this be inappropriate , alternative versions of both @ @ @ @ @ @ @ @ @ @ to form the set to be given as a sixth argument . <p> The operation of taking the union of two multisets should be distinguished from the operation of merging two sets . Imagine that one argument set contains three instances of the element 7 , and the second set contains two instances of the same value . The union will contain only three such values , while the merge will contain five . To form the merge , the function merge() can be used ( see Chapter 14 : Merge Ordered Sequences ) . The arguments to this function exactly match those of the setunion() function . <h> Set Difference <p> There are two forms of set difference . A simple set difference represents the elements in the first set that are not contained in the second . A symmetric set difference is the union of the elements in the first set that are not contained in the second , with the elements in the second that are not contained in the first . These two values are constructed by the functions setdifference() and setsymmetricdifference() , respectively . The @ @ @ @ @ @ @ @ @ @ the setunion() function described earlier . <p> Because sets are ordered and have constant iterators , a number of the generic functions described in Chapters 13 and 14 either are not applicable to sets or are not particularly useful . However , the following table gives a few of the functions that can be used in conjunction with the set data type . 
@@75677995 @4377995/ <p> A user-supplied hashing function for type T must be supplied to the constructor when creating a new table . If T is a Rogue Wave class , then this requirement is usually trivial because most Rogue Wave objects know how to return a hashing value . In fact , classes RWCString , RWDate , RWTime , and RWWString contain static member functions called hash that can be supplied to the constructor as is . The function must have prototype : <p> unsigned hFun ( const T&amp; a ) ; <p> and should return a suitable hash value for the object a . <p> To find an object , it is first hashed to determine in which bucket it occurs . The bucket is then searched for an object that is equal ( as determined by the equality operator ) to the candidate . <p> The initial number of buckets in the table is set by the constructor . There is a default value . If the number of items in the collection greatly exceeds the number of buckets then efficiency will sag because each bucket must be searched @ @ @ @ @ @ @ @ @ @ calling member function resize() . This is an expensive proposition because not only must all items be copied into the new buckets , but they must also be rehashed . <p> If you wish this to be automatically done , then you can subclass from this class and implement your own special insert() and remove() functions which perform a resize() as necessary . <p> Constructs a new hash table . The first argument is a pointer to a user-defined hashing function for items of type T. The table will initally have buckets buckets although this can be changed with member function resize() . <p> RWTValHashTable&lt;T&gt; ( const **29;10895;TOOLONG table ) ; <p> Constructs a new hash table as a copy of table . The new table will have the same number of buckets as the old table . Hence , although objects must be copied into the new table , they will not be hashed . <p> Applies the user-defined function pointed to by applyFun to every item in the table . This function must have prototype : <p> void yourFun ( T&amp; a , void* d ) ; <p> @ @ @ @ @ @ @ @ @ @ <p> void clear() ; <p> Removes all items from the collection . <p> RWBoolean contains ( const T&amp; val ) const ; <p> Returns TRUE if the collection contains an item which is equal to val . Returns FALSE otherwise . Equality is measured by the class-defined equality operator . <p> sizet entries() const ; <p> Returns the number of items currently in the collection . <p> RWBoolean find ( const T&amp; target , T&amp; k ) const ; <p> Returns TRUE if the collection contains an item which is equal to target and puts the matching object into k . Returns FALSE otherwise and leaves k untouched . Equality is measured by the class-defined equality operator . <p> void insert ( const T&amp; val ) ; <p> Inserts the value val into the collection . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if the collection has no items in it , FALSE otherwise . <p> sizet occurrencesOf ( const T&amp; val ) const ; <p> Returns the number of items in the collection which are equal to val . Equality is measured by the class-defined equality operator . @ @ @ @ @ @ @ @ @ @ Removes the first object which is equal to the object a and returns TRUE . Returns FALSE if there is no such object . Equality is measured by the class-defined equality operator . <p> sizet removeAll ( const T&amp; val ) ; <p> Removes all objects which are equal to the object a . Returns the number of objects removed . Equality is measured by the class-defined equality operator . <p> void resize ( sizet N ) ; <p> Changes the number of buckets to N , a relatively expensive operation if there are many items in the collection . 
@@75677996 @4377996/ <h> String Operations <p> The simplest form of declaration for a string simply names a new variable , or names a variable along with the initial value for the string . This form was used extensively in the example graph program given in 9 ( Example , Graphs ) . A copy constructor also permits a string to be declared that takes its value from a previously defined string . <p> In these simple cases the capacity is initially exactly the same as the number of characters being stored . Alternative constructors let you explicitly set the initial capacity . Yet another form allows you to set the capacity and initialize the string with repeated copies of a single character value . <p> Finally , like all the container classes in the standard library , a string can be initialized using a pair of iterators . The sequence being denoted by the iterators must have the appropriate type of elements . <p> As with the vector data type , the current size of a string is yielded by the size() member function , while the current capacity is returned @ @ @ @ @ @ @ @ @ @ call on the reserve() member function , which ( if necessary ) adjusts the capacity so that the string can hold at least as many elements as specified by the argument . The member function maxsize() returns the maximum string size that can be allocated . Usually this value is limited only by the amount of available memory . <p> The member function length() is simply a synonym for size() . The member function resize() changes the size of a string , either truncating characters from the end or inserting new characters . The optional second argument for resize() can be used to specify the character inserted into the newly created character positions . <p> A string variable can be assigned the value of either another string , a literal C-style character array , or an individual character . <p> s1 = s2 ; s2 = " a new value " ; s3 = ' x ' ; <p> The operator += can also be used with any of these three forms of argument , and specifies that the value on the right hand side should be appended to the @ @ @ @ @ @ @ @ @ @ " yz " ; // s3 is now xyz <p> The more general assign() and append() member functions let you specify a subset of the right hand side to be assigned to or appended to the receiver . A single integer argument n indicates that only the first n characters should be assigned/appended , while two arguments , pos and n , indicate that the n values following position pos should be used . <p> The member function cstr() returns a pointer to a null terminated character array , whose elements are the same as those contained in the string . This let 's you use strings with functions that require a pointer to a conventional C-style character array . The resulting pointer is declared as constant , which means that you can not use cstr() to modify the string . In addition , the value returned by cstr() might not be valid after any operation that may cause reallocation ( such as append() or insert() ) . The member function data() returns a pointer to the underlying character buffer . <p> The member functions begin() and end() return beginning and @ @ @ @ @ @ @ @ @ @ by the iterators will be individual string elements . The functions rbegin() and rend() return backwards iterators . <p> The string member functions insert() and remove() are similar to the vector functions insert() and erase() . Like the vector versions , they can take iterators as arguments , and specify the insertion or removal of the ranges specified by the arguments . The function replace() is a combination of remove and insert , in effect replacing the specified range with new values . <p> In addition , the functions also have non-iterator implementations . The insert() member function takes as argument a position and a string , and inserts the string into the given position . The remove function takes two integer arguments , a position and a length , and removes the characters specified . And the replace function takes two similar integer arguments as well as a string and an optional length , and replaces the indicated range with the string ( or an initial portion of a string , if the length has been explicitly specified ) . <p> The member function copy() generates a substring of @ @ @ @ @ @ @ @ @ @ given as the first argument . The range of values for the substring is specified either by an initial position , or a position and a length . <p> The member function compare() is used to perform a lexical comparison between the receiver and an argument string . Optional arguments permit the specification of a different starting position or a starting position and length of the argument string . See Chapter 13 ( Lexical Comparison ) for a description of lexical ordering . The function returns a negative value if the receiver is lexicographically smaller than the argument , a zero value if they are equal and a positive value if the receiver is larger than the argument . <p> The relational and equality operators ( &lt; , &lt;= , == , ! = , &gt;= and &gt; ) are all defined using the comparison member function . Comparisons can be made either between two strings , or between strings and ordinary C-style character literals . <p> The member function find() determines the first occurrence of the argument string in the current string . An optional integer argument let 's you @ @ @ @ @ @ @ @ @ @ that string index positions begin at zero . ) If the function can locate such a match , it returns the starting index of the match in the current string . Otherwise , it returns a value out of the range of the set of legal subscripts for the string . The function rfind() is similar , but scans the string from the end , moving backwards . <p> The functions findfirstof() , findlastof() , findfirstnotof() , and findlastnotof() treat the argument string as a set of characters . As with many of the other functions , one or two optional integer arguments can be used to specify a subset of the current string . These functions find the first ( or last ) character that is either present ( or absent ) from the argument set . The position of the given character , if located , is returned . If no such character exists then a value out of the range of any legal subscript is returned . 
@@75677997 @4377997/ <h> SourcePro C++ API Reference Guide <h> SourcePro C++ API Reference Guide <h> 12.0 <h> Organization of this Reference <p> This reference guide is generated from source code comments . It replaces the former suite of reference guides for SourcePro C++ . Below are some guidelines on how to navigate this new reference . <p> Modules : This tab provides a view into the product similar to the earlier suite of reference guides , organized on the top level by product , and on the next level by module . At each level you will find a list of the classes and related functions for that level . Note that the DB Access Module system and environmental handle classes , formerly documented in the user guides , have been moved to this reference guide . <p> Alphabetical Index : A concise alphabetical index of the classes in the API . <p> Annotated List : An annotated alphabetical list of the classes in the API . <p> Class Hierarchy : A hyperlink class hierarchy . <p> Class Members : A comprehensive index of class members and related functions in the @ @ @ @ @ @ @ @ @ @ box that let 's you search on symbols : classes , functions , variables , typedefs , enumerations , enumerators , and friends . To be clear : this is not full-text search , so searching on " hashmap " will return no matches , but ' hash ' will because many classes have a hash() function . <p> A dropdown menu on the left side of the search box let 's you restrict the search to a single type of symbol , with the default being all symbols . The results show matching symbols , and if you click on one , you will see a list of all places where the symbol is documented . Click the close icon on the right side of the search box to close the results box . <h> Inherited Members <p> The main class description page only documents members declared in the class . That is , it does not document inherited members inline . To see the list of all members , whether declared in the class or inherited from a base class , click the List of all members link near @ @ @ @ @ @ @ @ @ @ code elements <p> Some code elements are tagged as conditional , as indicated in the description by : <p> Condition : Reason for the limitation ... <p> Most commonly this is because the code element depends on functionality that not all compilers support , such as recent changes to the C++ standard . In some cases , they reflect specific problems related to a platform or compiler . Note that use of these code elements may limit the portability of your code . 
@@75677998 @4377998/ <h> Stingray Studio Components <p> All Stingray Studio components are available as an application demonstration . Select and download your component demo from the list below . <h> Objective Chart <p> Objective Chart is a complete library of Microsoft foundation classes ( MFC ) extension classes that you can use to add efficient and complex charting capabilities to Windows applications . <p> Objective Chart supports a large variety of chart types and style settings that define the appearance of the chart elements . Through its class-based architecture , you can easily extend and enhance these basic capabilities by using the chart extension system . <h> Objective Grid ( Objective Grid for . NET also available ) <p> Objective Grid is a full-featured grid control built completely from object-oriented technology . It can be extended quickly and easily , and it provides support for embedding grid objects virtually anywhere that a window can be embedded . It includes a comprehensive set of controls to embed in cells and provides the ability to add your own . Objective Grid classes also provide ODBC or ADO database connectivity . <h> Objective Toolkit @ @ @ @ @ @ @ @ @ @ that enhance your current Visual C++/MFC programs . Objective Toolkit provides support for a variety of graphical user interface controls , views , and utilities . You can extend its object-oriented classes quickly and easily . <p> The Objective Toolkit classes work seamlessly with the MFC classes and , in many cases , inherit from existing classes such as CView or CWnd . <h> Objective Views <p> Objective Views is a comprehensive set of Microsoft foundation classes ( MFC ) C++ classes for creating symbols that you can manipulate on a diagram . Objective Views provides a drawing surface abstraction , also known as the canvas , onto which you can draw and manipulate symbols and graphics . Objects on the canvas encapsulate graphical elements that the user or application can move , scale , rotate , connect , or animate . <p> In addition to extending the functionality of MFC , Objective Views also acts as a layer of abstraction for the Windows GDI . This layer shields you from low-level GDI details so you can concentrate on creating an application design . Because the Objective Views classes extend @ @ @ @ @ @ @ @ @ @ Objective Views . However , this does not prevent you from customizing the behavior of any of the Objective Views classes . 
@@75677999 @4377999/ <p> RWDBTable is a base class from which a family of classes derive . RWDBTable represents a table of information whose actual location is transparent . The data may reside in a database table or in program memory , or may be an SQL table expression , that is , a collection of rows returned from a database query . The three kinds of tables to which RWDBTable provides an interface are : <p> Database table-a handle to a table physically stored in the database <p> Result table-the rows returned as the result of a query <p> Memory table-a table stored in program memory <p> RWDBTable is designed around the Interface/Implementation paradigm . An RWDBTable instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBTable implementation is a base class from which a family of table implementations is derived . Each implementation except that of RWDBMemTable is in turn a base class from which a family of database-specific table implementations derive . <p> The default constructor creates an RWDBTable whose status is RWDBStatus : : @ @ @ @ @ @ @ @ @ @ for example , for declaring an array of RWDBTables . Usable RWDBTables are obtained from RWDBDatabase and RWDBResult . <p> Returns a deep copy of the first RWDBColumn in self 's schema whose name matches the given name . The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this table . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : ok . This is used with RWDBSelector to build up selectors and criterions without requiring an application to fetch the schema of a table . For example : <p> Returns a deep copy of the RWDBColumn in self 's schema at the given position . The RWDBColumn returned is associated with self . If no matching is found , returns an RWDBColumn whose status is RWDBStatus : : ColumnNotFound . A deep copy is made so that the application can modify the returned RWDBColumn without modifying self 's schema . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until @ @ @ @ @ @ @ @ @ @ from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWDBStatus addColumn ( const RWDBColumn&amp; column ) ; <p> Uses a default database connection to execute the database-specific equivalent of the SQL statement : <p> ALTER TABLE&lt;table&gt;ADD COLUMN&lt;column&gt; , <p> where &lt;table&gt; is the database table represented by self , and &lt;column&gt; is defined by the given column . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . <p> Uses the supplied connection to execute the database-specific equivalent of the SQL statement : <p> ALTER TABLE&lt;table&gt;ADD COLUMN&lt;column&gt; <p> where &lt;table&gt; is the database table represented by self , and &lt;column&gt; is defined by the given column . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self @ @ @ @ @ @ @ @ @ @ RWDBStatus : : invalidUsage . This function can behave asynchronously if executed using an asynchronous connection . <p> Uses a default database connection to execute the database-specific equivalent of the SQL statement : <p> ALTER TABLE&lt;table&gt;ADD COLUMN&lt;column&gt; <p> where &lt;table&gt; is the database table represented by self , and &lt;column&gt; is defined by the supplied arguments . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . <p> Uses the supplied connection to execute the database-specific equivalent of the SQL statement : <p> ALTER TABLE&lt;table&gt;ADD COLUMN&lt;column&gt; <p> where &lt;table&gt; is the database table represented by self , and &lt;column&gt; is defined by the supplied arguments . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus @ @ @ @ @ @ @ @ @ @ executed using an asynchronous connection . <p> RWDBBulkInserter bulkInserter ( const RWDBConnection&amp; conn ) ; <p> Returns an RWDBBulkInserter able to insert values into self . The RWDBBulkInserter executes using the supplied connection . <p> RWDBBulkReader bulkReader ( const RWDBConnection&amp; conn ) ; <p> Returns an RWDBBulkReader able to read the result set associated with the rows of self . The RWDBBulkReader executes using the supplied connection . <p> RWDBColumn column ( const RWCString&amp; name ) const ; <p> Returns a deep copy of the first RWDBColumn in self 's schema whose name matches the given name . The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this table . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying the associated RWDBTable schema . <p> NOTE:Database tables will not return valid column and schema information until fetchSchema() is called . <p> Returns a deep copy of the first RWDBColumn in self 's schema whose name matches @ @ @ @ @ @ @ @ @ @ returned is associated with self , that is , the table() method of the returned RWDBColumn returns this table . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . A deep copy of the column from self at the specified index is made . <p> NOTE:Database tables will not return valid column and schema information until fetchSchema() is called . <p> RWDBColumn column ( sizet index ) const ; <p> Returns a deep copy of the RWDBColumn in self 's schema at the given index . The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this table . A deep copy is made so that applications can modify the returned RWDBColumn without modifying the associated RWDBTable schema . If index is out of range , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . <p> NOTE:Database tables will not return valid column and schema information until fetchSchema() is called . @ @ @ @ @ @ @ @ @ @ of the SQL statement : <p> CREATE unique clustered INDEX name ON&lt;table&gt; ( &lt;columns&gt; ) <p> where name is the name of the index to be created , &lt;table&gt; is the database table represented by self , &lt;columns&gt; is a list of columns defined by columns , and the optional keywords unique and clustered are present or absent according to the supplied values unique and clustered . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . <p> Uses the supplied connection to send the database-specific equivalent of the SQL statement <p> CREATE unique clustered INDEX name ON&lt;table&gt; ( &lt;columns&gt; ) <p> where name is the name of the index to be created , &lt;table&gt; is the database table represented by self , &lt;columns&gt; is a list of columns defined by columns , and the optional keywords unique and clustered are present or absent according to the supplied values unique and clustered . You can check the return value 's isValid() method to determine whether the operation @ @ @ @ @ @ @ @ @ @ the returned status is RWDBStatus : : invalidUsage . This function can behave asynchronously if executed using an asynchronous connection . <p> If self is a database table , produces an RWDBCursor for execution of the SQL statement : <p> SELECT * from&lt;table&gt; <p> where &lt;table&gt; is the database table represented by self . The cursor is created on a default database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . If self is a result table or a memory table , the function produces an RWDBCursor whose status is RWDBStatus : : noCursor . <p> If self is a database table , produces an RWDBCursor for execution of the SQL statement : <p> SELECT * from&lt;table&gt; <p> where &lt;table&gt; is the database table represented by self . The cursor is created on the supplied database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . If self is a result table or a memory table , the function produces an RWDBCursor with @ @ @ @ @ @ @ @ @ @ asynchronously if executed using an asynchronous connection . <p> where &lt;table&gt; is the database table represented by self . The argument updateCols is used in building a clause : <p> FOR UPDATE OF column-name , column-name , ... <p> Some SQL dialects require this form . The cursor is created on a default database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . <p> where &lt;table&gt; is the database table represented by self . The cursor is created on the supplied database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . Some SQL dialects require this form . The argument updateCols is used in building a clause : <p> FOR UPDATE OF column-name , column-name , ... <p> This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBDatabase database() const ; <p> Returns the RWDBDatabase that produced this table . If there is no such object , for example , if this table was created using the default @ @ @ @ @ @ @ @ @ @ of RWDBStatus : : notInitialized . <p> RWDBDeleter deleter() const ; <p> Produces an RWDBDeleter that can be used to delete all rows from self . The result is an encapsulation of the SQL statement : <p> DELETE FROM&lt;table&gt; <p> where &lt;table&gt; is self 's table name . If self is not a database table , returns an RWDBDeleter whose status is RWDBStatus : : noDeleter . <p> RWDBDeleter deleter ( const RWDBCriterion&amp; criterion ) const ; <p> Produces an RWDBDeleter that can be used to delete rows from self based on criterion . An RWDBCriterion is an encapsulated SQL WHERE clause . The result is an encapsulation of the SQL statement : <p> DELETE FROM&lt;table&gt;WHERE criterion <p> where &lt;table&gt; is self 's table name . If self is not a database table , returns an RWDBDeleter whose status is RWDBStatus : : noDeleter . <p> RWDBStatus drop() ; <p> Uses a default database connection to drop the database table or view represented by self . Sends the database-specific equivalent of either the SQL statement : <p> DROP TABLE&lt;table&gt; <p> where &lt;table&gt; is the database table represented by self , @ @ @ @ @ @ @ @ @ @ database view represented by self . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table or view , the returned status is RWDBStatus : : invalidUsage . <p> RWDBStatus drop ( const RWDBConnection&amp; connection ) ; <p> Uses the supplied connection to drop the database table or view represented by self . Sends the database-specific equivalent of either the SQL statement : <p> DROP TABLE&lt;table&gt; , <p> where &lt;table&gt; is the database table represented by self , or : <p> DROP VIEW&lt;view&gt; <p> where &lt;view&gt; is the database view represented by self . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table or view , the returned status is RWDBStatus : : invalidUsage . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBStatus dropColumn ( const RWDBColumn&amp; column ) ; <p> Uses a default database connection to execute the database-specific equivalent of the SQL : <p> ALTER TABLE&lt;table&gt;DROP COLUMN&lt;column&gt; <p> where &lt;table&gt; is the database table represented @ @ @ @ @ @ @ @ @ @ the given column . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . <p> Uses the supplied connection to execute the database-specific equivalent of the SQL : <p> ALTER TABLE&lt;table&gt;DROP COLUMN&lt;column&gt; <p> where &lt;table&gt; is the database table represented by self , and &lt;column&gt; is the column name of the given column . If successful , calls fetchSchema() so that self 's schema remains consistent with the database . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBStatus dropIndex ( const RWCString&amp; name ) ; <p> Uses a default database connection to send the database-specific equivalent of the SQL : <p> DROP INDEX&lt;table&gt;.name <p> where &lt;table&gt; is the database table represented by @ @ @ @ @ @ @ @ @ @ to be dropped . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . <p> Uses the supplied connection to send the database-specific equivalent of the SQL : <p> DROP INDEX&lt;table&gt;.name <p> where &lt;table&gt; is the database table represented by self , and name is the name of the index to be dropped . You can check the return value 's isValid() method to determine whether the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : invalidUsage . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBStatus : : ErrorHandler errorHandler() const ; <p> Returns the error handler attached to self . <p> RWBoolean exists ( RWBoolean forceLookup = FALSE ) ; <p> If self is a database table , returns TRUE if the table exists in the database , otherwise returns FALSE . If self is a memory table , always returns TRUE . If self is a result table , returns @ @ @ @ @ @ @ @ @ @ read self , otherwise returns FALSE . <p> To determine whether or not a database table exists , DBTools.h++ uses a default connection to query the database for the table 's schema . If no schema can be obtained , FALSE is returned . Otherwise , self 's RWDBSchema is populated with the result of the query and TRUE is returned . By default , multiple calls to a database table 's exists() method always return the same result ; the database is only queried on the first call . This behavior can be overridden by forceLookup , which , if TRUE , forces the database to be queried . <p> If self is a database table , returns TRUE if the table exists in the database , otherwise returns FALSE . If self is a memory table , always returns TRUE . If self is a result table , returns TRUE if an RWDBReader has not yet been obtained to read self , otherwise returns FALSE . <p> To determine whether or not a database table exists , DBTools.h++ uses the supplied connection to query the database for the @ @ @ @ @ @ @ @ @ @ , FALSE is returned . Otherwise , self 's RWDBSchema is populated with the result of the query and TRUE is returned . By default , multiple calls to a database table 's exists() method always return the same result ; the database is only queried on the first call . This behavior can be overridden by forceLookup , which , if TRUE , forces the database to be queried . <p> virtual RWBoolean fetchSchema() ; <p> If self is a database table , returns TRUE if schema information about the table can be obtained , otherwise returns FALSE . If self is a memory table , always returns TRUE . If self is a result table , returns TRUE if an RWDBReader has not yet been obtained to read self , otherwise returns FALSE . <p> To obtain schema information , DBTools.h++ uses a default database connection to query the database . If no schema can be obtained , FALSE is returned . Otherwise , self 's RWDBSchema is populated with the result of the query and TRUE is returned <p> virtual RWBoolean fetchSchema ( const RWDBConnection&amp; connection ) @ @ @ @ @ @ @ @ @ @ TRUE if the schema information about the table can be obtained , otherwise returns FALSE . If self is a memory table , always returns TRUE . If self is a result table , returns TRUE if an RWDBReader has not yet been obtained to read self , otherwise returns FALSE . <p> To obtain schema information , DBTools.h++ uses the supplied connection to query the database . If no schema can be obtained , FALSE is returned . Otherwise , self 's RWDBSchema is populated with the result of the query and TRUE is returned . <p> Uses conn to append a list of foreign keys to keyList . If refName is blank , keyList will contain all self 's foreign keys . If refName is not blank , keyList will contain the foreign key of self that refers to refName . An empty list indicates there are no foreign keys associated with self referring to refName . You can check the return value 's isValid() method to determine whether the operation succeeded . <p> Uses the default connection to append a list of foreign keys to keyList . @ @ @ @ @ @ @ @ @ @ 's foreign keys . If refName is not blank , keyList will contain the foreign key of self that refers to refName . An empty list indicates there are no foreign keys associated with self referring to refName . You can check the return value 's isValid() method to determine whether the operation succeeded . <p> RWDBStatus grant ( const RWCString&amp; privilege , const RWCString&amp; user ) ; <p> Uses a default database connection to execute the database-specific equivalent of the SQL : <p> GRANT privilege ON&lt;table&gt;TO user <p> where &lt;table&gt; is self 's table name . DBTools.h++ does not validate the supplied arguments . You can check the returned object 's isValid() method to see if the operation succeeded . If self is not a database table , the returned status is RWDBStatus : : noPrivilege . <p> Uses a default database connection to execute the database-specific equivalent of the SQL : <p> **29;10926;TOOLONG ( &lt;column-list&gt; ) TOuser <p> where &lt;table&gt; is self 's table name , and &lt;column-list&gt; is a list of column names from self 's schema . DBTools.h++ does not validate the supplied arguments . You @ @ @ @ @ @ @ @ @ @ if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . <p> Uses the supplied database connection to execute the database-specific equivalent of the SQL : <p> **35;10957;TOOLONG <p> where &lt;table&gt; is self 's table name . DBTools.h++ does not validate the supplied arguments . You can check the returned object 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . This function can behave asynchronously if executed using an asynchronous connection . <p> Uses the supplied database connection to execute the database-specific equivalent of the SQL : <p> **29;10994;TOOLONG ( &lt;column-list&gt; ) TOuser <p> where &lt;table&gt; is self 's table name , and &lt;column-list&gt; is a list of column names from self 's schema . DBTools.h++ does not validate the supplied arguments . You can check the returned object 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . This function can behave asynchronously @ @ @ @ @ @ @ @ @ @ ( const RWCString&amp; name ) const ; <p> Returns the index in self 's schema of the first column with the given name . Returns RWNPOS if there is no such column . <p> sizet index ( const RWDBColumn&amp; column ) const ; <p> Returns the index in self 's schema of the first column whose name matches the name of the given column . Returns RWNPOS if there is no such column . <p> where &lt;table&gt; is represented by self . The actual values must be added to the inserter later . If self is not a database table , returns an RWDBInserter with a status of RWDBStatus : : noInserter . <p> NOTE:A cache of 0 is not allowed . If 0 is passed in for this parameter , the parameter is set to 1 . Setting the cache parameter greater than one can adversely affect transactions . Check your access library documentation for limitations and warnings . <p> where &lt;table&gt; is represented by self . The names of the column entries in columnList are used to build up the column-name list . If self is not a @ @ @ @ @ @ @ @ @ @ RWDBStatus : : noInserter . <p> NOTE:A cache of 0 is not allowed . If 0 is passed in for this parameter , the parameter is set to 1 . Setting the cache parameter greater than one can adversely affect transactions . Check your access library documentation for limitations and warnings . <p> where &lt;table&gt; is represented by self . The select-statement is encapsulated by the given select . This method is equivalent to database.inserter ( *this , select ) . If self is not a database table , returns an RWDBInserter with a status of RWDBStatus : : noInserter . <p> where &lt;table&gt; is represented by self . The names of the column entries in columnList are used to build up the column-name list . The select-statement is encapsulated by the given select . This method is equivalent to database.inserter ( *this , select , columnList ) . If self is not a database table , returns an RWDBInserter with a status of RWDBStatus:noInserter . <p> where &lt;table&gt; is represented by self . The select-statement is encapsulated by the given select . This method is equivalent to database.inserter ( @ @ @ @ @ @ @ @ @ @ database table , returns an RWDBInserter with a status of RWDBStatus:noInserter . <p> where &lt;table&gt; is represented by self . The names of the column entries in columnList are used to build up the column-name list . The select-statement is encapsulated by the given select . This method is equivalent to database.inserter ( *this , select , columnList ) . If self is not a database table , returns an RWDBInserter with a status of RWDBStatus : : noInserter . <p> RWBoolean isReady() const ; <p> This function returns TRUE if the object is in ready state , indicating that accessing the object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if the status of self is RWDBStatus : : ok , otherwise returns FALSE . <p> Uses the default connection to fetch the primary key associated with self . Returns the primary key as an RWDBSchema . Updates self 's schema with the return value . <p> RWDBSchema primaryKey ( const RWDBConnection&amp; conn ) ; <p> Uses conn to fetch the primary key associated with self . @ @ @ @ @ @ @ @ @ @ 's schema with the return value . <p> RWDBReader reader ( sizet cache=0 ) const ; <p> Produces an RWDBReader which can be used to read data from self one row at a time . Unless self is a memory table , a query is executed using a default database connection , returning a reader for the contents of the table . The reader holds the connection until the reader is destroyed . <p> Produces an RWDBReader which can be used to read data from self one row at a time . Unless self is a memory table , a query is executed using the supplied connection , returning an RWDBReader for the contents of the table . The RWDBReader holds the connection until the RWDBReader is destroyed . This function can behave asynchronously if executed using an asynchronous connection . <p> Uses conn to append to keyList all foreign keys which refer to self . You can check the return value 's isValid() method to determine whether the operation succeeded . <p> void release() const ; <p> Releases a previously acquired mutex . This function can be called from @ @ @ @ @ @ @ @ @ @ this function evaluates to a no-op . <p> RWDBStatus revoke ( const RWCString&amp; privilege , const RWCString&amp; user ) ; <p> Uses a default database connection to execute the database-specific equivalent of the SQL statement : <p> REVOKEprivilege ON&lt;table&gt;FROMuser <p> where &lt;table&gt; is self 's table name . DBTools.h++ does not validate the supplied arguments . You can check the return value 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . <p> Uses a default database connection to execute the database-specific equivalent of the SQL : <p> REVOKE privilege ON &lt;table&gt; ( &lt;column-list&gt; ) FROM user <p> where &lt;table&gt; is self 's table name , and &lt;column-list&gt; is a list of column names from self 's schema . DBTools.h++ does not validate the supplied arguments . You can check the return value 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . <p> Uses the supplied database connection to execute the database-specific equivalent of the @ @ @ @ @ @ @ @ @ @ is self 's table name . DBTools.h++ does not validate the supplied arguments . You can check the return value 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . This function can behave asynchronously if executed using an asynchronous connection . <p> Uses the supplied database connection to execute the database-specific equivalent of the SQL : <p> **30;11025;TOOLONG ( &lt;column-list&gt; ) FROMuser <p> where &lt;table&gt; is self 's table name , and &lt;column-list&gt; is a list of column names from self 's schema . DBTools.h++ does not validate the supplied arguments . You can check the return value 's isValid() method to see if the operation succeeded . If self is not a database table , the returned object is RWDBStatus : : noPrivilege . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBSchema schema() const ; <p> Returns a deep copy of self 's RWDBSchema . The copy is made so that an application can modify the returned RWDBSchema without changing the schema of the associated @ @ @ @ @ @ @ @ @ @ and schema information until fetchSchema() is called . <p> void **26;11057;TOOLONG : : errorHandler errorHandler ) ; <p> Installs errorHandler as self 's error handler . The supplied handler is inherited by all objects produced by self . By default an RWDBConnection error handler is inherited from the object that produced it . This method overwrites the default . <p> RWDBStatus status() const ; <p> Returns the status of self . <p> RWCString tag() const ; <p> Returns self 's tag . A table 's tag is an alias generated by DBTools.h++ for use in SQL queries . <p> RWDBTable&amp; tag ( const RWCString newTag ) ; <p> Set self 's tag to newTag . Returns reference to self . <p> RWDBUpdater updater() const ; <p> Produces an RWDBUpdater . The result can be augmented with one or more RWDBAssignments in order to create an encapsulated SQL UPDATE statement to update all rows in self . If self is not a database table , returns an RWDBUpdater whose status is RWDBStatus : : noUpdater . <p> RWDBUpdater updater ( const RWDBCriterion&amp; criterion ) const ; <p> Produces an RWDBUpdater . @ @ @ @ @ @ @ @ @ @ in order to create an encapsulated SQL UPDATE statement to update rows in self specified by criterion . If self is not a database table , returns an RWDBUpdater whose status is RWDBStatus : : noUpdater. 
@@75678000 @4378000/ <p> Initializes a new instance of the IlvButton class with a label . The label is copied . The button size is automatically computed from label . If you want to specify the size , use the constructor that takes a rectangle as parameter . <p> Initializes a new instance of the IlvButton class with a bitmap . The bitmap is locked . The button size is automatically computed from the bitmap size . If you want to specify the size , use the constructor that takes a rectangle as parameter . 
@@75678001 @4378001/ <h> Views Graph layout features <h> Automatically organize diagram displays <p> Deliver the most understandable views of data and relationships with this collection of sophisticated algorithms . With Views Graph , compute positions of the elements the " nodes " and " links " of a diagram ( or graph ) tailored to your data sets and user needs . <p> Examples of different graph layout algorithms <h> A variety of node layout algorithms <p> Find and apply the right node layout algorithm for your particular topology and application domain . <h> Fine tuning parameters <p> Do n't settle for algorithm " default settings . " Easily specify the layout direction , spacing between nodes and links , and how links should connect to nodes with a variety of control parameters . Each algorithm type has its own unique set of tuning parameters . <h> Fully customizable <p> Meet the requirements of your end users by delivering the exact layout , look , and interaction capability . Views Graph Layout has a complete application programming interface ( API ) , to customize any part of the diagram display , @ @ @ @ @ @ @ @ @ @ algorithms <p> New types of nodes and links <p> New custom interactions <h> Portability <p> Just like Views , Views Graph runs on Windows , UNIX and Linux . Code developed in one environment can deploy effortlessly to other Windows , Unix , and Linux platforms , removing the need to purchase a chart development product for each platform . 
@@75678002 @4378002/ <h> 10.2 Constructing MIME Part Bodies <p> The MIME specification requires that every simple content type define a standard format , called the canonical form . The MIME specification recommends that data be converted to canonical form before the data is encoded or inserted into a message . The specification describes the canonical form of a few media types and outlines a process for registering new types . The Internet Assigned Numbers Authority publishes a list of assigned media types and maintains a repository of the data format descriptions for those types . <p> For text , the canonical form uses a carriage return ( ASCII 13 ) followed by a line feed ( ASCII 10 ) to indicate a line break . Typically , an application converts text to canonical form before including the text in a message . <p> For most other content types , the canonical form is identical to the normal format of the file . A good working strategy is to always convert text to canonical form and to assume that other data does not require conversion . We use this strategy in this @ @ @ @ @ @ @ @ @ @ formats might have a canonical form different than the normal format of the data . See Appendix C for information on the type registry and repository of data format descriptions . <p> There is no canonical form for multipart content types . Instead , each part contained in a multipart body must be in canonical form . <p> A MIME part body may contain nested MIME parts . In this case , each nested part contains its own set of headers and its own part body . The top-level part has the media type multipart . <p> The MIME specification defines four multipart subtypes . The MIME package also supports an additional multipart subtype , the multipart/related content type described in RFC 2387 . All multipart types require that the header value contain a boundary parameter . The value of the boundary parameter delimits the parts of the message . For example , the message snippet below contains two parts delimited by theboundary : <p> Content-Type : multipart/mixed ; boundary= " theboundary " --theboundary This is the first part , in plain text . --theboundary Content-Type : text/plain ; charset=us-ascii @ @ @ @ @ @ @ @ @ @ but with a Content-Type header . --theboundary-- <p> Since the MIME format uses the value of the boundary parameter to tell where parts begin and end , it 's important that the value does not occur in the content of any message part . This restriction includes parts which are themselves multiparts . In other words , if a message contains more than one multipart , each multipart in the message must use a different boundary . Otherwise , a recipient has no way to reconstruct the message accurately . <p> An RWMimeMultipart must not contain itself , either directly or indirectly . A part that contains itself can not be represented as a string . <p> The relationship between the parts of a multipart media type determines the subtype . The table below describe common multipart types : <h> Table 2 : MIME multipart subtypes <p> Multipart subtype <p> Relationship of parts <p> mixed <p> Parts are unrelated documents ( for example , email attachments ) . <p> related <p> Parts are components of a single document ( for example , an HTML page and the images in that @ @ @ @ @ @ @ @ @ @ simultaneously ( for example , audio and video ) . <p> alternative <p> Parts contain the same content in alternative formats ( for example , an HTML page and a plain text equivalent ) . <p> digest <p> Parts are RFC 822 ( email ) messages . <p> A Content-Type of multipart/mixed is typically used for email attachments , and is therefore the most common multipart type . A default-constructed R-WMimeMultipartType object represents a multipart/mixed header value . <p> The value of a **29;11085;TOOLONG contains a boundary parameter , a required type parameter and two optional parameters , start and start-info . The type parameter matches the Content-Type of the part to be processed first . By default , an application begins processing a multipart/related body at the first contained part . If the start parameter is present , an application begins processing a multipart/related body at the part that contains a Content-ID value matching the value of the start parameter . If the start-info parameter is present , the value of the parameter provides information for the processing application . The MIME package provides class **26;11116;TOOLONG for convenience in @ @ @ @ @ @ @ @ @ @ . 50235 @qwx670235 
@@75678003 @4378003/ <h> Synopsis <h> Required Arguments <p> intnobservations ( Input ) Number of observations in each time series . nobservations must be greater than or equal to 2 . <p> float x(Input) Array of length nobservations containing the first time series . <p> float y(Input) Array of length nobservations containing the second time series . <p> int lagmax ( Input ) Maximum lag of cross-covariances and cross-correlations to be computed . lagmax must be greater than or equal to 1 and less than nobservations . <h> Return Value <p> Pointer to an array of length 2*lagmax + 1 containing the cross-correlations between the time series x and y . The kth element of this array contains the cross-correlation between x and y at lag ( k-lagmax ) where k = 0 , 1 , , 2*lagmax . To release this space , use free . If no solution can be computed , NULL is returned . <h> Optional Arguments <p> IMSLSRETURNUSER , float crosscorrelations ( Output ) If specified , crosscorrelations is an array of length 2*lagmax + 1 containing the cross-correlations between the time series x and y . @ @ @ @ @ @ @ @ @ @ x and y at lag ( k-lagmax ) where k = 0 , 1 , , 2*lagmax . <p> IMSLSVARIANCES , float *xvariance , float*yvariance ( Output ) If specified , xvariance is variance of the time series x and yvariance is variance of the time series y . <p> IMSLSSECCF , float**standarderrors , intseoption ( Output ) Address of a pointer to an array of length 2*lagmax + 1containing the standard errors of the cross-correlations between the time series x and y . Method of computation for standard errors of the cross-correlations is chosen by seoption . <p> Compute standard errors of cross-correlations using Bartletts formula with the assumption of no cross-correlation . <p> IMSLSSECCFUSER , floatstandarderrors , intseoption ( Output ) If specified , standarderrors is an array of length 2*lagmax + 1 containing the standard errors of the cross-correlations between the time series x and y . See IMSLSSECC . <p> IMSLSCROSSCOVARIANCES , float**crosscovariances ( Output ) Address of a pointer to an array of length 2*lagmax + 1 containing the cross-covariances between the time series x and y . The kth element of this array contains @ @ @ @ @ @ @ @ @ @ ) where k = 0 , 1 , , 2*lagmax . <p> **25;11144;TOOLONG , floatcrosscovariances ( Output ) If specified , crosscovariances is an array of length 2*lagmax + 1 the cross-covariances between the time series x and y . See IMSLSCROSSCOVARIANCES . <p> IMSLSINPUTMEANS , floatxmeanin , float ymeanin ( Input ) If specified , xmeanin is the user input of the estimate of the mean of the time series x and ymeanin is the user input of the estimate of the mean of the time series y . <p> IMSLSOUTPUTMEANS , float*xmeanout , float *ymeanout ( Output ) If specified , xmeanout is the mean of the time series x and ymeanout is the mean of the time series y . <h> Description <p> Function imslsfcrosscorrelation estimates the cross-correlation function of two jointly stationary time series given a sample of n = nobservations observations Xt and Yt for t = 1 , 2 , , n . <p> Let <p> be the estimate of the mean mX of the time series Xt where <p> The autocovariance function of Xt , sX(k) , is estimated by <p> where K @ @ @ @ @ @ @ @ @ @ sample variance xvariance . The autocorrelation function rX(k) is estimated by <p> Note that <p> by definition . Let <p> be similarly defined . <p> The cross-covariance function sXY(k) is estimated by <p> The cross-correlation function rXY(k) is estimated by <p> The standard errors of the sample cross-correlations may be optionally computed according to argument seoption for the optional argument IMSLSSECCF . One method is based on a general asymptotic expression for the variance of the sample cross-correlation coefficient of two jointly stationary time series with independent , identically distributed normal errors given by Bartlett ( 1978 , page 352 ) . The theoretical formula is <p> For computational purposes , the autocorrelations rX(k) and rY(k) and the cross-correlations rXY(k) are replaced by their corresponding estimates for k K , and the limits of summation are equal to zero for all k such that k &gt; K. <p> A second method evaluates Bartletts formula under the additional assumption that the two series have no cross-correlation . The theoretical formula is <p> For additional special cases of Bartletts formula , see Box and Jenkins ( 1976 , page 377 ) . @ @ @ @ @ @ @ @ @ @ = sYX(-k) for k 0 . This result is used in the computation of the standard error of the sample cross-correlation for lag k &lt; 0 . In general , the cross-covariance function is not symmetric about zero so both positive and negative lags are of interest . <h> Example <p> Consider the Gas Furnace Data ( Box and Jenkins 1976 , pages 532533 ) where X is the input gas rate in cubic feet/minute and Y is the percent CO2 in the outlet gas . Function imslsfcrosscorrelation is used to compute the cross-covariances and cross-correlations between time series X and Y with lags from -lagmax = -10 through lag lagmax = 10 . In addition , the estimated standard errors of the estimated cross-correlations are computed . The standard errors are based on the additional assumption that all cross-correlations for X and Y are zero . 
@@75678004 @4378004/ <p> The RWThreadPool object manages a pool of RWThread instances that are used to execute work encapsulated as RWFunctor0 functors . A thread pool object , when started , waits for other threads to enqueue work functors that they would like to have executed . Pool threads dequeue functors and execute them to completion . This process continues until the thread pool object passes out of scope , the destructor is called , or the stop() member function is called . <p> A thread pool can have a fixed number of threads , or its size may grow and shrink dynamically , according to load . The dynamic nature of the pool is controlled by parameters in the make() member function . <p> Enqueues a piece of work in the functor onto the thread pool . All functors must be valid ; that is , functor.isValid() must return TRUE . All exceptions that might be thrown within functor must be handled within functor . <p> Invalid functors and exceptions thrown by functors but not caught by functors will be ignored in the release version of the compiled source code @ @ @ @ @ @ @ @ @ @ source code in debug mode , which will throw assertions when invalid functors are found or uncaught exceptions are thrown . <p> sizet entries(void) const ; <p> Returns the number of work entries queued in the thread pool . <p> RWThreadAttribute getPoolAttribute(void) ; <p> Gets a handle to the thread attribute instance specified during thread pool construction . <p> Makes a thread pool instance with a pool that contains from minThreads to maxThreads threads . The actual number of threads will grow and shrink between minThreads and maxThreads , depending on the work load . A thread will await work for at least timeout milliseconds before exiting . The thread pool threads are created with default thread attributes . <p> Makes a thread pool instance with a pool that contains from minThreads to maxThreads threads , each created with the specified thread attributes . The actual number of threads will grow and shrink between minThreads and maxThreads , depending on the work load . A thread will await work for at least timeout milliseconds before exiting . <p> You are responsible for determining the suitability of thread pool attributes . @ @ @ @ @ @ @ @ @ @ poolThreadsAttr to RWTHRSTARTINTERRUPTED , then RWThreadPool would hang because all of the threads in the thread pool would be waiting for RWRunnable : : releaseInterrupt() calls . <p> sizet size(void) const ; <p> Returns the size of the thread pool , that is , the number of threads currently in the pool . <p> void stop(void) ; <p> Stops work execution after the thread pool executes all the work that is currently enqueued . No additional work may be enqueued after stop() is called . 
@@75678006 @4378006/ <p> Use thisdialog box to modify the properties of an existing action point . This dialog box let 's you control attributes of your action point as well as change it from one kind of action point into another . If you are creating an evaluation point , use this window to enter your C , Fortran , or Assembler code . <p> Figure 63 " Action Point &gt; Properties Dialog Box <p> NOTE &gt;&gt; The only kind of action point not controlled by this dialog box is the watchpoint . Use theTools &gt; Create Watchpointcommand within a Variable Window when you want to set or alter a watchpoint . <p> The following three controls set or change what happens when a program encounters an action point : <p> Process barrier breakpoints are similar to simple breakpoints , differing in that they let you synchronize a group of processes in a multiprocess program . Other controls let you indicate if the thread 's process or control group will also stop and what condition must be satisfied for TotalView to release threads held at the barrier . <p> An evaluation point @ @ @ @ @ @ @ @ @ @ When a thread or process encounters an evaluation point , it executes this code . You can use evaluation points in several different ways , including as conditional breakpoints , thread-specific breakpoints , countdown breakpoints , and for patching code fragments into and out of your program . <p> The following four controls are used by all three kinds of action points . <p> Addresses <p> If the selected line could be mapped to more than one place " for example , you selected a line in a template or an inline function " selecting this button displays a dialog box to refine where TotalView places breakpoints . Do this by individually selecting or clearing the locations at which TotalView will set the breakpoint . <p> Figure 64 " Action Point and Addresses Dialog Boxes <p> Initially , addresses are either enabled or disabled , but you can change their state by clicking the checkbox in the first column . The checkbox in the columns bar enables or disables all the addresses . This dialog supports selecting multiple separate items ( Ctrl-Click ) or a range of items ( Shift-Click @ @ @ @ @ @ @ @ @ @ is selected , right-click one of the selected items and choose Enable Selection or Disable Selection from the context menu . <p> Filtering <p> In massively parallel programs , the number of addresses can become very large , so the Addresses dialog has several mechanisms to help you manage the data . The search box filters the currently displayed data based on one or more space-separated strings or phrases ( enclosed in quotes ) . Remember that data not currently displayed is not included in the filtering . It may be helpful to click the Detailed Information checkbox , which displays much more complete information , giving you more possibilities for filtering . <p> Sorting <p> Clicking on the column labels performs a sort based on the data in that column . Each click toggles between ascending and descending order . If entry values in a column are the same , the values of the column to the right of the sorted column are examined and sorted based on those values . If the values are the same , the next column is examined and so on , until different @ @ @ @ @ @ @ @ @ @ sort , i.e. if all the entries are the same in the selected column and in the columns to the right , the list is not modified . <p> Displaying and rearranging columns <p> Finally , right-clicking in the columns bar presents a context menu for displaying or hiding columns . All are initially displayed except Image . You can reorder the columns by selecting a column label and dragging it to a new location . <p> Keyboard Shortcuts <p> To provide easy access to the buttons at the bottom of the Addresses dialog , the following mnemonic keys have been assigned . <p> Button <p> Keyboard Sequence <p> OK <p> Alt-o <p> Cancel <p> Alt-c <p> Help <p> Alt-h <p> Process <p> Let 's you indicate which process in a multi-process program will have enabled breakpoints . After selecting this button , TotalView displays a dialog box similar to the one it displays when you select the Addresses button . Note that if Plant in share group is selected , this button is not enabled because you 've told TotalView to set the breakpoint in all processes . <p> Enable @ @ @ @ @ @ @ @ @ @ point . If this control is not selected , TotalView ignores the action point . <p> Plant in share group <p> When set , the action point is shared among all of the threads in the thread 's share group . In all cases , TotalView places an action point in each member of the share group . <p> If you select this option , TotalView enables ( makes active ) all of these points . <p> If you do not select this option , TotalView only enables this action point ; all others are disabled . 
@@75678007 @4378007/ <p> Connections represent a scarce resource that applications can allocate and manage themselves . An RWDBConnection is an object that may be requested from an RWDBDatabase , and passed to many methods to specify that the method should use the given connection . Operations requested without supplying a connection are performed using a connection supplied invisibly by RWDBDatabase . If none are available , an error results . Thus , the use of explicit connections eliminates one likely source of errors , at some cost in program complexity . <p> Each RWDBConnection knows which RWDBDatabase produced it , and each RWDBDatabase knows what connections it has produced . <p> RWDBConnection is designed around the Interface/Implementation paradigm . An RWDBConnection instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBConnection implementation is a base class from which a family of database-specific connection implementations is derived . <p> The default constructor creates an RWDBConnection whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience , for example , for declaring an array @ @ @ @ @ @ @ @ @ @ <p> RWDBConnection ( const RWDBConnection&amp; connection ) ; <p> Copy constructor . The created object shares an implementation with connection . <p> Attempts to acquire the internal mutex lock . If the mutex is already locked by another thread , the function blocks until the mutex is released . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWDBStatus beginTransaction ( const RWCString&amp; name=RWCString() ) ; <p> Sends a begin transaction , or the vendor-specific equivalent , to the database server . Here name means the name of the transaction , if you choose to supply it and the vendor supports named transactions . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBStatus close() ; <p> Closes this connection . This method should only be used in exceptional circumstances , as it causes all references to this connection to become unusable . It is usually best to allow connections to close themselves as they go out of scope . <p> RWDBStatus commitTransaction ( const RWCString&amp; name=RWCString() ) ; <p> Sends @ @ @ @ @ @ @ @ @ @ the database server . Here name means the name of the transaction , if you choose to supply it and the vendor supports named transactions . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBConnection : : ConnectionType connectionType() const ; <p> Returns the connection type of self . An RWDBConnection can be synchronous or asynchronous . <p> The SQL statement(s) in sqlProgram are submitted to the connection for execution . DBTools.h++ does not check the contents of sqlProgram for validity . The return value represents a sequence of zero or more RWDBTables . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBConnection : : IsolationType isolation() const ; <p> Returns self 's isolation level , as defined by the most recent call to isolation() . If isolation ( RWDBConnection : : IsolationType level ) has not been called , returns Unknown . In this case , self 's isolation level is whatever the database vendor provides by default . <p> RWDBStatus isolation ( RWDBConnection : : IsolationType level ) ; <p> Makes a database-specific call or calls to set @ @ @ @ @ @ @ @ @ @ details vary widely among database vendor implementations . This function can behave asynchronously if executed using an asynchronous connection . See your DBTools.h++ access library guide and your database vendor 's manual for exact details on isolation levels . <p> RWBoolean isReady() const ; <p> This function returns TRUE if the object is in ready state , indicating that accessing the object will not block . Accessing a nonready object may potentially block . <p> RWBoolean isValid() const ; <p> Returns TRUE if the status of this connection is RWDBStatus : : ok , otherwise returns FALSE . <p> RWDBStatus open() ; <p> Reopens this connection after closing or error condition . If the connection can not be opened for use , both the status returned and the connection will be invalid . <p> void release() const ; <p> Releases a previously acquired mutex . This function can be called from a const object . Note : in nonmultithreaded builds , this function evaluates to a no-op . <p> RWDBStatus **25;11171;TOOLONG RWCString&amp; name=RWCString() ) ; <p> Sends a rollback transaction , or the vendor-specific equivalent , to the database server @ @ @ @ @ @ @ @ @ @ if you choose to supply it and the vendor supports named transactions . This function can behave asynchronously if executed using an asynchronous connection . <p> void **26;11198;TOOLONG : : ErrorHandler handler ) ; <p> Installs handler as the error handler for self . The supplied handler is called whenever the status of self changes to anything except RWDBStatus : : ok . By default , the error handler of an RWDBConnection is inherited from the RWDBDatabase that produced the RWDBConnection ; this method overrides the default . ErrorHandler is declared as a typedef within the scope of RWDBStatus : <p> typedef void ( *ErrorHandler ) ( const RWDBStatus&amp; ) ; <p> RWDBStatus setSavepoint ( const RWCString&amp; name ) ; <p> Sends a savepoint name or the vendor-specific equivalent to the database server . <p> RWDBStatus status() const ; <p> Provides the current status of this connection . <p> RWDBSystemHandle* systemHandle() ; <p> This member allows an application to gain access to the underlying vendor-specific database API . The result is a pointer to the base class RWDBSystemHandle , which must be cast by the application to a derived class @ @ @ @ @ @ @ @ @ @ in a type-safe manner if your compiler supports runtime type identification . See your DBTools.h++ access library guide for details on the name and contents of the database-specific system handle variants . 
@@75678008 @4378008/ <h> Prefix <p> The following table shows the standard mnemonics for all Rogue Wave products . <h> Version ( DLLs only ) <p> DLLs created for a shared library build on Windows platforms may include a one- or two-digit number representing the major and minor release numbers of the part used in the build . For example , the version number " 70 " for Tools.h++ would represent major release 7.0 ( before any minor releases ) . The actual version used in the build could include a maintenance release number , as in 7.0.8 . A possible DLL name , then , for a Tools.h++ build would be tls703d.dll , where " 70 " represents the version and " 3d " represents the build type . <p> The build type code is generated from a four-bit field where each bit indicates the setting for some build option . The meanings of the bit positions are shown in the following table : <p> The following table shows the full set of option settings for each build type code . For this release of Software Parts Manager , debugging always @ @ @ @ @ @ @ @ @ @ in the build . Also , beginning with the Nov 1997 release , the Standard C++ Library uses codes 8 through 15 for compatibility with products built on top of it . <h> Linkage Type Code <p> The following table shows the two possible values for the linkage type code : <p> CBM includes a provision for adding a custom suffix to generated library names . This suffix may prove useful to distinguish the library names of different build configurations you define . <p> This suffix is also added to DLL names , which provides a way of avoiding a potential collision of these names : DLLs built with the same build type and linkage option under the Msvc and Borland compilers will have the same name , posing an identification problem . To avoid this , you can create a custom compiler properties file that specifies , for example , a " b " suffix for DLLs compiled under Borland , thus creating a distinct name . <h> Platform Extension <p> The platform extension depends on the extension conventions for the platform targeted in the build . For most @ @ @ @ @ @ @ @ @ @ type . 
@@75678009 @4378009/ <h> 2.3 Data Types <p> The classes RWDBColumn and RWDBValue have an associated RWDBValue : : ValueType that specifies the data type of the database column or field being referenced . Mapping between this data type and the database vendor type runs in both directions : <p> When fetching data or retrieving information about tables , the DB Access Module for Oracle OCI converts the Oracle-specific data type information provided by the database into RWDBValue : : ValueTypes . This mapping is shown in Table 1 , which also gives the C++ data type corresponding to the RWDBValue : : ValueType . <p> When creating tables , the DB Access Module for Oracle OCI maps the given RWDBValue : : ValueType into an Oracle-specific type . This mapping is shown in Table 2 . <p> NUMBER(d) , where d is the number of digits needed to store the maximum value an int can express on the client machine <p> Long , UnsignedLong <p> NUMBER(d) , where d is the number of digits needed to store the maximum value a long can express on the client machine <p> LongLong , @ @ @ @ @ @ @ @ @ @ needed to store the maximum value a long long can express on the client machine <p> MBString , UString , WString <p> NVARCHAR2(n) using the storageLength of the RWDBColumn , if specified NVARCHAR2(2000) otherwise <p> Short , UnsignedShort , Tiny , UnsignedTiny <p> NUMBER(d) , where d is the number of digits needed to store the maximum value a short can express on the client machine <p> String <p> CLOB , if nativeType of the RWDBColumn is SQLTCLOB . VARCHAR2(n) , using the storageLength of the RWDBColumn , if 0 &lt; storageLength &lt;= 4000LONG , otherwise <p> NoType <p> If nativeType of the RWDBColumn is : " SQLTNUM , then NUMBER ( p , s ) , using precision and scale of the RWDBColumn " SQLTRDD , then ROWID " SQLTBFLOAT or SQLTIBFLOAT , then BINARYFLOAT " SQLTBDOUBLE or SQLTIBDOUBLE , then BINARYDOUBLE <p> To switch between these types , use the useTimestamp() method of the custom environment handle class , RWDBOCIEnvironmentHandle . <p> Oracle OCI servers place restrictions on the use of certain data types . Where possible , the DB Interface Module is flexible about data types . @ @ @ @ @ @ @ @ @ @ , and in these cases your application must be aware of the contexts in which certain data types can be used . Table 3 outlines the restrictions associated with each DB Interface Module type . <h> Table 3 : Restrictions on the use of DB Interface Module data types <p> RWDBValue : : ValueType <p> Restrictions <p> Blob <p> No restrictions <p> Char , UnsignedChar <p> No restrictions <p> Date <p> No restrictions <p> DateTime <p> Oracle 's TIMESTAMP datatype can hold fractional seconds with a precision of 0 through 9 , but RWDBDateTime1 and RWDateTime are limited to milliseconds. 50235 @qwx670235 
@@75678011 @4378011/ <h> 10.3 Error Reporting and Error Handling <p> Error reporting in C++ is often accomplished through the use of exceptions . When an error condition is encountered , an application can throw an exception to report the error condition , as follows : <p> if ( errorCondition ) throw E ; <p> " E " in the above throw statement can be any type . One may choose simply to throw an integer error code , or to use a customized error class providing detailed information regarding the error condition . When such exceptions are thrown and not specifically caught , the application in which the exception is thrown abnormally ends . To avoid abnormal program terminations , you should surround code that could throw an exception with a " try-catch " block , as follows : <p> try possibleException() ; catch ( E e ) handleException() ; <p> The code that may throw an exception is placed within the try block . If an exception of type " E " is thrown , then it may be " caught " in the catch block that follows . If @ @ @ @ @ @ @ @ @ @ the same as the type of a thrown exception ( or is not a base class of the type of exception thrown ) , then the exception is not caught , and the program will terminate . If , however , the type of exception thrown does match that in the catch statement , then the code in the following catch block will be executed to handle the exception . <p> The RWxmsg class serves as a base class for the various exception types that can be thrown and caught within the Essential Tools Module library , or from within Essential Tools Module client applications . <p> As shown in Figure 11 , RWxmsg serves as a base class for all exception types . From this point , the three major types of exceptions are derived : external errors , internal errors , and stream buffer allocation errors . Let us describe each of these classes in greater detail . <p> RWxmsg provides a basic interface for exceptions , from which an exception string is always available . This exception string is obtained through the why method , and is @ @ @ @ @ @ @ @ @ @ <p> RWExternalErr is derived from RWxmsg , and is used to report errors caused by external sources over which the library has no control . Currently , this class is used to report errors from RWFileManager and RWCollectable during file processing when an invalid file format is encountered . <p> In this example , the instantiation ( and consequent pattern compilation ) could result in a pattern compilation error that would be reported through an exception of type RWRegexErr . Therefore , the instantiation is surrounded in a try-catch block that catches exceptions of type RWRegexErr . <p> Another use of these classes is in setting " call-back " functions in environments in which exceptions are not enabled . <p> In Windows environments , the default error-handling scheme is to display a Windows message box with the error string , after which the program terminates . In UNIX environments , the error message is written to stderr , and then the program terminates . However , the Essential Tools Module provides a method of setting a user-defined call-back function to be invoked in place of the default error handler whenever @ @ @ @ @ @ @ @ @ @ set the call-back is named rwSetErrHandler and is declared as follows . <p> rwErrHandler rwexport **29;11226;TOOLONG ; <p> The method accepts as an argument a call-back function conforming to the type rwErrHandler . Upon completion , the method returns the previously installed error handler . Call-back functions must have the following signature , as defined by the rwErrHandler typedef . <p> typedef void ( *rwErrHandler ) ( const RWxmsg&amp; ) ; <p> The function must return void and accept a const reference to an RWxmsg object . 
@@75678012 @4378012/ <h> 5.2 Checking Status with Class RWDBStatus <p> Class RWDBStatusis an important component of the DBTools.h++ error model . Each RWDBStatus instance encapsulates the error state of an object or operation . Here is a partial listing of the definition of class RWDBStatus : <p> Notice that the ErrorCode enumeration is scoped within class RWDBStatus . To avoid polluting the global name space , all DBTools.h++enums are scoped within classes . To refer to a member of the enumeration outside the scope of class RWDBStatus , use the scoping operator : : , as in RWDBStatus : : ok , for example . Appendix A lists the possible RWDBStatus : : ErrorCode values . <p> A valid object , or a successful operation , is represented by an ErrorCode of RWDBStatus : : ok . An RWDBStatusinstance whose ErrorCode is vendorLib , serverError , or serverMessage reflects a database error or error of some kind , and contains database-dependent information . Other RWDBStatus instances represent errors generated by DBTools.h++ itself . <p> All DBTools.h++ classes that interact with a database have a status , accessible through a status()method . @ @ @ @ @ @ @ @ @ @ In classes that have status , certain member functions generate errors that do not affect the object itself . For example , the drop() method of RWDBTable succeeds or fails without affecting the RWDBTable itself . This type of method returns an RWDBStatusobject instead . Errors encountered by all other member functions result in a change of status in the object itself . <p> On //1 , the isValid() function , which in general checks the RWDBStatusof the object through which it was invoked , checks the status of the reader . This inline error checking technique has some advantages . For one thing , it is simple . Also , trapping an error close to the point where it occurs gives an application more context with which to handle the error . Here we are able to identify what was going on at the time the error occurred , that is , the application was reading anotherTable . <p> The error handling in this example is rudimentary : print a message , exit the processing loop , and continue . The loop is exited because the reader()call returns 0 @ @ @ @ @ @ @ @ @ @ This type of error handling is adequate in some contexts , but not in others . Inline error checking clutters up the original code , and distracts both the programmer and the reader of the code from its main purpose . Section 5.3 presents a less disruptive , more centralized method of reporting errors using error handlers. 
@@75678013 @4378013/ <h> Service Manager Performance <p> Akana has proven Service Manager 's ability to scale to handle more than 1 billion transactions per hour . Service Manager is the industry 's highest performing and most scalable Web Services Management product . <p> Service Manager Network Director intermediaries are fully stateless , this delivers two very important capabilities . First , it offers exceptional scalablity , allowing Network Director instances to be added to clustered pools seamlessly without changing any infrastructure or service configuation . Secondly , because the configuration for the policies that will be applied to a service are stored centrally , switching the type or instance of an intermediary for a service is seamless and instantaneous . <p> As described above , the Network Director is a fully stateless platform offering near limitless scalability . All Service Manager and Policy Manager subsystems implement the same stateless architecture relying on a commercial relational database ( Oracle , SQL Server or DB2 ) for state management where needed . <p> All of the subsystems are implemented as Web services and are registered in the UDDI registry . All intermediaries and @ @ @ @ @ @ @ @ @ @ available peers with which they may need communicate . Each peer has a specified load-balancing weighting that the components use to determine when to route requests to them . <p> This same model ( load-balancing weighting meta-data stored in the Registry ) to determine how to load-balance Web service requests over multiple instances of the same service . These weightings are dynamically modified by the SLA-based routing capabilities of the product described earlier . <p> All the subsystems are fully stateless and can be ( and usually are ) deployed in a failover configuration to eliminate any possible single point of failure . <p> Latency varies considerably based on the type of intermediary deplopyed ( agent or Network Director ) and the complexity of the policy being executed ( cryptographic and transformation policies add latency ) . In testing we have consistently shown sub millisecond latency for the agents , and sub 5 millisecond latencies for the proxy . 
@@75678014 @4378014/ <p> Returns true if self compares equal to lst , otherwise returns false . Two collections are equal if both have the same number of entries , and iterating through both collections produces , in turn , individual elements that compare equal to each other . <p> If there exists an element t in self such that the expression ( ( *fn ) ( t , d ) ) is true , assigns t to k and returns true . Otherwise , returns false and leaves the value of k unchanged . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> reference first() ; constreference first() const ; <p> Returns a reference to the first element of self . <p> T* get() ; <p> Removes and returns the first element in the collection . This method is identical to removeFirst and is included to provide compatibility with previous versions . <p> sizetype index ( constreference a ) const ; <p> Returns the position of the first item t in self such that ( t == a ) , or returns the @ @ @ @ @ @ @ @ @ @ sizetype index ( bool ( *fn ) ( constreference , void* ) , void* d ) const ; <p> Returns the position of the first item t in self such that ( ( *fn ) ( t , d ) ) is true , or returns the static member npos if no such item exists . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool insert ( constreference a ) ; <p> Adds the item a to the end of the collection . Returns true . <p> void insertAt ( sizetype i , const T&amp; a ) ; <p> Inserts the item a in front of the item at position i in self . This position must be between 0 and the number of entries in the collection , otherwise the function throws an exception of type RWBoundsErr . <p> bool isEmpty() const ; <p> Returns true if there are no items in the collection , false otherwise . <p> Returns the number of elements t in self such that the expression ( ( *fn ) ( t , d ) @ @ @ @ @ @ @ @ @ @ function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> void prepend ( constreference a ) ; <p> Adds the item a to the beginning of the collection . <p> bool remove ( constreference a ) ; <p> Removes the first element t in self such that the expression ( t == a ) is true and returns true . Returns false if there is no such element . <p> bool remove ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes the first element t in self such that the expression ( ( *fn ) ( t , d ) ) is true and returns true . Returns false if there is no such element . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> sizetype removeAll ( constreference a ) ; <p> Removes all elements t in self such that the expression ( t == a ) is true . Returns the number of items removed . <p> sizetype removeAll ( bool ( *fn ) ( constreference , void* ) , void* @ @ @ @ @ @ @ @ @ @ such that the expression ( ( *fn ) ( t , d ) ) is true . Returns the number of items removed . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> T removeAt ( sizetype i ) ; <p> Removes and returns the item at position i in self . This position must be between 0 and one less then the number of entries in the collection , otherwise the function throws an exception of type RWBoundsErr . <p> T removeFirst() ; <p> Removes and returns the first item in the collection . <p> T removeLast() ; <p> Removes and returns the first item in the collection . <p> sizetype **25;11257;TOOLONG oldVal , constreference newVal ) ; <p> Replaces all elements t in self such that the expression ( t == oldVal ) is true with newVal . Returns the number of items replaced . <p> Replaces all elements t in self such that the expression ( ( *fn ) ( t , d ) ) is true with the value nv . Returns the number of items replaced . @ @ @ @ @ @ @ @ @ @ prototype : 50232 @qwx670232 50233 @qwx670233 <p> void sort() ; <p> Sorts the collection using the less-than operator to compare elements . <p> rwslist&lt;T&gt;&amp; std() ; <p> const rwslist&lt;T&gt;&amp; std() const ; <p> Returns a reference to the underlying C++-standard collection that serves as the implementation for self . This reference may be used freely , providing access to the C++-standard interface as well as interoperability with other software components that make use of the C++-standard collections . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75678015 @4378015/ <h> Static Public Member Functions <h> Friends 50231 @qwx670231 <p> Gadget class . <p> Library : ilvgadgt <p> The IlvComboBox class combines a text field ( IlvTextField class ) with a pop-up menu displaying a set of predefined entries from which the user can choose . <p> - A Combo Box - <p> The user can enter a character string in the text field , or click on the arrow appearing on the right side of the field and select one of the choices from the menu that is displayed . You can access the pop-up menu attached to the combo box to modify its behavior . <h> Member Function Documentation <p> You can override this member function in a subclass to create your own items . 50234 @qwx670234 <p> label <p> The item label . <p> graphic <p> The IlvGraphic object representing the picture associated with the item . <p> bitmap <p> The IlvBitmap object representing the picture associated with the item . <p> selbitmap <p> The IlvBitmap object representing the picture of the item when it is selected . <p> copy <p> A Boolean value specifying whether @ @ @ @ @ @ @ @ @ @ IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvGadgetItem . <p> Warning : <p> note If both the second and third parameters are not null , only the second parameter is used . 
@@75678016 @4378016/ <h> Rogue Wave Software Acquires Enterprise Open Source Vendor OpenLogic <p> Boulder , CO " 8/22/2013 <p> Rogue Wave Software announced today that it has acquired OpenLogic , Inc. , the leading provider of cloud-based open source software management solutions , support , and consulting . Broomfield , Colorado-based OpenLogic offers a platform , OpenLogic Exchange ( OLEX ) , which enables software development teams to leverage the breadth and innovation of open source software . In an effort to get higher-quality applications to market more quickly , developers increasingly combine their own custom code with both commercial frameworks and open source packages . The combination of Rogue Wave and OpenLogic creates an unparalleled partner for developers , enabling them to write better code , faster . <p> " Rogue Wave has a rich history of providing market-leading commercial frameworks and tools used by developers to build world-class applications , " said Brian Pierce , CEO of Rogue Wave . " With the acquisition of OpenLogic , we can be an even better partner in the application development process by enabling developers to complement their own custom code with @ @ @ @ @ @ @ @ @ @ world-class team , with its unrivaled open source expertise , is a tremendous addition to the Rogue Wave family . " <p> OpenLogics OLEX platform was designed from its inception as a cloud-based SaaS solution . From their web browsers , developers can utilize OLEX to provision thousands of open source packages , set governance policies for the use of open source software , and scan their applications for open source code . Moreover , OpenLogics open source expertise extends to enterprise-grade support for more than 850 open source packages , as well as training and consulting services designed to help customers optimize their implementation of open source software . <p> " Rogue Waves size and market reach will be of tremendous value to OpenLogics customers , " said Steven Grandchamp , CEO of OpenLogic . " The adoption of open source software is growing at an increasing rate , and Rogue Waves customers now have a single vendor solution combining the open source usage with their commercial library usage . " The OpenLogic team will continue to provide customers with the same outstanding service and support that they have @ @ @ @ @ @ @ @ @ @ of a much larger organization . 
@@75678017 @4378017/ <h> com.imsl.math Class SparseMatrix <p> Sparse matrix of type double . The class represents a general real sparse matrix . It is intended to be efficiently and easily updated . <p> A SparseMatrix can be constructed from a set of arrays , or it can be abstractly created as an empty array and then incrementally built into final form . It is usually easier to create an empty SparseMatrix of set size and then use the set method to set the elements of the array . When setting the elements of the sparse array , their positions should be thought of as their positions in the dense array . Elements can be set in any order , but only the elements actually set are stored . <p> This class includes methods to update the sparse matrix . There are also methods to multiply a sparse matrix and a vector or to multiply two sparse matrices . To solve a sparse linear system use SparseCholesky or SuperLU . <p> nColumns - an int containing the number of columns in the sparse matrix . <p> index - an int jagged array @ @ @ @ @ @ @ @ @ @ the compressed representation of the sparse matrix in values . The size of index must be identical to the size of values . The i-th row contains the column indices of all nonzero elements of row i of the sparse matrix . The j-th element of row i is the column index of the value located at the same position in values . <p> values - a double jagged array containing the compressed representation of a real sparse matrix of size nRows by nColumns . The number of rows in values must be nRows . The i-th row contains all nonzero elements of row i of the full sparse matrix . 
@@75678020 @4378020/ <p> You want to focus on value and features , not reinventing the wheel , by choosing the right tools to make development easier . Tools that allow you to create code that 's robust , effective , and easy to maintain . Using the right tools can mean the difference between meeting the release schedule or missing it , between building a solid code foundation or re-writing key codelines year after year . <p> Our C/C++ , Java , Python , and PHP libraries are built for one purpose : to create software that stands the test of time in mission-critical applications . We speed up code development and allow developers to work across platforms , languages , and compilers time and time again . Embed great code . Reuse key components . Reliably deliver functionality to your customers faster . <p> Write code once and deploy on any platform with SourcePro . This infrastructure layer for C++ insulates developers from the complexities of underlying platforms and provides low-level access to common functions . This way , you can benefit from the latest platform technologies without rewriting your code @ @ @ @ @ @ @ @ @ @ , separating the presentation layer from the data allows you to support multiple platforms and insulate the user from future underlying changes . Apigility helps build APIs around business logic , helping you create well-structured RESTful or RPC services for authentication , content negotiation , validation , and error reporting . Designed to simplify the creation and maintenance of useful , easy to consume APIs , Apigility makes controlled consumer access to your data a reality . <p> IMSL Numerical Libraries are built by mathematicians and statisticians for developers that need math and statistics . From prototype to deployment , IMSL is a proven , reliable set of sophisticated algorithms that provide unerring analytics . Go ahead , find the hardest problem , we can help solve it . <p> Bring powerful visuals and interactivity to your application with Visualization . This set of cross-platform C++ , Java , and Adobe Flex tools allow you to upgrade your user interfaces to better model , analyze , and communicate complex business information to your users : <p> The power of open source web development has never been greater than with the @ @ @ @ @ @ @ @ @ @ provides reusable components to access popular web services along with a high-performance MVC implementation , an easy-to-use database abstraction , and many HTML5 form-based operations to drastically reduce development times and improve reliability . <p> Built upon a thoroughly-tested foundation , this framework is designed to be loosely coupled , allowing developers to use and extend exactly the components they want . That 's because Zend Framework is much more than code , its also a collaboration between industry partners , such as Google , Microsoft , and StrikeIron , and community contributors numbering in the hundreds of thousands . Community built and designed for reuse , Zend Framework accelerates your PHP web application development . 
@@75678021 @4378021/ <h> 2.3 Key Abstractions <p> The Essential Networking Module contains classes that encapsulate basic networking and C++ concepts . To understand how all the classes are used together , however , you need only two key abstractions : portals and sockets . <p> A portal is a kind of network access point , invented by Rogue Wave , that is not specific to a particular network protocol . In traditional network programming , a socket is specific to a particular network technology . In the Essential Networking Module , portals represent a higher-level abstraction than sockets because they transcend any particular networking technology . In this sense , the concept of a protocol-independent portal is unique to Rogue Wave ; you wo n't find it in traditional network programming manuals . <p> Class RWPortal of the Essential Networking Module is an encapsulation of the portal concept . Its derived class RWSocketPortal is the first class you encounter when making a connection to a network . <p> When you use the Essential Networking Module , you are usually either connecting to a remote server as a client , or waiting @ @ @ @ @ @ @ @ @ @ . For either task , you use RWSocketPortal . We already used RWSocketPortal when connecting to a remote server in Section 2.2.1 , " A Simple Code Example . " Here 's another example : <p> RWSocketPortal sp ( RWInetAddr ( 80 , " www.roguewave.com " ) ) ; //1 <p> In //1 , we create a connection to www.roguewave.com , port 80 , using class RWSocketPortal . Notice that we initialize the RWSocketPortal with an RWInetAddr object . RWInetAddr encapsulates an Internet address and can be constructed using a port and a host , as shown here . <p> Once we have created the connection using RWSocketPortal , it can work with the familiar C++ iostreams to send and receive data . Let 's continue the example : <p> On //2 and //3 , we use RWPortalIStream and RWPortalOStream to give us a high-level iostream interface to our network connection . These classes derive from istream and ostream , respectively , and can be used anywhere a standard iostream is used . <p> On //4 , we write our HTTP request . Finally , in the while loop beginning @ @ @ @ @ @ @ @ @ @ using RWCString : : readLine() , a member function that reads a line from the given stream into the RWCString , and echo it to cout . That 's all there is to it . Of course , we could write an even simpler version of this program by using the prebuilt HTTP classes in the Internet Protocols Module , but this example shows how easy it is to use classes of the Essential Networking Module alone . For more information on transferring data using streams , see Chapter 5 , " Streams . " <p> As we have mentioned , class RWPortal is an encapsulation of the portal concept , a high-level abstraction used in network programming with Rogue Wave products . Class RWPortal is a base for classes such as RWSocketPortal , RWBufferedRecvPortal and RWBufferedSendPortal , and is used for writing code that sends or receives data over a network connection without regard for a particular networking transport protocol or technology . For example , consider the following function : <p> Because of the way this code is written , it could be used to service clients of @ @ @ @ @ @ @ @ @ @ in implementing the server . Of course , a transport protocol must be chosen at some point , but that does n't mean all networking code must be implemented in a way that is specific to that protocol . By keeping transport protocol details out of the code as much as possible , we increase our chances for code reuse . <p> A second important concept of the Essential Networking Module is the socket . Rogue Wave uses the traditional definition of a socket as an endpoint for communication with another application . When you establish a network connection with a socket , you create a channel for data transmission between your socket and a socket in use by the application to which you 're connecting . The sockets are used for sending and receiving data , and they are closed when either side wants to stop communicating . The Berkeley sockets API is a standard C API for network programming that is available on all popular operating systems . <p> In the Essential Networking Module , class RWSocket provides low-level socket functionality for TCP/IP . Internally , class RWSocket @ @ @ @ @ @ @ @ @ @ by the operating system . You will use RWSocket member functions directly for those times when you want to work with low-level details of your network connection , and you do n't need a higher-level interface . Here 's an example : <p> On //1 , we create an RWSocket using its default constructor . On //2 , we connect the socket to www.roguewave.com , port 80 . On //3 , we use the function sendAtLeast() to send a string to the remote host , and on //4 , we shut down the writing side of the socket . <p> This code example illustrates a perfectly legitimate use of RWSocket appropriate to development requiring low-level control . Since such direct use can be difficult , however , the class is actually more commonly used in conjunction with the higher-level portal abstraction . Class RWSocketPortal multiply inherits from both RWPortal and RWSocket . For this reason , it can provide both the easy-to-use RWPortal interface and the RWSocket flexibility to freely mix high-level portal usage with lower-level socket calls . For example : <p> On //1 , RWPortalOStream is used to @ @ @ @ @ @ @ @ @ @ portal interface . However , on //2 we use the lower-level getpeername() method , inherited from RWSocket , to obtain the name of the host to which the RWSocketPortal is connected . <p> This is a very typical use of RWSocket . You will probably avoid using RWSocket members directly for most tasks since you can perform them through the higher-level APIs provided in the rest of the product . If you need to work directly with the low-level details of a network connection , however , you 'll use RWSocket directly . RWSocket is discussed in more detail in Chapter 6 , " Socket Addresses . " <p> Class RWSocketListener is another commonly used class of the Essential Networking Module . This class makes it easy to create server applications by encapsulating the work needed to listen for and accept incoming connections . An RWSocketListener creates a listening socket , which can wait for incoming connections . Its overloaded operator() waits for a connection and returns it as a new RWSocketPortal . To use RWSocketListener , just create one with the port you 'd like to listen on as @ @ @ @ @ @ @ @ @ @ RWSocketListener , telling it to listen for new connections on port 1234 . This sets up a queue for incoming connections , but does not cause the program to wait for a new connection . On //2 we wait for the new connection by invoking the listener as if it were a function , made syntactically possible by the RWSocketListener overloaded operator() . <p> Once a client connects to our port 1234 , an RWSocketPortal connected to the new client is returned on //2 . On //3 , the client is serviced in our imaginary serviceClient() function that we created in Section 2.3.1.2 , " RWPortal as a Base . " In a real server , serviceClient() might hand the new connection to a separate thread to be serviced . Since local objects declared inside a while loop are destroyed and recreated on each loop iteration , the connection to each client is automatically closed . 
@@75678022 @4378022/ <h> 4.4 Calculating the Determinant , Inverse , and Condition Number <p> Factorizations are useful for many calculations besides solutions to systems of equations . The Linear Algebra Module factorization classes include member functions for calculating the determinant , condition number , and inverse of a matrix . <p> Matrix inverses are often used in describing matrix algorithms . However , in practice , it is almost never necessary to calculate the inverse of a matrix explicitly . In almost every case , the problem can be solved much more efficiently by using a factorization . Nevertheless , for those rare occasions when you actually need the explicit inverse , a function is provided for its calculation . For example , to find the inverse of a double precision symmetric matrix whose factorization is the variable fact of type RWSymFact&lt;double&gt; , you use : <p> The condition number of a matrix describes how sensitive it is to errors in the right-side vector when solving systems of equations . The factorization classes can calculate an estimate of the reciprocal condition number . When this number is near 1 , the @ @ @ @ @ @ @ @ @ @ condition number is near 0 , the matrix is ill-conditioned . The solutions obtained for ill-conditioned matrices may not be very accurate . Consult a linear algebra text for more information on conditioning . You compute the condition number like this : <p> double rcond = condition(fact) ; <p> To compute the condition , the factorization class must do a little extra work while constructing the factorization ; it must compute the norm of the system matrix . If you know that you will not need the condition number , you can save some computation by using the optional bool parameter on the factorization constructor . See the Linear Algebra Module Reference Guide for details . 
@@75678023 @4378023/ <h> Constructor &amp; Destructor Documentation <p> Initializes a new instance of the IlvTreeGadgetItem class . This constructor allows you to specify both a label and a bitmap , as well as their relative alignment and spacing . The bitmap is locked . 50234 @qwx670234 <p> label <p> The item label . <p> bitmap <p> The item sensitive bitmap . <p> position <p> The label position relative to the picture . <p> spacing <p> The spacing between the label and the picture . <p> copy <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvTreeGadgetItem . <p> Initializes a new instance of the IlvTreeGadgetItem class . This constructor allows you to specify both a label and a graphic , as well as their relative alignment and spacing . 50234 @qwx670234 <p> label <p> The item label . <p> graphic <p> The item picture . <p> position <p> The label position relative to the picture . <p> spacing <p> @ @ @ @ @ @ @ @ @ @ copy <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvTreeGadgetItem . <p> Computes the size of the item using the member function IlvGadgetItem : : computeRects , which specifies the location of the label and picture parts . If you want to change the item size , you can override this member function in a subclass . <p> The bitmap mask let 's you know which bitmap indexes the item is handling . If the ith bit of the return value is set , it means that the item uses the bitmap of index i . You can get the associated symbol using the static member function GetItemBitmapSymbol . <p> IlTrue if the number of children of the tree gadget item is not known . In this case , the tree gadget item behaves as if it had children even when it does not have any . This means that you can expand it . This feature is @ @ @ @ @ @ @ @ @ @ only if necessary , that is , when the user tries accessing these items by expanding their parent . <p> Reads an object description from the file input . It reads the information that was saved by the member function write to be able to create a new instance of this object . Usually , because of the availability of the constructor that expects an IlvInputFile , readItem should be equivalent to : <p> Runs the sorting algorithm on all the children of this item . If you provide a sorting function in the form of an **32;11284;TOOLONG , this function is called to compare each item pair . If you do not provide a sorting function , a default comparison function is used that sort items in the ascendant order using their labels . 
@@75678024 @4378024/ <h> class CGXTabWnd : public CWnd <p> The CGXTabWnd classprovides the functionality to simply switch between several views in a frame window . The CGXTabWnd class displays a tab-beam control on the bottom-left side of the frame window . The functionality of the CGXTabWnd class is like the functionality of a workbook in MS Excel . <p> CGXTabWnd canbe used either in a document frame window ( CFrameWnd ) or in a dialog template . <p> CGXTabWnd is mainly based on the code of the CSplitterWnd class . Embedding a CGXTabWnd window in a frame window is similar to embedding a splitter window in a frame window . <p> Using CGXTabWnd is simple . <h> 1 . Embedding a CGXTabWnd window in a document frame window <p> If you want to use the workbook window in an MDI frame window , you must derive a class from CMDIChildWnd . You have to embed a CGXTabWnd object in the derived class . Furthermore , you have to override OnCreateClient . In OnCreateClient , you must initialize the CGXTabWnd object and create the views . <p> In your view class , @ @ @ @ @ @ @ @ @ @ belong to your view class . They are child windows of the CGXTabWnd window . You have to override GetScrollBarCtrl in your view class and return a pointer to the corresponding scrollbar object . The sample program contains the necessary source code for this method . <p> If you want to know whether your view is being activated or deactivated , you can override OnActivateView. <h> 2 . Embedding a CGXTabWnd window in a dialog template <p> The class can be used directly in Visual Studio as user control . <p> In InitInstance you have to register the window class of the CGXTabWnd window by calling RegisterClass . In ExitInstance , you have to unregister the window class by calling UnregisterClass . <p> In Visual Studio , you can drag the user control icon into the dialog template . Next , you have to set the user control properties : any I 'd , Class : CGXTabWnd , Style : 0x50810000 . <p> In your dialog class , you have to insert a function to get a pointer to the CGXTabWnd object . <h> 3 . User defined messages sent to @ @ @ @ @ @ @ @ @ @ the associated sheets : <p> WMGXINITTAB is sent from AttachWnd with the zero-based index of the tab in wParam to the associated sheet . This message is sent after inserting a register into the tab-beam control . The sheet can change the name or the tab width , or can do any other operations . The WMGXINITTAB message is not sent to views . Views can be initialized in OnInitialUpdate . <p> WMGXNEEDCHANGETAB is sent with the zero-based index of the currently selected tab in wParam to the associated sheet , when the user has double-clicked on tab . If you want to prevent editing the sheet name , you have to return FALSE . If you return TRUE , editing the sheet name is possible . <p> WMGXCHANGEDTAB is sent with the zero-based index of the currently selected tab in wParam to the associated sheet , when the user has changed a tab name . The message is sent after changing the tab name . The purpose of the message is to allow the view to update the sheet name in the document and notify other views of the @ @ @ @ @ @ @ @ @ @ unique I 'd . The first window obtains the I 'd AFXIDWPANEFIRST . Subsequent windows get continuous IDs ( max. 256 ) . The scrollbars have the IDs AFXIDWHSCROLLFIRST and AFXIDWVSCROLLFIRST . <p> If you need access to tab information , such as name and width , you can use the GetBeam method . By calling GetBeam().FindTab(pWnd) , you can look up the zero-based tab index for an embedded view . <p> #include &lt;gxall.h&gt; <h> Example <p> In your view class , you have to consider that the scroll bars do not belong to your view class . They are child windows of the CGXTabWnd window . You have to override GetScrollBarCtrl in your view class and return a pointer to the corresponding scrollbar object . 
@@75678027 @4378027/ <h> TotalView for HPC <p> Understand high-scale parallel and multicore applications , with unprecedented control over processes and thread execution and visibility into program states and data . <p> With TotalView for HPC , simultaneous debug many processes and threads in a single window to get complete control over program execution : Running , stepping , and halting line-by-line through code within a single thread or arbitrary groups of processes or threads . Work backwards from failure through reverse debugging , isolating the root cause faster by eliminating repeated restarts of the application . Reproduce difficult problems that occur in concurrent programs that use threads , OpenMP , MPI , GPUs , or coprocessors . <p> Memory leaks , deadlocks , and race conditions can be things of the past . Whether an experienced developer or new to the development challenges of multicore or parallel applications , TotalView finds errors quickly , validates prototypes , verifies calculations , and certifies code correctness . 
@@75678028 @4378028/ <p> " One of our simulations was about 1.5 million lines of code ... The ability to port the code , and to watch and test on two different platforms side-by-side in real-time using TotalView cut development time by 60-70% ; we would n't have been able to achieve this if we had to use more than one debugging tool . It also save us about 40% in costs because we did n't have to purchase other tools . " <p> Jim Knoblach , CAS , Inc . <p> Modeling and Simulation Department Manager <h> C and C++ debugging and troubleshooting <p> C and C++ give you control over the details of data , access patterns , memory management , and execution . But direct control over low level machine behavior leaves little margin for error when it comes to building and maintaining scalable scientific applications . TotalView provides the ideal environment for troubleshooting complex C and C++ applications . They feature detailed views of objects , data structures , and pointers , simplifying working with complex objects . <p> The standard template library ( STL ) collection classes @ @ @ @ @ @ @ @ @ @ but they complicate troubleshooting when your program hangs or crashes . TotalView type transformation facility ( TTF ) provides a flexible way for you to provide alternate displays for data objects . STLView transformations provide a logical view of STL collection class objects , providing a more practical view of list data . The end result is a simplified , intuitive view into the structure and behavior of your code . <h> Fortran debugging <p> While there are some things that both C and Fortran have in common , Fortran is not C. TotalView correctly represents Fortran notation , types , and concepts , such as common blocks and modules , that are not present in other languages . <p> Fortran is especially good at representing and manipulating numerical and mathematical data . One of its key characteristics is its facility for representing array data . Scientists and engineers working with Fortran source code are doing so in part to take advantage of language-level support for things like multidimensional arrays , array assignment , and the powerful features of Fortran pointers . Our technology can help you leverage these key @ @ @ @ @ @ @ @ @ @ of the applications you are developing are engines for manipulating data . Whether observational or computational , it is the data that you really care about . When you are trying to develop insight into the behavior of a physical system you approach it quantitatively . The same approach is necessary when trying to understand the behavior of computational systems . <p> Troubleshooting involves exploring the behavior of a live application , looking for clues as to why the computation is not proceeding as expected , slicing the data presented in different ways to uncover patterns . It is critical that you have the tools that make it easy to view and manipulate that data , and TotalView helps streamline this process . <h> Debugging memory leaks and malloc errors <p> The fact that memory is a limited resource has a significant impact on the implementation of your application , especially when it contains millions of lines of code . As program complexity grows , memory leak debugging and troubleshooting malloc errors become more difficult . Memory-related code defects can cause out-of-control resource and random data corruption . Memory errors @ @ @ @ @ @ @ @ @ @ impacting productivity . In a worst-case scenario , memory errors can result in corrupted data causing programs to generate inaccurate results . TotalView helps you manage that risk by ensuring working code and accurate results . <h> Support for MPI , OpenMP , and other parallel paradigms <p> TotalView provides comprehensive support for MPI , OpenMP , UPC , and GA . With support for more than 20 implementations of MPI , TotalView has been the debugger of choice in parallel programming courses . <h> Multithreaded applications / multicore architectures <p> The era of increasing clock rates has ended . Processor architectures are characterized by multicore and many-core designs . Building a multithreaded application or transitioning from a serial application to a parallel application presents significant challenges . TotalView and ReplayEngine are natively built to help you manage the challenges presented by concurrency , parallelism , and threads . <p> Race conditions are a common problem , even in a well tested multithreaded application . You can use locks , semaphores , and atomic operations to avoid race conditions , but they can introduce subtle problems of their own . @ @ @ @ @ @ @ @ @ @ , increasing your understanding of the impact of these problems . <h> TVScript <p> TVScript is a framework for non-interactive debugging with TotalView . You define a series of events that may occur within the target program , TVScript loads the program under its control , sets breakpoints as necessary , and runs the program . At each program stop , TVScript gathers data which is logged to a set of output files for your review when the job has completed . If you call TVScript with no arguments , it provides usage guidelines and a listing of available events and actions . TVScript has been likened to printf on steroids . 
@@75678032 @4378032/ <h> 8.2 Functor Class Hierarchy <p> The Functor package consists of a sizable family of template classes designed to accommodate global , static , and member function calls with varying numbers of arguments , as shown in Figure 50 and Figure . Like many other Threads.h++ packages , the Functor package uses the handle-body idiom . In the hierarchies , the handle classes are on the left and the matching sets of body classes are on the right . <p> The base name for functor classes is RWTFunctor , for templatized classes , or RWFunctor , for the few non-templatized classes . Body class names end in Imp . Both handle and body class names are constructed by adding characters that encode information about the functor to the base name . These codes will make more sense as you go through the rest of the chapter . <p> An optional character R that indicates whether or not the functor returns a value . <p> A digit indicating the number of caller arguments the functor accepts : 1 or 2 . <p> Body class names also include additional characters that @ @ @ @ @ @ @ @ @ @ arguments accepted by the function . This sequence consists of the following elements : <p> A single letter indicating the function type : <p> G - The function is a global function or a static member function , which has no callee object . <p> M - The function is a non-static member function . <p> An optional two-letter code describing the number of callee arguments that the functor will store and automatically pass to the function ( in addition to the caller arguments ) : <p> A1 - One callee argument . <p> A2 - Two callee arguments . <p> A3 - Three callee arguments . Only functors with no caller arguments can take three callee arguments . 
@@75678033 @4378033/ <p> The easiest way to create a thread with Threads.h++ is to begin with rwtMakeThreadIOUFunction . By supplying a global or member function pointer , you control what your thread will do after starting . If you wish your thread to start by calling a function that takes arguments , rwtMakeThreadIOUFunction allows you to specify the values that should be passed to that function . Note that threads created with rwtMakeThreadIOUFunction allow you to extract the return value from the associated function . This distinguishes them from those created by rwtMakeThreadFunction , which do not . <p> rwtMakeThreadIOUFunction comes in two flavors . First , there is a set of overloaded global function templates . Since not all compilers are able to handle templates to the degree required by these functions , we also provide a corresponding set of macros . The template functions are slightly easier to use and you only have to remember one name . The macros are more portable but they do require more arguments ; and as we can not overload macros , each must have a unique name . <p> In naming the @ @ @ @ @ @ @ @ @ @ easier to remember . Each name begins with rwtMakeThreadIOUFunction , which will be followed by either a G if the macro is expecting a global function , or an M if it is expecting a member function . At that point the name is complete if the associated global or member function takes no arguments . Otherwise we add one of A1 , A2 , or A3 for functions with 1 , 2 , or 3 arguments respectively . For example , you will use macro **25;11318;TOOLONG to create a thread that calls a global function that takes no arguments . The macro **27;11345;TOOLONG will create a thread that calls a member function that takes two arguments . 
@@75678035 @4378035/ <p> Automatically identifies time series outliers , determines parameters of a multiplicative seasonal ARIMA ( p , 0 , q ) x ( 0 , d , 0 ) s model and produces forecasts that incorporate the effects of outliers whose effects persist beyond the end of the series . <p> AUTOFPEUNIAR <p> Automatic selection and fitting of a univariate autoregressive time series model using Akaike 's Final Prediction Error ( FPE ) criteria . <p> AUTOPARM <p> Estimates structural breaks in non-stationary univariate time series . <p> AUTOMULAR <p> Automatic selection and fitting of a multivariate autoregressive time series model . <p> AUTOFPEMULAR <p> Automatic selection and fitting of a multivariate autoregressive time series model using Akaike 's Multivariate Final Prediction Error ( MFPE ) criteria . <h> BAYESIAN TIME SERIES ESTIMATION <p> ROUTINE <p> DESCRIPTION <p> BAYSEA <p> Bayesian seasonal adjustment modeling . The model allows for a decomposition of a time series into trend , seasonal , and an error component . <h> CONTROLLER DESIGN <p> ROUTINE <p> DESCRIPTION <p> OPTDES <p> Optimal controller design which allows for multiple channels for both the controlled and manipulated @ @ @ @ @ @ @ @ @ @ <p> Performs lack-of-fit test for a univariate time series or transfer function given the appropriate correlation function . <h> CONTROLLER DESIGN <p> ROUTINE <p> DESCRIPTION <p> OPTDES <p> Optimal controller design which allows for multiple channels for both the controlled and manipulated variables . 
@@75678036 @4378036/ <p> The class istreamiterator reads elements from an input stream ( using operator &gt;&gt; ) . A value of type T is retrieved and stored when the iterator is constructed and each time operator++ is called . The iterator will be equal to the end-of-stream iterator value if the end-of-file is reached . Use the constructor with no arguments to create an end-of-stream iterator . The only valid use of this iterator is to compare to other iterators when checking for end of file . Do not attempt to dereference the end-of-stream iterator ; it plays the same role as the past-the-end iterator provided by the end() function of containers . Since an istreamiterator is an input iterator , you can not assign to the value returned by dereferencing the iterator . This also means that istreamiterators can only be used for single pass algorithms . <p> Since a new value is read every time the operator++ is used on an istreamiterator , that operation is not equality-preserving . This means that i == j does not mean that ++i == ++j ( although two end-of-stream iterators are always equal ) . 
@@75678037 @4378037/ <h> 6.3 Vertical Bar Graphs <p> The Vertical Bar axis types are used to plot data values as bars which extend vertically . The bars for the data objects in a group are spaced evenly across the horizontal axis . <p> CXAXISCLASSIC displays a numeric y-axis to the left of the graph . <p> CXAXISCLASSICRIGHT displays a numeric axis to the right . <p> CXAXISDATE and CXAXISDATER are used when the data values are dates or times . <p> The isographic **27;11374;TOOLONG , CXAXISISOCLASSICR , CXAXISISODATE , and CXAXISISODATERadd a pseudo three-dimensional look to the axes and bars . <p> The data axis ( Y ) is defined by an SRGDecimalScale object or SRGLogScale for logarithmic scaling or SRGDateScale for date/time values . The other axis ( X ) is defined by SRGIndexScale . The annotations from the data items ( indices ) in group 0 are used to label the axis . <p> The methods described above for changing the scaling and appearance of Classic axes also apply here . <p> In a Vertical Bar graph , the data values are indicated by the vertical extent of individual @ @ @ @ @ @ @ @ @ @ the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , the style of the first group is used ( SRGraphDataList object ) . <p> The bars ' appearance is determined by the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , the style of the first group is used ( SRGraphDataList object ) . <p> In a Stacked Vertical Bar graph , the bars for different groups are displayed one behind another , rather than side-by-side . The values from the different groups are not summed . The Strata Vertical Bar graph is what some users expect for a stacked bar graph . <p> The bars ' appearance is determined by the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , the style of the first group is used ( SRGraphDataList object ) . <p> A Strata Vertical Bar @ @ @ @ @ @ @ @ @ @ . It shows the summed total of a particular index over all groups . The length of the combined bar represents the total over all groups . Areas within the bar show how much each group contributes to the total . For example , a strata bar chart could be used to show the market share of individual car manufacturers ( groups ) over several years ( indices ) . <p> Because negative values can not be represented , a standard bar chart is drawn if the data contain negative values . <p> The bars ' appearance is determined by the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , the style of the first group is used ( SRGraphDataList object ) . <p> This graph style reverses the roles of groups and indices from those of the previous style . A bar is drawn for each group , with segments showing the contributions of each index . <p> The bars ' appearance is determined by the settings in the style member of @ @ @ @ @ @ @ @ @ @ styles of a data item are set to NONE , then the global style of this display component is used . <p> 100% Strata Vertical Bar graphs are similar to Strata bar graphs , except all the combined bars have the same height . Like a Pie graph , the relative importance of the contributing factors is displayed . These graphs highlight the variation of these contributions with time or place . In this style , a bar is drawn for each index with segments showing each group 's relative contributions . <p> Because negative values can not be represented , a standard bar chart is drawn if the data contain negative values . <p> The bars ' appearance is determined by the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , the style of the first group is used ( SRGraphDataList object ) . <p> This graph style reverses the roles of groups and indices from those of the previous style . A bar is drawn for each group with segments showing @ @ @ @ @ @ @ @ @ @ ' appearance is determined by the settings in the style member of the individual data items . If the interior and frame styles of a data item are set to NONE , then the global style of this display component is used . 50236 @qwx670236 
@@75678038 @4378038/ <h> IMSL Numerical Libraries <h> Battle-tested algorithms from prototype to production <p> Analyzing data has never been more important or harder . Getting actionable information from your large and disparate datasets can often determine if your organization meets its goals . Create competitive differentiation and unlock innovation by using the most trusted , tested , and reliable algorithms available . Backed by a team of mathematicians and statisticians , IMSL Numerical Libraries allow you to address complex problems quickly with a variety of readily-available algorithms . With IMSL you get consistency from prototype to production . <h> Embeddable mathematical and statistical functionality <p> IMSL Libraries save development time by providing optimized mathematical and statistical algorithms that can be embedded into C , C++ , . NET , Java , and Fortran applications , including many databases . IMSL enhances application performance , reliability , portability , scalability , and maintainability as well as developer productivity . IMSL Libraries are supported across a wide range of languages as well as hardware and operating system environments including Windows , Linux , Apple , and many UNIX platforms . <p> " IMSL @ @ @ @ @ @ @ @ @ @ available , support major computing platforms , and were easily embeddable into the GlyphWorks solution . " 
@@75678039 @4378039/ <p> Shifts an existing point to another location by means of a vector . You indicate the x and y translation values that represent the distance between the current position of the point and the target future position . <p> Shifts an existing point to another location by means of a vector . You indicate the x and y translation values that represent the distance between the current position of the point and the target future position . 
@@75678040 @4378040/ <h> 2.8 Stored Procedures <p> Stored procedures are encapsulated by the class RWDBStoredProc . The implementation of stored procedures by the DBTools.h++ access library for Informix is subject to many restrictions . These restrictions are due to a combination of factors dictated by the Informix SQL grammar and the capabilities of the Informix ODBC Driver : <p> The DBTools.h++ access library for Informix implements only a subset of the RWDBStoredProc functionality declared in the DBTools.h++ core . In particular , Informix stored procedures does not support output or input/output parameters ; instead , parameters are returned as a set of results . See Section 2.8.2 below . <p> Return values from stored procedures are not supported . The function RWDBStoredProc : : returnValue() returns a NULLRWDBValue . <p> RWDBStoredProc : : operator ( const RWCString&amp; paramName ) is not available , since this information is not stored in the Informix system tables . <p> Use the createProcedure method of RWDBDatabase to create a stored procedure . DBTools.h++ creates the parameter list from a schema you supply . You must supply the text of the stored procedure . Here is @ @ @ @ @ @ @ @ @ @ DBTools.h++ : <p> An Informix stored procedure returns zero or more rows of values . If you execute a stored procedure that does not return any values , it is executed immediately when your application calls RWDBStoredProc : : execute() . <p> Here is an example of executing a stored procedure that does not return values : <p> If you execute a stored procedure that does return rows , you must first fetch a row . This can be done by obtaining a reader from the execute method . The first time a row is fetched , the procedure is actually executed in the database . <p> increases the performance of stored procedures by eliminating the usual parameter fetch required for instantiation . The schema must include the RWDBColumn : : ParamType of each parameter in the stored procedure . For example , the code in Section 2.8.1 uses the schema params to create the stored procedure ; params could be used to instantiate an RWDBStoredProc. 
@@75678041 @4378041/ <p> Like RWDBReader , RWDBBulkReader is a class designed to read result sets associated with an RWDBTable or RWDBSelector . The main difference between RWDBBulkReader and RWDBReader is that arrays of values are shifted into the RWDBBulkReader for each column in the result set , while scalar values are shifted out of the RWDBReader . These arrays are passed by reference and need to stay in scope for the duration of the reader . The classes RWDBVector&lt;T&gt; , RWDBDateVector , RWDBStringVector , and RWDBBinaryVector are used for reading simple numeric types , dates , strings , and binary data , respectively . <p> RWDBBulkReader is designed around the Interface/Implementation paradigm . An RWDBBulkReader instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBBulkReader implementation is a base class from which a family of database-specific implementations is derived . <p> Default constructor . Creates an RWDBBulkReader whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience ; for example , for declaring an array of RWDBBulkReaders . Usable RWDBBulkReaders are obtained @ @ @ @ @ @ @ @ @ @ ) ; <p> Copy constructor . The created RWDBBulkReader shares an implementation with rdr . <p> Changes the current row position to index . If index is out of range , self 's status is set to RWDBStatus : : invalidPosition . Returns a reference to self . <p> RWDBBulkReader &amp; operator&lt;&lt; ( RWDBAbstractBuffer&amp; val ) ; <p> Shifts in the val to be associated with the column at the current position . Increments the current position . Returns a reference to self . <p> Before DBTools.h++4.0 , this operator&lt;&lt; took RWDBVector , which is now a derived class of RWDBAbstractBuffer . Code written with RWDBVector should require no changes . <p> RWDBBulkReader &amp; operator&lt;&lt; ( RWDBDateVector&amp; dateVector ) ; <p> Shifts in the dateVector to be associated with the column at the current position . Increments the current position . Returns a reference to self . <p> sizet operator() ( ) ; <p> Fetches into the arrays shifted into self , the next set of rows from the result set associated with self . Up to n rows are fetched at a time , where n is equal to @ @ @ @ @ @ @ @ @ @ Returns the number of rows actually fetched . A return value of 0 indicates that there is no additional data to fetch . <p> Cancels any pending results associated with self . Subsequent calls to RWDBBulkReader : : operator() ( ) iterate over a fresh result set based on the current values of the set of bound variables associated with the selector that produced self . 
@@75678042 @4378042/ <h> 3.6 Data Structures <p> Objective Grid maintains grid properties and attributes in separate classes . This allows several grid views to share the same data . Objective Grid provides several pre-built dialogs that allow the end user to modify properties . <p> CGXGridParam contains shared attributes such as the row heights , the cell contents , the styles map , the printer settings and the selected ranges . By default , an instance of CGXGridParam is created in CGXGridCore : : OnGridInitialUpdate() , but can also be embedded in the document and linked to the grid . <p> The CGXData class maintains the cell contents of the grid and the row and column base styles . The grid component creates an instance of this class in CGXGridCore : : OnGridInitialUpdate() and attaches it to the parameter object . <p> The CGXProperties class maintains the display and print properties of a grid , such as margins , header/footer and colors of grid lines . Objective Grid offers some pre-built dialog classes that allow the end user to modify these settings at run time . All settings except the header/footer @ @ @ @ @ @ @ @ @ @ . <p> The CGXCommand class is an abstract base class for storing Undo information for commands . If you want to support Undo/Redo for your commands , you should derive a class from CGXCommand and store all information necessary for undoing the operation into the command object . A detailed discussion of this process is included in the Programmer 's Guide section of this manual . <p> CGXControlFactory is the default implementation of the Objective Grid control factory . CGXControlFactory registers all cell types , user attributes and window classes provided by Objective Grid and will force them to be linked in your application . <p> A CGXGridDropTarget object provides the communication mechanism between a grid and the OLE libraries . Creating an object of this class allows a window to accept data through the OLE drag-and-drop mechanism . <p> These classes provide dialogs that allow the end user to change the settings maintained by the CGXProperties class . All dialogs provide an option that allows the user to save/load the settings using the registry/profile . <p> CGXRange objects define a rectangular range of cells in the grid . A @ @ @ @ @ @ @ @ @ @ a left and right columns . Ranges can represent a selection of cells , columns , rows or all cells . 50236 @qwx670236 
@@75678043 @4378043/ <p> As part of its pattern matching capability , the Tools.h++ Class Library supports regular expression searches . See the Class Reference , under RWCRegexp , for details of the regular expression syntax . You can use a regular expression to return a substring ; for example , here 's how you might match all Windows messages ( prefix WM ) : <p> The function call operator for RWCString has been overloaded to take an argument of type RWCRegexp . It returns an RWCSubString matching the expression , or the null substring if there is no such expression . <p> This version of the Tools.h++ class library supports extended regular expression searches based on the POSIX.2 standard . ( See the Bibliography . ) Extended regular expressions are the regular expressions used in the UNIX utilities lex and awk . You will find details of the regular expression syntax in the Class Reference under RWCRExpr . <p> Note : RWCRExpr is available only if your compiler supports exception handling and the C++ Standard Library . <p> Extended regular expressions can be any length , although limited by available memory @ @ @ @ @ @ @ @ @ @ the symbol to create either/or regular expressions for pattern matching . <p> The following example shows some of the capabilities of extended regular expressions : <p> Note that the function call operator for RWCString has been overloaded to take an argument of type RWCRExpr . It returns an RWCSubString matching the expression , or the null substring if there is no such expression . 
@@75678044 @4378044/ <h> 4.6 Compiling in Windows with MSVC <p> Before starting , be sure that the Microsoft environment variables PATH , INCLUDE , and LIB are set to the proper search path for the Microsoft compiler , the system #include header files , and the libraries , respectively . <p> Let 's say that we have a file named myapp.cpp and that we are compiling it in a Windows NT MS-DOS command prompt . Let 's also say that our LAPACK.h++ header files are located in c : **28;11403;TOOLONG , and that we built static , single-threaded , no debug versions of LAPACK.h++ , Math.h++ and Tools.h++ named , respectively , lpk0s.lib , mth0s.lib and tls0s.lib . Then we can compile myapp.cpp with the Microsoft C++ compiler with the following command ( all on one line ) : <p> The entire command line must be typed without carriage returns . Your operating system might have a line length limit . If your command line gets too long , use a response file . <p> This command will compile and link in one step . <p> The -I option tells the @ @ @ @ @ @ @ @ @ @ <p> The LONG ... path and the other lib paths are the full path names for no standard library , no debugging , static LAPACK.h++ , FORTRAN , BLA , Math.h++ , and Tools.h++ libraries for Microsoft C++ . ( Substitute as appropriate . ) <p> The user32.lib is the library for message-boxes and other widgets . <p> NOTE : Even if you are compiling a LAPACK.h++ Windows NT or Windows 95 console program , you still need to link in the user32.lib library , because Tools.h++ uses the Windows message box to report errors . <p> Microsoft Visual C++ allows you to create a LAPACK.h++ DLL under Windows 95 and Windows NT . <p> To use the 32-bit DLL version of LAPACK.h++ , you must : <p> Use the Microsoft runtime DLL . <p> Use the DLL version of Tools.h++ . <p> Define the macros RWLAPACK , RWLAPACKDLL , RWMATHDLL , RWTOOLSDLL , and RTLDLL on the compiler command line . This tells the header files to configure for dynamic linking . If LAPACK.h++ is also using the Standard C++ Library , you must also define RWSTDDLL . See @ @ @ @ @ @ @ @ @ @ the Standard C++ Library with Tools.h++ . <p> In addition , you must defined the macros RWMULTITHREAD , and REENTRANT when using a multithreaded version of the library . <p> Use the -MD or -MDd option on the compiler command line in order to use the release or debug version , respectively , of the Microsoft runtime library DLL . <p> You must link your program with the Math.h++ , Tools.h++ and LAPACK.h++ import libraries . Example names of the import libraries are : <p> Release Version ( no symbolic debugging or assertions ) : <p> LAPACK.h++ : lpk4d.lib , laf4d.lib , and bla4d.lib <p> Math.h++ : mth4d.lib <p> Tools.h++ : tls4d.lib <p> Standard C++ Library : std11d.lib . In addition , if you 're building with the Standard C++ Library , you must replace 4d in the build types above with 11d . <p> Microsoft runtime library : msvcrt.lib <p> Debug Version ( with symbolic debugging and assertions ) : <p> LAPACK.h++ : lpk7d.lib , laf7d.lib , and bla7d.lib <p> Math.h++ : mth7d.lib <p> Tools.h++ : tls7d.lib <p> Standard C++ Library : std15d.lib . In addition , if you @ @ @ @ @ @ @ @ @ @ replace 7d in the build types above with 15d . <p> Microsoft runtime library : msvcrtd.lib <p> The LAPACK.h++ DLL is lpk&lt;build#&gt;d.dll . See Section 2.4 for information on build numbers . Check the Tools.h++ Build Guide or Standard C++ Library Build Guide for the name of the DLL file . <p> When you run your program , the LAPACK.h++ , Math.h++ , Tools.h++ , Standard C++ Library , and Microsoft runtime library DLLs must be in one of the following places : <p> the current directory <p> the WINDOWS or WINNT directory <p> the WINDOWSSYSTEM or WINNTSYSTEM32 directory <p> the directory containing the executable file for the current task <p> the directories listed in the PATH environment variable <p> the list of directories mapped in your network search paths <p> If you get exceptions , especially in * . DLLs , and you ca n't figure out where they 're coming from , you may have incompatible * . DLLs running . Check for incompatible.DLLs in your path . <p> To build a program that uses LAPACK.h++ under the Microsoft Visual Studio development environment , you must add the @ @ @ @ @ @ @ @ @ @ your studio configuration . Use the menu selection Tools Options ... to bring up the options dialog . Select the Directories tab , select Include Files from the Show Directories For : drop-down box , and add the necessary include paths . <p> You will also need to define any macros and compiler switches required to use a particular configuration of the LAPACK.h++ , Math.h++ , and Tools.h++ products . <p> See the Microsoft Visual Studio help system for instructions on making changes to a project configuration . 
@@75678045 @4378045/ <p> This is an abstract class that can automate the process of benchmarking a piece of code . To use it , derive a class from RWBench , including a definition for the virtual function doLoop ( unsigned long N ) . This function should perform N operations of the type that you are trying to benchmark . RWBench will call doLoop() over and over again until a preset amount of time has elapsed . It will then sum the total number of operations performed . <p> To run , construct an instance of your derived class and then call go() . Then call report() to get a standard summary . For many compilers , this summary will automatically include the compiler type and memory model . You can call ops() , outerLoops() , etc. for more detail . <p> If you wish to correct for overhead , then provide an idleLoop() function which should do all non-benchmark-related calculations . <p> The parameter duration is the nominal amount of time that the benchmark should take in seconds . The virtual function doLoop ( unsigned long ) will be called @ @ @ @ @ @ @ @ @ @ time has elapsed . The parameter ILO is the number of " inner loop operations " that should be performed . This parameter will be passed in as parameter N to doLoop(N) . Parameter machine is an optional null terminated string that should describe the test environment ( perhaps the hardware the benchmark is being run on ) . <p> A pure virtual function whose actual definition should be supplied by the specializing class . This function will be repeatedly called until a time duration has elapsed . It should perform the operation to be benchmarked N times . See the example . <p> double duration() const ; <p> Return the current setting for the benchmark test duration . This should not be confused with function time() which returns the actual test time . <p> virtual void go() ; <p> Call this function to run the benchmark . <p> virtual void idleLoop ( unsigned long N ) ; <p> This function can help to correct the benchmark for overhead . The default definition merely executes a " for() " loop N times . See the example . <p> const char @ @ @ @ @ @ @ @ @ @ the machine which is passed into the benchmark object through parse() . <p> virtual void parse ( int argc , char* argv ) ; <p> This function allows an easy way to change the test duration , number of inner loops and machine description from the command line : <p> Argument <p> Type <p> Description <p> argv1 <p> double <p> Duration ( sec . ) <p> argv2 <p> unsigned long <p> No. of inner loops <p> argv3 <p> const char* <p> Machine <p> void parse ( const char * ) ; <p> This is a non-virtual function which provides the same service as parse ( int argc , char * argv ) , but is designed for Windows users . It extracts tokens from the null-terminated command argument provided by Windows , then calls the virtual parse for ANSI C command arguments . <p> virtual void report(ostream&amp;) const ; <p> Calling this function provides an easy and convenient way of getting an overall summary of the results of a benchmark . <p> double setDuration ( double t ) ; <p> Change the test duration to time t . <p> unsigned @ @ @ @ @ @ @ @ @ @ the number of " inner loop operations " to N. <p> virtual void what(ostream&amp;) const ; <p> You can supply a specializing version of this virtual function that provides some detail of what is being benchmarked . It is called by report() when generating a standard report . <p> void where(ostream&amp;) const ; <p> This function will print information to the stream about the compiler and memory model that the code was compiled under . <p> unsigned long innerLoops() const ; <p> Returns the current setting for the number of inner loop operations that will be passed into function doLoop ( unsigned long N ) as parameter N. <p> double time() const ; <p> Returns the amount of time the benchmark took , corrected for overhead . <p> unsigned long outerLoops() const ; <p> Returns the number of times the function doLoop() was called . <p> double ops() const ; <p> Returns the total number of inner loop operations that were performed ( the product of the number of times outerLoop() was called times the number of inner loop operations performed per call ) . 
@@75678046 @4378046/ <p> The set declaration macros implement the runtime lookup of environment variables that determine whether a function will generate a trace event . Trace does not work correctly if the set declaration macros are not used or are used improperly . Set declaration macro names all include the word TRACEABLE , to distinguish them from event generation macros . Set declaration macros come in three varieties : package declaration macros , class declaration macros , and function declaration macros . <p> NOTE : A predefined package set named rwuser acts as a default super set for your classes and functions . If this single package set is sufficient for your purposes , you can skip this section . <p> The package declaration macros are used in the implementation of the Execution Tracing package itself . To get a feel for what these macros do , you can check the userdefs.h and userdefs.cpp files in the trace source directories . <p> The macros take one parameter , packageName , to specify the name of the package to be traced . The packageName must be a valid C++ identifier . The @ @ @ @ @ @ @ @ @ @ and the packageName of the DECLARE and DEFINE macros must match . <p> LONG ... <p> Declares a traceable package . This macro is normally placed at the end of the header file that defines the trace macros for that package . For an example , see the trace header file userdefs.h or the pkgdefs.h file for any other package in Threads.h++ . <p> LONG ... <p> Provides a definition for a static variable defined by the matching DECLARE macro ( above ) . This macro must be placed in some implementation file ( . cpp ) for your application . For an example , see the trace source file userdefs.cpp or the pkgdefs.cpp file in any of the other packages in Threads.h++ . <p> The class declaration macros declare classes to be traceable , with the rwuser package as the super set . If you intend to trace any of a class ' functions ( member or static member ) , you must use these macros . Friend functions can either be traced with these macros or traced as global functions . <p> The macros take one parameter , @ @ @ @ @ @ @ @ @ @ be traced . The className must be a valid C++ identifier . The DECLARE and DEFINE macros must be used in pairs , and the className of the DECLARE and DEFINE macros must match . <p> **38;11433;TOOLONG <p> Declares a non-template class as traceable . This macro must be placed in the header file for a class before the class declaration . Otherwise , it generates an undefined symbol compile error . <p> **37;11473;TOOLONG <p> Provides a definition for a static variable defined by the matching DECLARE macro ( above ) . This macro must be placed in the implementation ( . cpp ) file for the class . <p> LONG ... <p> Declares a template class as traceable . Do not include the template parameters in the className . This macro must be placed in the header file for a class before the class declaration . Otherwise , it generates an undefined symbol compile error . <p> LONG ... <p> Provides a definition for a static variable defined by the matching DECLARE macro ( above ) . Do not include the template parameters in the className . This macro @ @ @ @ @ @ @ @ @ @ . cc file ) for the template class . <p> The function declaration macros declare functions to be traceable . In addition , the macros automatically generate ENTRY and EXIT trace events upon entry and exit of the function . Every function that requires tracing must have one of these macros , normally as the first line of the function . Attempting to use more than one function declaration macro in a function results in compile or link errors . <p> The macro families come in sets of four macros , including an INLINE version for inline functions , a TEMPLATE version for template functions , a INLINETEMPLATE version for inline template functions , and a basic version for all other functions . Using the incorrect version results in compile and link errors . <p> Function declaration macros can take these parameters : <p> functionTag is used as the environment variable to control trace event generation for this function . It also appears in the trace output . The functionTag parameter must be a valid C++ identifier , and it must be enclosed in quotation marks , as a string @ @ @ @ @ @ @ @ @ @ ( for a global function ) or a string of the form " ClassNamefunctionName " ( for a member function ) . See Section 6.4.3 , " Function Declaration Macros , " in the Threads.h++ User Guide , for more on assigning tag names . <p> className specifies the name of the class to which the member or friend function belongs . It must match the className used in the **27;11512;TOOLONG macro for the class . <p> Macros for global functions . <p> RWUSERTRACEABLEFUNCTION ( " functionTag " ) <p> LONG ... <p> LONG ... <p> LONG ... <p> This macro family is used in global ( non-member ) functions . The functionTag is usually the name of the function . <p> Macros for member functions . <p> LONG ... <p> LONG ... <p> LONG ... <p> LONG ... <p> This macro family is used in member functions . The functionTag is usually the string " ClassNamefunctionName " . 
@@75678048 @4378048/ <h> Free and Discounted Software for Qualifying Academic Institutions and Students <p> Flexible licensing options are available to students , teachers and researchers at colleges and universities around the world . TotalView debugging software , IMSL Numerical Library and PV-WAVE licenses are available for classroom , project and research use . Academic licensing is not limited to any environment or platform . Licenses are available from a single user license on a desktop to department or site use for the largest supercomputing labs . <p> In many cases , engineering and computer science courses have relied on the use of print statements , GDB and a variety of other open source tools to teach students how to analyze , troubleshoot and debug code . Rogue Wave Software is committed to enhancing the quality of programming instruction by making our industry-standard TotalView tool available to full-time students at no cost . Rogue Wave has recently implemented an IMSL Student Express Edition that will be available to all students pursuing a degree . It will have the same features as TotalView Student Express , however , the license will expire in a year rather than upon graduation. 
@@75678051 @4378051/ <h> Constructor &amp; Destructor Documentation <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvLabelMatrixItem . <p> Reads an object description from the file input . It reads the information that was saved by the member function write to be able to create a new instance of this object . Usually , because of the availability of the constructor that expects an IlvInputFile , readItem should be equivalent to : <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvAbstractMatrixItem. 
@@75678053 @4378053/ <h> 2.8 Stored Procedures <p> The Oracle access library includes support for RWDBStoredProc that is analogous to PL/SQL procedures and functions . ( See the Oracle PL/SQL User 's Guide and Reference , Chapter 6 . ) Procedures and functions are implemented using the OCI call odessp() to get parameter information . SQL statements are made to create procedures and functions , to get their text , and to execute them . <p> Please note that PL/SQL differentiates between stored functions and procedures . PL/SQL functions can not be created with the createProcedure() method of RWDBDatabase that we describe in the next section . Instead , you must use the executeSql() method of RWDBConnection . PL/SQL functions can be executed and the return value can be obtained using the RWDBStoredProc : : returnValue() call . <p> A stored procedure is created using the CREATE OR REPLACE PROCEDURE ... SQL statement . You can create the procedure by using the RWDBDatabase : : createProcedure() call . In this case , the parameter list and body of the stored procedure must be supplied . The body should contain the following : @ @ @ @ @ @ @ @ @ @ procedure to debit an account provides an example . The procedure takes two input parameters and one output parameter . The input parameters are the amount and the acctid , and the output parameter is the new balance , newbal . <p> After a stored procedure is created , it can be executed by instantiating an RWDBStoredProc and calling the execute() method . See the DBTools.h++ User 's Guide and Reference for more information . It is the responsibility of the programmer to make sure that his or her stored procedure can be compiled by the PL/SQL compiler . <p> DBTools.h++ provides support for stored procedures that contain cursor variables . A cursor variable is a reference to a cursor that is defined and opened on an Oracle server . In the sample stored procedure below , written in PL/SQL , myCursor is a cursor variable . <p> create package myProcPkg as type cursvar is ref cursor return employees%ROWTYPE ; end myProcPkg ; create procedure myProc ( myDept in number , myCursor in out myProcPkg.cursvar ) as begin open myCursor for select * from employees where DEPTNO = myDept ; @ @ @ @ @ @ @ @ @ @ an RWDBResult containing the result sets returned from the execution of a stored procedure , as in the following code fragment : <p> increases the performance of stored procedures by eliminating the usual parameter fetch required for instantiations . The schema can come from previously cached procedure schema , through RWDBStoredProc : : params() , or from user-created schema . The user-created schema must include the name and the type of each parameter in the stored procedure . When the type is unknown , the native type should be used . The native type is used first to avoid type mapping , unless the native type is set to the default -1 . 
@@75678054 @4378054/ <p> An **30;11541;TOOLONG is a readable IOU handle . An IOU , sometimes known as a future , is a promise for a value that is forthcoming . It is a placeholder for that value . Usually the writer of an IOU and the reader ( or readers ) of an IOU are in different threads of control . In this sense IOUs are a mechanism for interthread communication . <p> The template parameter Redeemable is the value type of IOU result . This type must provide a public copy-constructor and must allow dynamic allocation using operator new() . <p> An IOU is a write once/read many structure . It may only be written to once , but may be read any number of times . <p> The **30;11573;TOOLONG handle is a reference counted handle to an **30;11605;TOOLONG . It can be copied and passed by value . When the last handle to a given **30;11637;TOOLONG is destroyed , then the internal **30;11669;TOOLONG is destroyed . <p> An **30;11701;TOOLONG can be initialized by or assigned to an **30;11733;TOOLONG , and visa versa . Both are interfaces to the same @ @ @ @ @ @ @ @ @ @ **30;11832;TOOLONG is a write interface . <p> The holder of the **30;11864;TOOLONG decides how and when to redeem the value held by the IOU . IOU redemption is the process of getting the result from the IOU when it is available . There are 3 ways to redeem an **30;11896;TOOLONG : <p> Blocking . A call to **30;11928;TOOLONG : : redeem() will block the caller until the result is available . <p> Polling . Calls to **30;11960;TOOLONG : : redeemable() return whether the IOU is redeemable . An IOU is redeemable if a value has been set , an exception has been set , or the IOU has been aborted . <p> Callback . A callback function may be registered with the IOU using LONG ... The callback function is created using one of the rwtMakeIOUCallback() functions or macros . The callback is called and passed an **30;11992;TOOLONG when the IOU is redeemable . <p> An IOU may be aborted by the holder of an **30;12024;TOOLONG . This will cause an exception to be thrown if an attempt is made to redeem the IOU or to set its value . @ @ @ @ @ @ @ @ @ @ by the holder of an **30;12056;TOOLONG . This will cause the exception to be thrown when an attempt is made to redeem it . <p> An **30;12088;TOOLONG is redeemable if a value has been set , if it has been aborted , or if an exception has been set . <p> Creates an empty , invalid handle . Use of an instance created by the default constructor will result in an RWTHRInvalidPointer exception being thrown . You can determine if an **30;12120;TOOLONG handle is valid by calling the isValid() member function which is inherited from the RWHandleBase base class . <p> RWTIOUResult ( const **38;12152;TOOLONG escrowHandle ) ; <p> Constructs a new handle instance and attaches it to the escrow instance , if any , pointed to by second , and increments the escrow 's reference count . This constructor allows an **30;12192;TOOLONG to be constructed from an **30;12224;TOOLONG . <p> RWTIOUResult ( const **35;12256;TOOLONG second ) ; <p> Copy constructor . Constructs a new handle instance and attaches it to the escrow instance , if any , pointed to by second , and increments the escrow 's reference count @ @ @ @ @ @ @ @ @ @ , if any , decrementing the escrow 's reference count and deleting the escrow if the count reaches zero . It then attaches to the escrow instance , if any , pointed by second , and increments the new escrow 's reference count . <p> Tells the writer of an IOU that a result is no longer needed . Notifies anyone waiting to redeem the IOU so they can detect , abort , and catch an exception . Subsequent calls to redeem the IOU will immediately receive an exception indicating that the operation associated with the IOU has been aborted . Ignored if the operation was already aborted . Possible exceptions include RWTHRInvalidPointer . <p> RWBoolean aborted(void) const ; <p> Returns TRUE if the operation has been aborted , and FALSE if not . Possible exceptions include RWTHRInvalidPointer . <p> void addCallback ( const RWIOUResultCallback&amp; callback ) <p> Adds a callback . Will be called when the IOU is closed . <p> RWBoolean inError(void) const ; <p> Returns TRUE if the IOU was closed with an error , and FALSE if not . Possible exceptions include RWTHRInvalidPointer . <p> Redeemable @ @ @ @ @ @ @ @ @ @ the result is not yet available . Throws RWTHROperationAborted if the IOU ( or the associated operation ) has been aborted . If an exception is thrown and stored in the IOU , then that exception is re-thrown by this routine . <p> RWBoolean redeemable(void) const ; <p> Returns TRUE if the IOU has been closed , closed with an error , or aborted , and FALSE if not . This function is used to poll an IOU for the availability of a result . Possible exceptions include RWTHRInvalidPointer . <p> RWBoolean redeemed(void) const ; <p> Returns TRUE if the IOU has been redeemed at least once , and FALSE if the IOU has never been redeemed . Possible exceptions include RWTHRInvalidPointer. 
@@75678055 @4378055/ <h> com.imsl.stat Class AutoCorrelation <p> Computes the sample autocorrelation function of a stationary time series . <p> AutoCorrelation estimates the autocorrelation function of a stationary time series given a sample of n observations for . <p> Let <p> be the estimate of the mean of the time series where <p> The autocovariance function is estimated by <p> where K = maximumlag . Note that is an estimate of the sample variance . The autocorrelation function is estimated by <p> Note that by definition . <p> The standard errors of sample autocorrelations may be optionally computed according to the getStandardErrors method argument stderrMethod . One method ( Bartlett 1946 ) is based on a general asymptotic expression for the variance of the sample autocorrelation coefficient of a stationary time series with independent , identically distributed normal errors . The theoretical formula is <p> where assumes is unknown . For computational purposes , the autocorrelations are replaced by their estimates for , and the limits of summation are bounded because of the assumption that for all such that . <p> A second method ( Moran 1947 ) utilizes an exact formula @ @ @ @ @ @ @ @ @ @ random process with independent , identically distributed normal errors . The theoretical formula is <p> where is assumed to be equal to zero . Note that this formula does not depend on the autocorrelation function . <p> The method **26;12293;TOOLONG estimates the partial autocorrelations of the stationary time series given K = maximumlag sample autocorrelations for k=0,1 , ... , K. Consider the AR(k) process defined by <p> where denotes the j-th coefficient in the process . The set of estimates for k = 1 , ... , K is the sample partial autocorrelation function . The autoregressive parameters for j = 1 , ... , k are approximated by Yule-Walker estimates for successive AR(k) models where k = 1 , ... , K. Based on the sample Yule-Walker equations <p> a recursive relationship for k=1 , ... , K was developed by Durbin ( 1960 ) . The equations are given by <p> and <p> This procedure is sensitive to rounding error and should not be used if the parameters are near the nonstationarity boundary . A possible alternative would be to estimate for successive AR(k) models using least @ @ @ @ @ @ @ @ @ @ true process is AR(p) , Box and Jenkins ( 1976 , page 65 ) note <h> AutoCorrelation <p> Constructor to compute the sample autocorrelation function of a stationary time series . 50234 @qwx670234 <p> x - a one-dimensional double array containing the stationary time series <p> maximumlag - an int containing the maximum lag of autocovariance , autocorrelations , and standard errors of autocorrelations to be computed . maximumlag must be greater than or equal to 1 and less than the number of observations in x <p> Method Detail <h> getAutoCorrelations <p> public double getAutoCorrelations() <p> Returns the autocorrelations of the time series x . <p> Returns : <p> a double array of length maximumlag +1 containing the autocorrelations of the time series x . The 0-th element of this array is 1 . The k-th element of this array contains the autocorrelation of lag where k = 1 , ... , maximumlag. <h> getAutoCovariances <p> a double array of length maximumlag +1 containing the variances and autocovariances of the time series x . The 0-th element of the array contains the variance of the time series x . The @ @ @ @ @ @ @ @ @ @ = 1 , ... , maximumlag. <h> getMean <h> **26;12321;TOOLONG <p> Returns the sample partial autocorrelation function of the stationary time series x . <p> Returns : <p> a double array of length maximumlag containing the partial autocorrelations of the time series x. <h> getStandardErrors <p> public double getStandardErrors ( int stderrMethod ) <p> Returns the standard errors of the autocorrelations of the time series x . Method of computation for standard errors of the autocorrelation is chosen by the stderrMethod parameter . If stderrMethod is set to BARTLETTSFORMULA , Bartlett 's formula is used to compute the standard errors of autocorrelations . If stderrMethod is set to MORANSFORMULA , Moran 's formula is used to compute the standard errors of autocorrelations. 50234 @qwx670234 <p> stderrMethod - an int specifying the method to compute the standard errors of autocorrelations of the time series x <p> Returns : <p> a double array of length maximumlag containing the standard errors of the autocorrelations of the time series x 
@@75678057 @4378057/ <p> Class RWTime represents a time , stored as the number of seconds since 00:00:00 January 1 , 1901 GMT . See Section 5 of the User 's Guide for how to set the time zone for your compiler . Failure to do this may result in GMT times being wrong . <p> Output formatting is done using an RWLocale object . The default locale formats according to U.S. conventions . <p> Note that because the default constructor for this class creates an instance holding the current date and time , constructing a large array of RWTime may be slow . <p> RWTime v5000 ; // Figures out the current time 5000 times <p> Those with access to the C++ Standard Library-based versions of the Tools.h++ template collections should consider the following : <p> // Figures out the current time just once : **33;12349;TOOLONG v ( 5000 , RWTime() ) ; <p> Thanks to the smart allocation scheme of the standard collections , the above declaration will result in only one call to the default constructor followed by 5000 invocations of the copy constructor . In the case of @ @ @ @ @ @ @ @ @ @ one long to another , resulting in faster creation than the simple array . <p> Constructs a time with s seconds since 00:00:00 January 1 , 1901 GMT . If s==0 , an invalid time is constructed . Note that for small s this may be prior to January 1 , 1901 in your time zone . <p> The compiler can parse 0 as either an integer or a pointer . Since there is also a constructor which takes a pointer ( to struct tm ) , if you want to construct a time from the unsigned long value 0 , you will have to be explicit : <p> Constructs a time for a given date , hour , minute , and second , relative to the time zone zone , which defaults to local time . Note that the maximum RWTime is much sooner than maximum RWDate . ( In fact , it is on Feb. 5 , 2037 for platforms with 4-byte longs . ) This is a consequence of the fact that RWTime counts seconds while RWDate only deals with full days . <p> RWTime ( const @ @ @ @ @ @ @ @ @ @ ) ; <p> Constructs a time from the tmyear , tmmon , tmmday , tmhour , tmmin , and tmsec components of the struct tm argument . These components are understood to be relative to the time zone zone , which defaults to local time . Note that the numbering of months and years in a struct tm differs from that used in RWTime arguments . <p> Constructs a time for the given date , extracting the time from the string str . The string str should contain only the time . The time is understood to be relative to the time zone zone , which defaults to local time . The specified locale is used for formatting information . Use function isValid() to check the results . Note : not all time string errors can be detected by this function . <p> Returns self as a string , formatted by the RWLocale argument , with the time zone adjusted according to the RWZone argument . Formats are as defined by the standard C library function strftime() . The default format is the date followed by the time : " @ @ @ @ @ @ @ @ @ @ and time returned is dependent upon the implementation of strftime() available . For more information , look under RWLocale . <p> Returns self as a string , formatted by the RWLocale argument , with the time zone adjusted according to the RWZone argument . Formats are as defined by the standard C library function strftime() . <p> RWBoolean between ( const RWTime&amp; a , const RWTime&amp; b ) const ; <p> Returns TRUE if RWTime is between a and b , inclusive . <p> sizet binaryStoreSize() const ; <p> Returns the number of bytes necessary to store the object using the global function <p> RWFile&amp; operator&lt;&lt; ( RWFile&amp; , const RWTime&amp; ) ; <p> int compareTo ( const RWTime* t ) const ; <p> Comparison function , useful for sorting times . Compares self to the RWTime pointed to by t and returns : <p> 0 if self == *t ; 1 if self &gt; *t ; -1 if self &lt; *t ; <p> void extract ( struct tm* , const RWZone&amp; = RWZone : : local() ) const ; <p> Fills all members of the struct tm argument , @ @ @ @ @ @ @ @ @ @ . If the time is invalid , the struct tm members are all set to -1 . Note that the encoding of struct tm members is different from that used in RWTime and RWDate functions . <p> unsigned hash() const ; <p> Returns a suitable hashing value . <p> unsigned hour ( const RWZone&amp; zone = RWZone : : local() ) const ; <p> Returns the hour , adjusted to the time zone specified . <p> unsigned hourGMT() const ; <p> Returns the hour in GMT . <p> RWBoolean isDST ( const RWZone&amp; zone = RWZone : : local() ) const ; <p> Returns TRUE if self is during Daylight-Saving Time in the time zone given by zone , FALSE otherwise . 
@@75678058 @4378058/ <h> 3.3 Threading Class Hierarchies <p> The Threading package runnable objects are implemented using a common C++ design technique called the handle-body idiom . Each runnable instance consists of a protected body instance with one or more public handle instances that reference it . The hierarchy of runnable classes is shown in Figure 2 . <p> A runnable object is reference-counted . Each runnable body instance keeps a count of the number of handles that currently reference it . A runnable object is deleted when the last handle that references the body is deleted . <p> The public interface for a runnable is included in its handle classes . Many of the public functions in a handle simply forward control to a corresponding protected function in the body class . <p> You can find additional information regarding the handle-body idiom and reference-counting in the Smart Pointer package . <p> Many runnable objects supply two different handle classes-one that defines an interface intended for use by outside threads and one that defines an interface that can only be used by the thread running inside the runnable object . Other runnable @ @ @ @ @ @ @ @ @ @ are defined in both the internal and external handle classes . <p> Outside threads-The RWRunnable and RWThread handles give access to functions that outside threads use to manipulate the corresponding runnable , such as requestInterrupt() or resume() . <p> Inside threads-The RWRunnableSelf and RWThreadSelf handles give access to functions that can only be used by the thread running inside the runnable , such as serviceInterrupt() or yield() . <p> Internal and external handle instances-An internal handle instance can be converted to an external handle instance and vice-versa , but any attempt to violate the thread access restrictions imposed by the separate interfaces generally results in an RWTHRIllegalAccess exception . <p> Empty handles-A runnable handle instance is not required to reference a body-handles can be constructed in an empty state . Many of the functions provided by the handle class can not be used if the handle instance is empty . Calls to functions that are normally forwarded to a body instance produce an RWTHRInvalidPointer exception if called on an empty handle . You can test a handle to see if it is empty by using the isValid() member function . @ @ @ @ @ @ @ @ @ @ public constructors that build a corresponding body instance . Body instances are constructed by calling one of the static make() functions included in each handle class . These functions dynamically allocate the appropriate body class instance on the heap , and return a temporary handle instance that has been bound to the new body . <p> Figure 4 shows the IOU class hierarchy . All but one of these classes are in the Interthread Communication package , which implements the framework for the IOU functionality . The hierarchy is duplicated here , because the piece that makes IOUs usable is the Threading package class RWTThreadEscrowImp . This class has the mechanisms for synchronizing multithread access to the result and blocking threads that have attempted to redeem the result before it has been supplied . 
@@75678060 @4378060/ <p> This class is a simple hash table for objects inheriting from RWCollectable . It uses chaining ( as implemented by class RWSlistCollectables ) to resolve hash collisions . Duplicate objects are allowed . <p> An object stored by RWHashTable must inherit from the abstract base class RWCollectable , with suitable definition for virtual functions hash() and isEqual() ( see class RWCollectable ) . <p> To find an object that matches a key , the key 's virtual function hash() is first called to determine in which bucket the object occurs . The bucket is then searched linearly by calling the virtual function isEqual() for each candidate , with the key as the argument . The first object to return TRUE is the returned object . <p> The initial number of buckets in the table is set by the constructor . There is a default value . If the number of items in the collection greatly exceeds the number of buckets then efficiency will sag because each bucket must be searched linearly . The number of buckets can be changed by calling member function resize() . This will require @ @ @ @ @ @ @ @ @ @ Create a new hash table as a shallow copy of the table t . The new table will have the same number of buckets as the old table . Hence , the members need not be and will not be rehashed . <p> Assignment operator . Sets self as a shallow copy of t . Afterwards , the two tables will have the same number of buckets . Hence , the members need not be and will not be rehashed . <p> RWBoolean operator== ( const RWHashTable&amp; t ) const ; <p> Returns TRUE if self and t have the same number of elements and if for every key in self there is a corresponding key in t which isEqual . <p> RWBoolean operator&lt;= ( const RWHashTable&amp; t ) const ; <p> Returns TRUE if self is a subset of t , that is , every element of self has a counterpart in t which isEqual . Note : If you inherit from RWHashTable in the presence of the Standard C++ Library , we recommend that you override this operator and explicitly forward the call . Overload resolution in C++ @ @ @ @ @ @ @ @ @ @ class members . These global definitions are not appropriate for set-like partial orderings . <p> Redefined from RWCollection . The function pointed to by ap will be called for each member in the collection . Because of the nature of hashing collections , this will not be done in any particular order . The function should not do anything that could change the hash value or equality properties of the objects . 
@@75678061 @4378061/ <h> Rogue Wave Software acquires API management leader Akana <p> Louisville , CO " 11/29/2016 <h> API economy drives software development and business logic access <p> Rogue Wave Software announces it has acquired Akana , a leader in developing , managing , and securing application programming interfaces ( APIs ) . As businesses look to further connect with their partners and customers , strength in API governance , integration , and ease of accessing legacy applications are increasingly part of the digital transformation . <p> According to The API Management Solutions Market Will Quadruple By 2020 As Business Goes Digital , a Forrester blog by Michael Yamnitsky : " Often considered the poster child of digital transformation , APIs are proliferating at enterprises making industry-leading investments in mobile , IoT , and big data . As these initiatives mature , CIOs , CTOs , and heads of development are coming together with business leaders to manage and secure companywide use of APIs using API management solutions . " <p> Rogue Wave CEO Brian Pierce explains the fit , " Todays announcement builds on our commitment to software development , @ @ @ @ @ @ @ @ @ @ and IoT . APIs are the business interfaces , so the ability to manage and govern their use fits squarely with our product capabilities . Akana mirrors the needs in our enterprise customer base and furthers our mission to accelerate great code . " <p> Recently , Akana was named a Leader by Forrester Research , Inc. in its new report , " The Forrester Wave : API Management Solutions , Q4 2016 . " APIs drive business , making API management a critical component of business strategy . <p> The flagship Akana API platform is available in three editions to meet scale and security requirements , with enterprise-class features , including : <p> API traffic management Complete control over traffic , including alerts and SLA enforcement <p> Akana is available as a SaaS platform , on-premises , and as a hybrid deployment . This acquisition is highly complementary to the 2015 Zend acquisition , fueling web and mobile development , including API development . For further inquiries , please contact Amanda Boughey , content communications manager . 
@@75678062 @4378062/ <p> This class maintains a collection of keys , each with an associated item of type T. These pairs are stored according to a hash object of type H. H must provide a const hash function on elements of type K via public member <p> unsigned long operator() ( const K&amp; x ) const ; <p> Equivalent keys within the collection will be grouped together based on an equality object of type EQ . EQ must ensure this grouping via public member <p> bool operator() ( const K&amp; x , const K&amp; y ) const ; <p> which should return true if x and y are equivalent . <p> Note : Any two keys that are equivalent must hash to the same value . <p> RWTValHashMap&lt;K , T , H , EQ&gt; will not accept a key that is equivalent to any key already in the collection . ( RWTValHashMultiMap&lt;K , T , H , EQ&gt; may contain multiple keys that are equivalent to each other . ) Equality is based on an equality object and not on the == operator . If your type has an == operator @ @ @ @ @ @ @ @ @ @ function object provided by the Standard C++ Library ; otherwise , you must define your own equality object . <p> The value type must have operator== ( ) defined . This requirement is imposed by the Standard C++ Library . <p> Returns true if self compares equal to m , otherwise returns false . Two collections are equal if both have the same number of entries , and iterating through both collections produces , in turn , individual pairs that compare equal to each other . <p> T&amp; operator ( const K&amp; key ) ; <p> Looks up key and returns a reference to its associated item . If the key is not in the dictionary , then it will be added with an associated item provided by the default constructor for type T. <p> If there exists an association a in self such that the expression ( ( *fn ) ( a , d ) ) is true , assigns a to r and returns true . Otherwise , returns false and leaves the value of k unchanged . fn points to a user-defined tester function which must have @ @ @ @ @ @ @ @ @ @ void* d ) ; 50233 @qwx670233 <p> bool findValue ( const K&amp; key , T&amp; r ) const ; <p> If there exists a key j in self that compares equal to key , assigns the item associated with j to r and returns true . Otherwise , returns false and leaves the value of r unchanged . <p> bool findKeyValue ( const K&amp; key , K&amp; kr , T&amp; tr ) const ; <p> If there exists a key j in self that compares equal to key , assigns j to kr , assigns the item associated with j to tr , and returns true . Otherwise , returns false and leaves the values of kr and tr unchanged . <p> bool insert ( const K&amp; key , const T&amp; a ) ; <p> Adds key with associated item a to the collection . Returns true if the insertion is successful , otherwise returns false . The function will return true unless the collection already holds an association with the equivalent key . <p> bool insertKeyAndValue ( const K&amp; key , const T&amp; a ) ; <p> This is @ @ @ @ @ @ @ @ @ @ behaves exactly the same as insert . <p> bool isEmpty() const ; <p> Returns true if there are no items in the collection , false otherwise . <p> Returns the number of associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool remove ( const K&amp; key ) ; <p> Removes the first association with key j in self such that the expression ( j == key ) is true and returns true . Returns false if there is no such association . <p> bool remove ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes the first association a in self such that the expression ( ( *fn ) ( a , d ) ) is true and returns true . Returns false if there is no such element . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> sizetype removeAll ( const K&amp; key @ @ @ @ @ @ @ @ @ @ compare equal to key . Returns the number of items removed . <p> sizetype removeAll ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes all associations a in self such that the expression ( ( *fn ) ( a , d ) ) is true . Returns the number of items removed . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> void resize ( sizetype sz ) ; <p> Changes the capacity of self by creating a new hashed map with a capacity of sz . resize copies every element of self into the new container and finally swaps the internal representation of the new container with the internal representation of self . <p> rwhashmap&lt;K , T , H , EQ&gt;&amp; std() ; const rwhashmap&lt;K , T , H , EQ&gt;&amp; std() const ; <p> Returns a reference to the underlying C++-standard collection that serves as the implementation for self . This reference may be used freely , providing access to the C++-standard interface as well as interoperability with other software components that @ @ @ @ @ @ @ @ @ @ at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75678063 @4378063/ <h> A.3. - Sampling of MPI Applications <p> When sampling a normal , non-MPI application , the sample command creates a fingerprint file called sample.smp by default , unless overridden by an explicit parameter like so : <p> $ sample -o myapp-test4.smp -r . /myapp arg1 <p> In a MPI environment , there are several instances of the sampler that all try to create their own fingerprint files , typically in the same directory . Clearly , they need to use different names for their files , or else the files overwrite one another . It is your responsibility to provide a template for the names of these files as an input to the sample command : <p> $ mpirun -np 16 sample -o test4/myapp-%r.smp -r . /myapp arg1 <p> The %r is a special sequence that expands to a unique value for each rank . On many systems it expands to the MPI rank number , but on systems where the rank number is not available to ThreadSpotterG , it expands to a combination of hostname and a unique number , e.g. , " node45-17 " , where @ @ @ @ @ @ @ @ @ @ is a sequential number within that node . <p> The following table lists the special sequences that ThreadSpotterG recognizes : <p> Table- A.1. - Fingerprint filename substitutions <p> Sequence <p> Substitution <p> %r <p> If executed in an MPI environment this is replaced with the MPI rank number , if known . On other systems it is equivalent to %h-%p ( see below ) . 
@@75678064 @4378064/ <p> Constructs an address for a TCP/IP internet connection . Note that the RWInetPort and RWInetHost classes have conversion constructors that take either a string or an integer , so you can specify either a string or an integer for either the port or the host . The constructor that takes only a port argument creates a special address used to bind to any of the network interfaces on the machine on which the process is running . This is done , for example , when you are setting a server address . An address created using the default constructor binds to an arbitrary port number on any network interface the machine has . These constructors do not block . <p> RWInetAddr ( const RWCString&amp; s ) ; <p> Constructs an address from s , where s has the form type:host:port and both type and host are optional . If type is supplied it must be stream for a stream socket address or dgram for a datagram socket . <p> Returns a pointer to an internal representation of the address that was cast to a sockaddr structure , as @ @ @ @ @ @ @ @ @ @ is to an internal data structure , so it becomes invalid if self is changed in any way or goes out of scope . If the address has no representation as a sockaddr , a null pointer is returned . <p> RWInetHost host() const ; <p> Returns the host part of the address . <p> RWCString i 'd ( unsigned level=0 ) ; <p> Returns a string describing self . The verbosity of the output is controlled by level with level=0 being the most basic output and level=9 the most verbose . <p> RWInetPort port() const ; <p> Returns the port part of the address . <p> virtual void prepare() const ; <p> Ensures that future calls do not block on this address . If necessary , this function looks up the IP address and port number from the host name and service name . It is not necessary to call prepare() , but if you do n't , future calls may block . No exceptions are thrown from prepare() . <p> virtual sizet sockaddrSize() const ; <p> Returns the size of an internal representation of the socket address defined by the sockets . 
@@75678065 @4378065/ <h> 5.4 Columns and Rows <p> The row and column count can be changed at run time using the following APIs : <p> CGXGridCore : : SetColCount() <p> Specifies the number of columns in the grid . If this number is greater than the current number of columns , new columns will be added to the right-hand side of the grid . If the new count is less the current count , the extra columns will be removed from the right-hand side of the grid . <p> CGXGridCore : : SetRowCount() <p> Specifies the number of rows in the grid . If this number is greater than the current number of rows , new rows will be added to the bottom of the grid . If the new count is less the current count , the extra rows will be removed from the bottom of the grid . <p> CGXGridCore : : InsertCols() <p> Inserts columns before a specified anchor column . <p> InsertCols ( 8 , 5 ) ; // Insert 5 columns before column 8 <p> To add columns at the bottom of the grid , use @ @ @ @ @ @ @ @ @ @ in the above call . <p> The end user can resize a column or row by dragging the grid line separating two headers . The column to the left or the row above the grid line being dragged is resized . You can change the behavior for end user resizing using : <p> CGXGridParam : : EnableTrackColWidth() <p> Specifies how columns can be resized . <p> CGXGridParam : : EnableTrackRowHeight() <p> Specifies how rows can be resized . <p> Or turn user resizing off by calling <p> CGXGridParam : : **26;12384;TOOLONG <p> or <p> CGXGridParam : : **27;12412;TOOLONG . <p> The end user can also size a column or row by double-clicking the adjacent grid line . Again , the column to the left or the row above will be resized . Double-clicking the grid line resets the column or row to the default size . The programmer can specify the default size using : <p> Hidden columns have zero width . Hidden rows have zero height . The programmer can hide a column by calling CGXGridCore : : HideCols()or hide a row by calling CGXGridCore : : HideRows() . @ @ @ @ @ @ @ @ @ @ hidden are set in the grid object . Visibility flags are stored with a call to StoreHideRow() for each row or StoreHideCol() for each column . The display is updated with **25;12441;TOOLONG or UpdateChangedColWidths() . <p> CGXGridCore : : HideCols() <p> An overridable command for specifying the visible-flag for specific columns . This function can also be used to unhide a column . <p> CGXGridCore : : HideRows() <p> An overridable command for specifying the visible-flag for specific rows . This function can also be used to unhide a row . <p> The end user can hide a column or row by resizing the column or row to zero . ( User resizing of rows and columns is discussed in Section 5.4.2.2 . ) Users can unhide hidden columns and rows by double-clicking the grid line where columns or rows are hidden . For example , if column 3 is hidden , the end user could double-click the grid line between the column 2 header and the column 4 header . This will cause column 3 to be resized to the default size . Users can also resize the column @ @ @ @ @ @ @ @ @ @ 43 and Figure 44 ) until the column or row is restored . <p> Frozen columns are columns that will never scroll out of the window ; they are always fixed at the left side of the grid . Frozen rows are rows that will never scroll out of the window ; they are always fixed at the top of the grid . <p> CGXGridCore : : SetFrozenCols() <p> An overridable command for specifying the number of frozen columns and columns to be used as row headers . Row headers are columns that will be used to display titles for rows . They typically have a 3D-look . <p> CGXGridCore : : GetFrozenCols() <p> An overridable method that returns the number of frozen columns stored in the parameter-object . <p> CGXGridCore : : StoreFrozenCols() <p> An overridable method that stores the number of frozen columns and columns to be used as row headers to the corresponding attribute of the parameter-object . <p> You can override this method if you want to maintain the data in your own classes . The library accesses the data through GetFrozenCols() and GetHeaderCols() . <p> @ @ @ @ @ @ @ @ @ @ the window display after freezing columns . The method simply calls Redraw() . <p> An overridable command for specifying the number of frozen rows and rows to be used as column headers . Column headers are rows that will be used to display titles for columns . They typically have a 3D-look . <p> Numbering begins with zero . This means that if you set nFrozenRows = 0 and nHeaderRows = 0 there will still be one column header . <p> If you want to hide the first column header , you should call HideRows(0,0) . <p> An overridable method that returns the number of frozen rows stored in the parameter-object . <p> CGXGridCore : : StoreFrozenRows() <p> An overridable method that stores the number of frozen rows and rows to be used for column headers to the corresponding attribute of the parameter-object . The library accesses the data through GetFrozenRows() and GetHeaderRows() . <p> You can override this method if you want to maintain the data in your own classes . <p> CGXGridCore : : UpdateFrozenRows() <p> An overridable method that updates the display window after freezing rows . The method simply calls Redraw(). 50236 @qwx670236 
@@75678066 @4378066/ <h> I <p> Evaluates a sequence of modified Bessel functions of the first kind with real order and real argument . The Bessel function , is defined to be <p> Here , argument xnu is represented by in the above equation . <p> The input x must be nonnegative and less than or equal to log(b) ( b is the largest representable number ) . The argument = xnu must satisfy . <p> This function is based on a code due to Cody ( 1983 ) , which uses backward recursion . 50234 @qwx670234 <p> xnu - a double representing the lowest order desired . xnu must be at least zero and less than 1 <p> x - a double representing the argument of the Bessel functions to be evaluated <p> n - is the int order of the last element in the sequence <p> Returns : <p> a double array of length n+1 containing the values of the function through the series . Bessel.Ii contains the value of the Bessel function of order i+xnu . <h> I <p> public static double I ( double x , int n @ @ @ @ @ @ @ @ @ @ the first kind with integer order and real argument . The Bessel function is defined to be <p> The input x must satisfy where b is the largest representable floating-point number . The algorithm is based on a code due to Sookne ( 1973b ) , which uses backward recursion . 50234 @qwx670234 <p> x - a double representing the argument of the Bessel functions to be evaluated <p> n - is the int order of the last element in the sequence <p> Returns : <p> a double array of length n+1 containing the values of the function through the series . Bessel.Ii contains the value of the Bessel function of order i . <h> J <p> public static double J ( double xnu , double x , int n ) <p> Evaluate a sequence of Bessel functions of the first kind with real order and real positive argument . The Bessel function , is defined to be <p> This code is based on the work of Gautschi ( 1964 ) and Skovgaard ( 1975 ) . It uses backward recursion . 50234 @qwx670234 <p> xnu - a double representing @ @ @ @ @ @ @ @ @ @ zero and less than 1 . <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated <p> n - an int representing the order of the last element in the sequence . If order is the highest order desired , set n to int(order) . <p> Returns : <p> a double array of length n+1 containing the values of the function through the series . Bessel.JI contains the value of the Bessel function of order I+v at x for I=0 to n . <h> J <p> public static double J ( double x , int n ) <p> Evaluates a sequence of Bessel functions of the first kind with integer order and real argument . The Bessel function , is defined to be <p> The algorithm is based on a code due to Sookne ( 1973b ) that uses backward recursion with strict error control . 50234 @qwx670234 <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated <p> n - an int which specifies the order of the last element in @ @ @ @ @ @ @ @ @ @ length n+1 containing the values of the function through the series . Bessel.Ji contains the value of the Bessel function of order i at x for i=0 to n . <h> K <p> public static double K ( double xnu , double x , int n ) <p> Evaluates a sequence of modified Bessel functions of the third kind with fractional order and real argument . The Bessel function is defined to be <p> Currently , xnu ( represented by in the above equation ) is restricted to be less than one in absolute value . A total of n values is stored in the result , K. <p> K , K , , K. <p> This method is based on the work of Cody ( 1983 ) . 50234 @qwx670234 <p> xnu - a double representing the fractional order of the function . xnu must be less than one in absolute value . <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated . <p> n - an int representing the order of the last element in the sequence . @ @ @ @ @ @ @ @ @ @ to int(order) . <p> Returns : <p> a double array of length n+1 containing the values of the function through the series . Bessel.KI contains the value of the Bessel function of order I+v at x for I=0 to n . <h> K <p> public static double K ( double x , int n ) <p> Evaluates a sequence of modified Bessel functions of the third kind with integer order and real argument . This function uses for and . For the definition of , see above . 50234 @qwx670234 <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated <p> n - an int which specifies the order of the last element in the sequence <p> Returns : <p> a double array of length n+1 containing the values of the function through the series <h> scaledK <p> public static double scaledK ( double v , double x , int n ) <p> Evaluate a sequence of exponentially scaled modified Bessel functions of the third kind with fractional order and real argument . This function evaluates , for i=1 , ... @ @ @ @ @ @ @ @ @ @ the third kind . Currently , v is restricted to be less than 1 in absolute value . A total of elements are returned in the array . This code is particularly useful for calculating sequences for large x provided n = x . ( Overflow becomes a problem if . ) n must not be zero , and x must be greater than zero . must be less than 1 . Also , when is large compared with x , must not be so large that <p> overflows . The code is based on work of Cody ( 1983 ) . 50234 @qwx670234 <p> v - a double representing the fractional order of the function . v must be less than one in absolute value . <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated . <p> n - an int representing the order of the last element in the sequence . If order is the highest order desired , set n to int(order) . <p> Returns : <p> a double array of length n+1 containing the values of @ @ @ @ @ @ @ @ @ @ , Bessel.KI contains times the value of the Bessel function of order I+v at x for I=0 to n . If n is negative , Bessel.KI contains times the value of the Bessel function of order v-I at x for I=0 to n . <h> Y <p> public static double Y ( double xnu , double x , int n ) <p> Evaluate a sequence of Bessel functions of the second kind with real nonnegative order and real positive argument . The Bessel function is defined to be <p> The variable xnu ( represented by in the above equation ) must satisfy . If this condition is not met , then Y is set to NaN . In addition , x must be in where and . If , then the largest representable number is returned ; and if , then zero is returned . <p> The algorithm is based on work of Cody and others , ( see Cody et al . 1976 ; Cody 1969 ; NATS FUNPACK 1976 ) . It uses a special series expansion for small arguments . For moderate arguments , an analytic continuation @ @ @ @ @ @ @ @ @ @ minimax approximations providing starting values is employed . An asymptotic expansion is used for large arguments . 50234 @qwx670234 <p> xnu - a double representing the lowest order desired . xnu must be at least zero and less than 1 <p> x - a double representing the argument for which the sequence of Bessel functions is to be evaluated <p> n - an int such that n+1 elements will be evaluated in the sequence <p> Returns : <p> a double array of length n+1 containing the values of the function through the series . Bessel.KI contains the value of the Bessel function of order I+v at x for I=0 to n. 
@@75678067 @4378067/ <h> SOLA and IBMs CICS SOA Offerings <p> SOLA works well with CICS TS V3.x . SOLA compliments CICS SOA offerings by adding manageability , monitoring , security and much needed additional features . Using SOLA , developer productivity is enormously improved . The paragraphs below and the feature matrix on the following page illustrate the degree to which SOLA improves CICS SOA capability . <p> CICS TS V3.x : <p> Have a large number of components that weave a complex web of interactions . <p> Multiple stages in message handling result in performance lag . <p> Requires installation on the users machine . <p> Task of exposing mainframe apps falls to distributed programmers . <p> Creating web services involves programming . <p> Creating a single web service can take days or weeks . <p> Requires the use of USS . <p> SOLA : <p> Consists of a single mainframe application for the run-time and a single J2EE application for the development environment . <p> SOLA has server based tooling and a central repository which make it easy do impact analysis , search for and reuse components and enforce @ @ @ @ @ @ @ @ @ @ superior performance and stability . <p> Provides over a dozen features and capabilities missing from the integrated SOA features of CICS TS V3.x ( see the feature Matrix below ) . <p> Requires no installation on a users machine ; can be accessed from any machine with a web browser . The development environment runs on a single J2EE server . <p> Creating a single web service can take minutes or a few hours , depending on the complexity of the service . <p> SOLA and CICS TSv3.x <p> SOLA is a perfect compliment to CICS TS V3.x in that it is a native CICS application and takes advantage of all of the new features introduced in previous releases . For example , SOLA exploits the use of containers and channels and uses it to remove the 32K limit for linkable Commarea programs . Using HTTP 1.1 , SOLA can make use of " keep alive " connections to increase overall efficiency by reusing connections . SOLA is also capable of taking advantage of the pipeline architecture by expanding on the capabilities of the pipeline . <p> The following feature @ @ @ @ @ @ @ @ @ @ CICS TS v3.x. 
@@75678070 @4378070/ <p> Collectable strings . This class is useful when strings are stored and retrieved as RWCollectables , or when they are used as keys in the " dictionary " collection classes . Class RWCollectableString inherits from both class RWCString and class RWCollectable . The virtual functions of the base class RWCollectable have been redefined . <p> Redefined from class RWCollectable. returns the result of RWCString : : compareTo ( * ( const String* ) c , RWCString : : exact ) . This compares strings lexicographically , with case considered . It would be possible to define , for instance , CaseFoldedString which did comparisons ignoring case . We have deliberately left this as an exercise for two reasons : Because it is both easy to do and not universally needed ; and because the presence of both RWCollectableStrings and such a CaseFoldedString in any kind of sorted collection has the potential for very confusing behavior , since the result of a comparison would depend on the order in which the comparison was done . <p> virtual unsigned hash() const ; <p> Redefined from class RWCollectable . Calls RWCString : : hash() and returns the results . 
@@75678071 @4378071/ <h> 3.7 Multibyte Strings <p> Class RWCString provides limited support for multibyte strings , sometimes used in representing various alphabets ( see Section 16.1XX ) . Because a multibyte character can consist of two or more bytes , the length of a string in bytes may be greater than or equal to the number of actual characters in the string . <p> If the RWCString contains multibyte characters , you should use member function mbLength() to return the number of characters . On the other hand , if you know that the RWCString does not contain any multibyte characters , then the results of length() and mbLength() will be the same , and you may want to use length() because it is much faster . Here 's an example using a multibyte string in Sun : <p> The string in Sun is the name of the day Sunday in Kanji , using the EUC ( Extended UNIX Code ) multibyte code set . With the EUC , a single character may be 1 to 4 bytes long . In this example , the string Sun consists of 6 bytes @ @ @ @ @ @ @ @ @ @ the second or later byte of a multibyte character may be null . This means the length in bytes of a character string may or may not match the length given by strlen() . Internally , RWCString makes no assumptions3 about embedded nulls , and hence can be used safely with character sets that use null bytes . You should also keep in mind that while RWCString : : data() always returns a null-terminated string , there may be earlier nulls in the string . All of these effects are summarized in the following program : <p> You will notice that two different constructors are used above . The constructor in lines 1 and 2 takes a single argument of const char* , a null-terminated string . Because it takes a single argument , it may be used in type conversion ( ARM 12.3.1 ) . The length of the results is determined the usual way , by the number of bytes before the null . The constructor in line 3 takes a const char* and a run length . The constructor will copy this many bytes , including any @ @ @ @ @ @ @ @ @ @ bytes is always given by RWCString : : length() . Because the string may include embedded nulls , this length may not match the results given by strlen() . <p> Remember that indexing and other operatorsbasically , all functions using an argument of type sizetwork in bytes . Hence , these operators will not work for RWCStrings containing multibyte strings . 
@@75678074 @4378074/ <h> Example 2 : SparseMatrix Using the Matrix Market Format <p> The matrix market exchange format is an ASCII file format that represents sparse matrices in coordinate format . It consists of three sections : The header section is the first line in the file and contains general information about the matrix , e.g. data type and symmetry properties . This line is followed by the comments section which consists of zero or more lines of comments . The remainder of the file is the data section . The first line of the data section contains the row number , column number , and number of nonzeros of the matrix . The following lines contain the location and value of all nonzero entries of the matrix , usually one per line . A file in Matrix Market format is read and converted to a JMSL SparseMatrix in this example . Matrix information and the one norm of the matrix are printed . <h> Output <p> The matrix type is %%MatrixMarket matrix coordinate real symmetric The number of rows is 48 The number of columns is 48 The number of @ @ @ @ @ @ @ @ @ @ is 3.00944444444744E9 
@@75678076 @4378076/ <h> OpenSSL security information for our customers <p> Heartbleed , a serious security vulnerability in OpenSSL , was recently detected and announced . So named because it stems from the TLS Heartbeat extension , this vulnerability could allow attackers to access protected information , including the secret keys used to encrypt the information in communications . Heartbleed is specifically related to the OpenSSL 1.0.1 and 1.0.2-beta releases . Patches are available and should be applied to affected systems immediately . Also , security experts recommend that those with affected servers replace and revoke the potentially compromised SSL certificates . For more information regarding the OpenSSL Heartbleed vulnerability click here and click here . <p> As soon as Rogue Wave heard of the Heartbleed security vulnerability , we took steps to investigate what that means for our customers . Below you will find information on how each Rogue Wave product , including OpenLogic and Klocwork , may be affected by this issue . We will continue to monitor the situation and take any steps necessary to ensure that our products are secure . This page will reflect all current efforts @ @ @ @ @ @ @ @ @ @ <p> Products or Services <p> Affected <p> Details <p> Remediation <p> CentOS for Microsoft Azure by OpenLogic <p> Yes* <p> OpenLogic CentOS images for MS Azure do include an affected version of OpenSSL . OpenLogic does not provide any services running that utilize OpenSSL directly , but customers may have add SSL services on top of the core OS image and may be at risk . <p> A patched version of OpenSSL has already been released to the community and is available through the standard package update mechanism . Upgrade any running VM 's by running ' sudo yum update openssl ' . Additionally , the standard image HAS BEEN replaced with a new one that includes the patched package to eliminate propagating the affeced OpenSSL versions . If you have implemented a secured service using SSL , you should update the libraries and replace your SSL Certificate immediately . <p> OpenLogic Stacks for AWS Marketplace built on Ubuntu <p> Yes* <p> OpenLogic Stacks in the AWS Marketplace do include an affected version of OpenSSL . OpenLogic does not provide any services running that utilize OpenSSL directly , but customers @ @ @ @ @ @ @ @ @ @ OS image and may be at risk . <p> A patched version of OpenSSL has already been released to the community and is available through the standard package update mechanism . Upgrade any running VM 's by running ' sudo apt-get update ; sudo apt-get install -y libssl1.0.0 openssl ' . Additionally , the standard image WILL BE replaced with a new one that includes the patched package to eliminate propagating the affeced OpenSSL versions . If you have implemented a secured service using SSL , you should update the libraries and replace your SSL Certificate immediately . <p> * Libraries only installed . These systems are only affected if customer has implemented a service utilizing the OpenSSL libraries . <h> Rogue Wave Products NOT Affected by Heartbleed <p> Products or Services <p> Affected <p> Notes <p> HostAccess <p> No <p> HostAccess does not ship with any affected versions of OpenSSL . <p> HydraExpress <p> No <p> HydraExpress does not ship with any affected versions . Unless customers have changed the SSL library , the application is not affected . <p> IMSL <p> No <p> OpenSSL is not used by @ @ @ @ @ @ @ @ @ @ used directly by this product . <p> OpenLogic Governance Platform <p> No <p> The OpenLogic Governance Platform does not use any affected versions of OpenSSL . <p> OpenLogic Audit Services <p> No <p> Services supporting the OpenLogic Audits are not vulnerable . <p> OpenLogic Support Services <p> No <p> Services for OpenLogic Support are not vulnerable . <p> OpenLogic Stacks for AWS Marketplace built on CentOS <p> No <p> OpenLogic Stacks in the AWS Marketplace built on CentOS include an unaffected version of OpenSSL . <p> PV-WAVE <p> No <p> PV-WAVE does not ship with any affected versions of OpenSSL . <p> SourcePro <p> No <p> SourcePro does not ship with any affected versions of OpenSSL . Unless customers have changed the SSL library , the application is not affected . 
@@75678077 @4378077/ <p> Open source is the dominant force in software development today , with over 80 percent of developers now using open source in their software . With an increase in use of open source software ( OSS ) , support and knowledge of these packages becomes critical to companies . Apache Tomcat is one of the most popular open source software implementations in the industry , and one of the most requested support packages to Rogue Wave OSS support experts . Support requests related to Apache Tomcat cover many aspects of the software , but a popular topic is always high-reliability and clustering . <h> Introduction <p> Open source is the dominant force in software development today , with over 80 percent of developers now using open source in their software . With an increase in use of open source software ( OSS ) , support and knowledge of these packages becomes critical to companies . Apache Tomcat is one of the most popular open source software implementations in the industry , and one of the most requested support packages to Rogue Wave OSS support experts . Support requests @ @ @ @ @ @ @ @ @ @ , but a popular topic is always high-reliability and clustering . <p> Running Apache Tomcat as an application container for revenue generating applications is a decision many companies make every day . Unfortunately , this is where the decision making stops . The design should continue to include a system configuration that will protect these cash generating applications even in the event of catastrophic system failure . This is where Tomcat clustering plays a role . By implementing a solid clustering design you protect your company from systems failure . <p> This paper will walk through what is clustering and why you should cluster your Tomcat application servers . It will look at the multiple options for clustering setups , and help you identify which one is the best for your IT infrastructure . Finally , you can review some detailed example configurations and common issues when clustering with Apache Tomcat . <h> What is clustering ? <p> Clustering , when referring to information technology systems , is two or more independent interconnected systems ( nodes ) , interlinked to provide reliability . Reliability can come in the form of @ @ @ @ @ @ @ @ @ @ ease of maintenance . <p> Independent interconnected systems sounds complicated , although its not . In the case of this paper we are referring to Tomcat systems . An instance of Tomcat is an independent system . Clustering instances of Tomcat makes them interconnected . Tomcat instances in a Tomcat cluster are often referred to as a node . Individual components in any network configuration can normally be referred to as nodes , but for the duration of this paper , we are referring to nodes as Tomcat instances . <p> A Tomcat cluster is a group of Tomcat instances that are connected . There are different ways that they can be connected . The Tomcat instances can be running on the same physical device , same virtual device , or disparate systems . There are many different options when it comes to clustering Tomcat , and we will discuss these in detail further on in this paper . <h> Why you should cluster <p> Clustering can solve different problems . For instance , you have a web application , serving approximately five thousand concurrent requests , running on your @ @ @ @ @ @ @ @ @ @ maxed out . New users are receiving 404 errors . Supporting larger numbers of concurrent requests is one of the advantages of high-availability clustering . The goal of high-availability clustering is 99.999 percent ( " five nines " ) . <p> Another example of a problem clustering is the solution for failover . If your business is running a web application that earns income for your business and this web application is running in a non-clustered environment , you are at risk . If your application is on a Tomcat server that is not clustered and the Tomcat server fails , that source of revenue stops generating money every second the system is down . Setting up a simple Tomcat cluster containing two instances , this issue is preventable . In a properly configured cluster , all requests to the failed server will be directed to the remaining working instance . This will preserve your revenue stream even if there is performance degradation from losing 50 percent of the nodes in the cluster . <p> These are just some examples of why it pays off to cluster Tomcat , or @ @ @ @ @ @ @ @ @ @ these examples above , Tomcat improves your systems availability . High-availability is a goal that many companies seek to improve the appearance and availability of their services . <p> A normal systems yearly average uptime is called its availability . High-availability is a pre-arranged , contracted level of performance that will be maintained during the contract length . Granted , that is not very easy to understand . An example of high-availability could be : your web server is guaranteed to be available " five nines . " This means that in a given year the server will have a maximum of 5.26 minutes of unscheduled downtime a year . <p> To achieve high-availability you need to implement geographic separation . Geographic separation , in regards to our server configuration , is installing nodes of the cluster in geographically different locations . This provides safety against regional power outages and other locational risks like storms and floods . <h> Determining the best clustering setup for your architecture <p> Everyone wants to build a reliable , stable , and available application container platform . But , in order to do so @ @ @ @ @ @ @ @ @ @ your business the best . <p> In determining your configuration you must evaluate the resources at hand . This section will discuss possible options for your resources , without actually taking your resources into consideration . The next section will make suggestions as to which configurations your company may leverage depending on the resources available . <h> Vertical , horizontal , or hybrid cluster <p> A vertical cluster expands vertically . A horizontal cluster expands , you guessed it , horizontally . What does this mean ? A vertically expanding cluster has limited horizontal layout . Horizontal layout would be multiple systems/resources . A vertical cluster is on a single machine a machine can be many things , including a physical device or a virtual host . As need increases , Tomcat instances are spawned on the same machine , using configuration tweaks that allow multiple instances to run on the same system . <p> A horizontal cluster contains Tomcat instances running on separate machines . If demand for processing increases and you had a pure , horizontal cluster configuration , the network technician ( or you ) would install @ @ @ @ @ @ @ @ @ @ that machine is a new Tomcat instance . <p> Real life is often very different from dictate . Companies rarely have a pure horizontal or vertical cluster configuration . Most systems are hybrids . A hybrid cluster is a mixture of vertical and horizontal clustering to facilitate a specific need and/or to match the hardware provided . <h> Homogeneous or heterogeneous cluster <p> Is your setup going to be for multiple applications , or just a few , or maybe just one ? Do you have applications that require specific hardware ? This determines whether or not you decide to use a heterogeneous vs. homogeneous setup . While this section defines your options , the next section will help you decide which option suits your needs . <p> A homogeneous setup is very common . Companies will often duplicate their Tomcat environment , launching servers on many devices with a simple copy of the Tomcat directory . A Tomcat cluster that has the same web applications deployed on all nodes is considered homogeneous . <p> Homogeneous setups can be hard to keep truly identical . Sometimes , especially after node @ @ @ @ @ @ @ @ @ @ the Tomcat instances . The best way to do this is to create an image of the Tomcat setup from a node designated as the primary node . As long as this image stays up-to-date you can distribute it over as many Tomcat setups as you prefer . <h> Load balancing <p> Load balancing happens outside of the Tomcat cluster . The broad scope of load balancing will not be touched in this document . We are concerned with Apache Httpd server and the built-in load balancing/gateway features , as this is free and available , and because of this , it is a common solution in many enterprise systems . <p> To use Apache Httpd as a load balancer we will configure it as a gateway . Once it is aware of its nodes , it is able to balance traffic across these nodes . Further on in the paper , we will show an example configuration , using modproxyajp , of an Httpd gateway with " Round Robin " load balancing . <p> Another common enterprise configuration option for load balancing is the hardware load balancer . A @ @ @ @ @ @ @ @ @ @ as a software balancer ( like the one in the Apache Httpd server ) . The main difference between a software balancer and a hardware balance ( besides price ) , is resources . A HLB has dedicated hardware resources ( RAM ) , processor , network adapters , etc . ) . This allows hardware balancers to perform at a much more efficient rate , while providing more features . This is also an infinitely more expensive method , as you can find many free open source load balancing solutions . <h> Determining the best fit for your organization and resources <p> There are many factors in determining your cluster configuration . When choosing how to configure your cluster its critical to examine the resources available before making a decision . <h> Scalability <p> How do you choose your scalability options ? This relies heavily on the availability of hardware resources . For instance , you have 4 low-end servers , meaning they have one processor with 1-4 gigabytes of RAM . This would be an ideal situation for a horizontal cluster . Each member of the cluster would @ @ @ @ @ @ @ @ @ @ One of the servers could be used as a balancer running Apache Httpd server . Here is a drawing of the architecture . <p> If your situation was a bit different , and you had better servers , you could consider a hybrid cluster . If there are servers available with two or more processors and a large amount of ram ( 8 gigabytes or more ) this would be ideal for multiple Tomcat instances . In this configuration you can setup a hybrid cluster by running multiple instances of Tomcat on multiple machines , and multiple instances of Apache Httpd to handle the load of load balancing . This configuration could look something like this : <h> Heterogeneous or homogeneous Tomcat configuration <p> Determining heterogeneous vs. homogeneous setup can be simple in some situations . The easiest situation is one with a single web application . If there is only one application to deploy , you deploy it to all members in the cluster . This is a very straightforward homogeneous configuration . Unfortunately , most companies do not have one single web application ; however , this situation @ @ @ @ @ @ @ @ @ @ large number of applications . The division of your applications over Tomcat nodes will be your choice . The Tomcat configuration of the nodes will be a little more complicated and we review this further in the examples section . If the company has an application that requires heavy processing and large amounts of ram ( HPR1 , ) you can setup this application on two nodes by itself . After this , take the remaining applications ( GUI ) and place them on two different nodes in the cluster . This will prevent the GUI application from being bogged down when HPR1 is consuming the CPU and RAM . This cluster might look like this : <p> There are many things to take into consideration when designing and building your cluster . If a large company is relying on you to provide a reliable , highly-available application implementation , then clustering and load balancing is the right choice . Regardless of if you are new to clustering , or an old hand , purchase a support contract . There are companies that will provide open source software support for @ @ @ @ @ @ @ @ @ @ you to offer your customers an extremely reliable , available service while at the same time providing someone to turn to if you run into problems . <p> This is not a complete step-by-step tutorial on cluster creation , but we will provide you with the tools you can use to implement a cluster rapidly and effectively . Whether you have created many clusters in the past or this is your first attempt , we hope that you will be able to learn something , whether it be basic or advanced , from the information discussed in this paper . To limit the liability of your attempt at creating a cluster , you can set up a machine , virtual or physical , just for this task . <p> Note - You can run multiple Tomcat instances on a single virtual/physical machine by tweaking just a few settings , mainly port numbers so the instances do n't interfere with each other . The configuration of these Tomcat instances is well outside the scope of this document , although it is not difficult to accomplish . Settings for the connectors in @ @ @ @ @ @ @ @ @ @ Tomcat 8 website . Below are two server configurations that you can use to run a simple cluster , just start with two instances of Tomcat 8 , and replace the corresponding server.xml file with the . xml information provided below . <p> Server.xml 1 <p> Server.xml 2 <h> Configurations <p> Create a Tomcat cluster <p> Tomcat clustering is very simple to setup . However , if you wish to leverage clustering in your enterprise environment the default configuration is not going to be the best route for you . To turn on clustering in your Tomcat server all you have to do is add one line of code to your server.xml . <p> Adding this line to your configuration enables clustering with all of the default settings . This would be great if you were not in an enterprise setting . <p> You have created a clustered Tomcat instance , but you only have one instance , so it is not a very big cluster . Before we create the next instance we should install the application we want to test on this cluster . <p> Make your web @ @ @ @ @ @ @ @ @ @ normal application on one server will not trigger propagation to other servers . The idea behind propagation is : an application is placed on one node in the cluster , it is migrated ( copied ) automatically to other nodes in the cluster . To achieve this we add the following code to the web.xml : <p> This tells Tomcat that this application is designed to run on multiple nodes in this cluster . <p> Set up session replication <p> The default session replication mode is " All to All , " meaning any session data created on a server will be duplicated to all other servers in the cluster . If your application creates session data for a user , and you have a heterogeneous cluster , the session data will still be replicated across the other nodes . A heterogeneous configuration is one that does not have all of the same applications on every node . Therefore , if application A stores session data for a user , and application A is running on server A , but not server B , session data will replicate to server @ @ @ @ @ @ @ @ @ @ there . <p> Configure multicast setup <p> The cluster is discovered and maintained via multicast heartbeats . The server will be set up with a default multicast IP address of 228.0.0.4 and a multicast port of 45564 . This means that any other nodes that are using the same multicast address and port will see this cluster/node . It is important to ensure your network supports multicast . This is commonly blocked for security reasons . <h> Additional considerations <p> The Manager object <p> After creating the cluster object and making your web applications distributable , we need to move on to configuring other settings . The Manager object controls session replication . <p> The DeltaManager replicates all changed session data to all nodes of the cluster . The BackupManager backs up session data to a specific backup node . For large clusters the BackupManager is the option to go with , for smaller clusters it is common to just use the default DeltaManager . <p> In Tomcat 5 , you could n't choose the specific session manager for your application . In Tomcat 8 , you can define a manager @ @ @ @ @ @ @ @ @ @ versions , but you can also define a manager in a web application 's context . <p> Defining the Manager in your clustering configuration provides a default setting for applications that do not provide their own Manager configuration . For instance , the following code will set all applications in your cluster to use the BackupManager for session replication . <p> Channel send options <p> After setting the Manager , you might need to apply a non-default channel send options value . Channel send options is a setting specified on the cluster object . For example : <p> Channel send options controls how messages are sent between cluster nodes . Are these message sent synchronously , or , in layman 's terms , does the thread that sends the message have to wait until the message has sent before continuing to work , in turn , potentially making the users request wait on this message to be sent ? Sending the messages asynchronously is when the thread generates and sends the message , but does not stop and wait for this to happen . It does this by spawning a @ @ @ @ @ @ @ @ @ @ is just one aspect of the channel send options , and it is a lot of information . To go over channel send options in detail will require a whole default channel send mode is asynchronous . <h> Conclusion <p> This paper barely scratches the surface of clustering . What we have provided is a starting point for your cluster . With the information provided here you can start a cluster containing two or one thousand nodes , it is just a matter of determining your companys needs . <p> The cluster configuration in Tomcat can be simple . As demonstrated here we were able to configure a cluster in a small amount of time . Problems like nodes not joining cluster , session information being lost , random node crashes , and configuration issues are normally resolved with little effort . Tomcat clustering is a powerful tool that can provide the high availability , reliability , and dependability that your company requires and all of it can be setup with little effort . 
@@75678078 @4378078/ <h> Naive Bayes An Overview <p> Classification problems are characterized by a need to classify unknown patterns or data into one of m categories based upon the values of k attributes x1 , x2 , , xk . There are many algorithms for solving classification problems including discriminant analysis , neural networks and Naive Bayes . Each algorithm has its strengths and weaknesses . Discriminant analysis is robust but it requires x1 , x2 , , xk . to be continuous , and since it uses a simple linear equation for the discriminant function , its error rate can be higher than the other algorithms . See **26;12468;TOOLONG . <p> Neural Networks provides a linear or non-linear classification algorithm that accepts both nominal and continuous input attributes . However , network training can be unacceptably slow for problems with a larger number of attributes , typically when k &gt;1000 . Naive Bayes , on the other hand , is a simple algorithm that is very fast . A Naive Bayes classifier can be trained to classify patterns involving thousands of attributes and applied to thousands of patterns . As @ @ @ @ @ @ @ @ @ @ text mining and other large classification problems . However , its computational efficiency comes at a price . The error rate for a Naive Bayes classifier is typically higher than the equivalent Neural Network classifier , although it is usually low enough for many applications such as text mining . <p> If C is the classification attribute and XT=x1 , x2 , , xk is the vector valued array of input attributes , the classification problem simplifies to estimating the conditional probability P(cX) from a set of training patterns . The Bayes rule states that this probability can be expressed as the ratio : <p> , <p> where c is equal to one of the target classes 0 , 1 , , nclasses-1 . In practice , the denominator of this expression is constant across all target classes since it is only a function of the given values of X. As a result , the Naive Bayes algorithm does not expend computational time estimating for every pattern . Instead , a Naive Bayes classifier calculates the numerator for each target class and then classifies X to the target class with @ @ @ @ @ @ @ @ @ @ classifier simplifies this calculation by assuming conditional independence : <p> . <p> This is equivalent to assuming that the values of the input attributes , given C , are independent of one another , i.e. <p> , for all i j . <p> In real world data this assumption rarely holds , yet in many cases this approach results in surprisingly low classification error rates . Thus , the estimate of from a Naive Bayes classifier is generally an approximation , classifying patterns based upon the Naive Bayes algorithm can have acceptably low classification error rates . <p> Function imslsfnaivebayestrainer is used to train a classifier from a set of training patterns that contains patterns with values for both the input and target attributes . This routine stores the trained classifier into an Imslsfnbclassifier data structure . The trained classifier can in turn be stored to a file using imslsfnbclassifierwrite , and later retrieved using imslsfnbclassifierread. 
@@75678079 @4378079/ <p> The API Management solution for IBM WebSphere DataPower provides centralized policy definition and service monitoring for DataPower appliances , and allows customers to easily use their existing DataPower infrastructure to virtualize enterprise services for high-availability , load-balancing , and offloading of costly XML and security processing . <p> API Management for IBM WebSphere DataPower allows customers to : <p> Proxy backend REST or SOAP services by transforming , mediating , and integrating with existing large scale backend systems , all without requiring new service development or re-configuring existing backend systems <p> Centrally define policies and apply them to services distributed across multiple DataPower appliances <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75678080 @4378080/ <h> Question <h> Answer <p> The general look of a radar chart is as follows , with only one scale on the Yaxis(0) : <p> It is however possible to have a scale on every Y axis of a radar chart by adding extra Y axes to the chart and configuring the scale for each additional axis . <p> You can choose to set the scale labels visible or not and to draw ticks on one side or the other of the scale , or both as below . <p> In order to have ticks drawn on both sides like below , two Y axes are added for each label of the chart , one hosting the ticks on the left side and the other hosting the ticks on the right side . <p> Attached is a sample that illustrates how to draw chart with multiple Y axes . In order to run this class , you need to add jviews-framework-all.jar and jviews-charts-all.jar , available in JView 's distribution , to your java build path . 
@@75678081 @4378081/ <h> 12.6 Objective Grid Integration With Document/View Architecture <p> For those readers who are familiar with design patterns , the MFC document/view concept is very similar to the Observer pattern : A view is associated with a document , and the document maintains a list of pointers to all associated views . When a view changes data in the document , it can trigger a notification to all associated views that the document data has changed . In Objective Grid , we extended the Observer pattern in such a way that we systematically separated methods , which update the display from methods , which changes data . <p> The document-view architecture in MFC allows the programmer to separate data from the views . An MFC application can offer the user many ways to view the document ( the data ) , and some views may present only a part of the data or results computed from the raw data . For instance , a statistical application could present the data as a grid of numbers , a chart , or a summary showing computed values such as the mean @ @ @ @ @ @ @ @ @ @ applications is the need to propagate information to all views . For example , suppose four view windows show different views of the same document and the user changes data in one view . Now it 's necessary to notify all views about the change . The views should be able to update themselves most efficiently . Note also that views can draw to devices other than the video display e.g. , on plotters or printers . <p> In MFC , a document object keeps a list of its views , provides member functions for adding and removing views , and supplies the UpdateAllViews() member function for letting multiple views know when the document 's data has changed . Each view has an OnUpdate() member function which is called from UpdateAllViews() method for each view . <p> Let us explain how drawing works in a view . <p> With the exception of mouse drawing , nearly all drawing in your application occurs in the view 's OnDraw() member function , which you must override in your view class . Your OnDraw() override : <p> Gets data by calling the document @ @ @ @ @ @ @ @ @ @ calling member functions of a device-context object that the framework passes to OnDraw() . <p> When a document 's data changes in some way , the view must be redrawn to reflect the changes . Typically , this happens when the user makes a change through a view on the document . In this case , the view calls the document 's UpdateAllViews() member function to notify all views on the same document to update themselves . UpdateAllViews() calls each view 's OnUpdate() member function . The default implementation of OnUpdate() invalidates the view 's entire client area . You can override it to invalidate only those regions of the client area that map to the modified portions of the document . <p> The UpdateAllViews() member function of class CDocument and the OnUpdate() member function of class CView let you pass information describing what parts of the document were modified . This hint mechanism let 's you limit the area that the view must redraw . OnUpdate() takes two hint arguments . The first , lHint , of type LPARAM , let 's you pass any data you like , while the @ @ @ @ @ @ @ @ @ @ pass a pointer to any object derived from CObject . <p> When a view becomes invalid , Windows sends it a WMPAINT message . The view 's OnPaint() handler function responds to the message by creating a device-context object of class CPaintDC and calls your view 's OnDraw() member function . You do not normally have to write an overriding OnPaint() handler function . <p> Your code for drawing in the view first retrieves a pointer to the document and then makes drawing calls through the device context . The following simple OnDraw() example illustrates the process : <p> In this example , you would define the GetData() function as a member of your derived document class . <p> The example prints whatever string it gets from the document , centered in the view . If the OnDraw() call is for screen drawing , the CDC object passed in pDC is a CPaintDC whose constructor has already called BeginPaint() . Calls to drawing functions are made through the device-context pointer . <p> The CDocument class provides operations for adding and removing views from the document and functions to iterate through @ @ @ @ @ @ @ @ @ @ in mviewList and call the Update() method of the CView class . <p> Here are some code snippets for the class declaration of CDocument and CView : <p> Who triggers the update ? The document and its associated views rely on the notification mechanism to stay consistent . The MFC approach makes views responsible for calling UpdateAllViews() at the right time . <p> Dangling references to deleted subjects . Deleting a document should not produce dangling references in its views . The MFC approach ensures that documents are instantiated and deleted through the MFC class framework . The MFC framework will close and destroy all views before a document is destroyed . <p> The push and pull model . The MFC approach uses the push model : The document sends detailed information about the change ( a hint ) to all views , whether they want it or not . This approach works fine when a view triggers the update and other views understand the hint . If the document itself has to trigger an update , this method has the disadvantage that the document has to know implementation details @ @ @ @ @ @ @ @ @ @ we extended the push model concept . In the grid view class , We systematically separated user interactions and methods that update the display from methods which change data . Each method that updates the display is associated with an I 'd . This I 'd can be used as a hint to be sent among views . <p> For example , if the user does a specific interaction , such as typing text in a cell and moving the current cell , the view will call the SetStyleRange() operation in the grid to store the value of the current cell . All associated views have to update this cell . The grid-component uses the following scheme to keep all views up to date . As mentioned , a user interaction results in calling a command such as SetStyleRange() . For each command , the grid-component contains two further methods . One method ( which gets called once ) stores and actualizes the data . The other method ( which gets called for each view ) updates the display . Here we explain the scheme by example : <p> The command method @ @ @ @ @ @ @ @ @ @ : <p> SetStyleRange() calls the update method UpdateStyleRange() , telling the method to create a hint and send it to the document . UpdateStyleRange() updates the window and creates a hint . Each update method in the grid is associated with an integer i 'd . This integer is is used as hint and will be sent together with some additional information to all views . The hint is sent to the document by calling CDocument : : UpdateAllViews() . <p> CDocument : : UpdateAllViews() sends the hint to all associated views by calling CView : : OnUpdate() . Each view analyzes the hint I 'd and calls the corresponding update-method telling the method not to create a hint . The update method decides depending on the specific context of the view how to update the view . The integer-id will be used to call the appropriate update method in the view . Note that the bCreateHint parameter will be passed as FALSE to avoid an infinite recursion . 50236 @qwx670236 
@@75678084 @4378084/ <h> 12.6 Using Custom Allocators <p> The STL and STL extension-based classes now accept an additional template allocator argument . The allocator argument has a default value of std : : allocator&lt;T&gt; derived from the Standard C++ Library . <p> The use of custom allocators depends on the ANSI compliance of your compiler and your Standard C++ Library implementation . If allocators can be used , you can also provide your own allocator to customize memory management in an application . <p> In order to provide your own class template as an allocator , the template must conform to the particular interface described by the Standard C++ Library . This consists of member functions and typedefs as well as their syntactic and semantic requirements . <p> The example below defines a simple custom allocator . This can be used to test your compiler or the Standard C++ Library 's support for custom allocators . It checks if the allocator argument that is passed in the code is actually used : <p> Creating a RWTValDlist with a default allocator Inserting 100 items Creating a RWTValDlist with myallocator type used myallocator @ @ @ @ @ @ @ @ @ @ to allocate at address 0080AC08 ( + ) Inserting 100 items used myallocator to allocate at address 0080AC40 ( + ) used myallocator to allocate at address 0080AC78 ( + ) used myallocator to allocate at address 0080C6F0 ( + ) used myallocator to allocate at address 0080C728 ( + ) used myallocator to allocate at address 0080FB28 ( + ) used myallocator to allocate at address 00820068 ( + ) used myallocator to deallocate at address 00820068 ( - ) used myallocator to deallocate at address 0080FB28 ( - ) used myallocator to deallocate at address 0080C728 ( - ) used myallocator to deallocate at address 0080C6F0 ( - ) used myallocator to deallocate at address 0080AC78 ( - ) used myallocator to deallocate at address 0080AC40 ( - ) used myallocator to deallocate at address 0080AC08 ( - ) used myallocator to deallocate at address 0080ABD0 ( - ) <p> In the output listed above , it can be seen that , when no custom allocator was used , the RWTValDist was created and 100 items were inserted . However , when the list was instantiated with myallocator @ @ @ @ @ @ @ @ @ @ and deallocations of heap memory . This proves that the example used myallocator for memory management . 
@@75678085 @4378085/ <p> RWDBDateTime represents a date stored as a Julian day number , plus a time stored as the number of milliseconds since midnight . The member function isValid() can be used to determine whether an RWDBDateTime is a valid date and time . Note that RWDBDateTime is instantiated from the local system and not the database . <p> RWDBDateTime instances can be converted to and from RWDate and/or RWTime instances , and to and from the Standard C library type struct tm defined in &lt;time.h&gt; . <p> Output formatting is done using an RWLocaleobject . The default locale formats data according to US conventions . See the Tools.h++ Class Reference for further discussion of RWLocale . <p> Because the default constructor for this class creates an instance holding the current date and time as provided by the local system , constructing a large array of RWDBDateTimes may be quite slow . If this is an issue , declare your arrays with a class derived from RWDBDateTime that provides a faster constructor . <p> The default constructor creates an instance holding the current date and time . Note that RWDBDateTime @ @ @ @ @ @ @ @ @ @ . The millisecond part of self is set to zero . <p> Constructs an RWDBDateTime from the tmyear , tmmon , tmmday , tmhour , tmminute , and tmsec components of tm , with milliseconds = 0 . These components are understood to be relative to the time zone , zone , which defaults to local time . Note that the numbering of months and years in a structtm differs from numbering in RWDBDateTime arguments . <p> Constructs an RWDBDateTime for the given date , extracting the time from the string str . The time is understood to be relative to the time zone , zone , which defaults to local time . The specified locale is used for formatting information . You can use isValid() to check the results . <p> Returns self as a string , formatted by the given locale , with the time zone adjusted according to the given zone . The valid values for format are as defined by RWLocale . The default format is ' 0 ' , which is the same as ' x X ' . See RWLocale in the Tools.h++ Class @ @ @ @ @ @ @ @ @ @ RWCString asString ( const char *format ) const ; <p> Returns LONG ... See the description of the following asString() function . <p> Returns self as a string , formatted by the given locale , with the time zone adjusted according to the given zone . The format string may consist of any sequence of characters containing single formats as defined by RWLocale . Preceding a single format character with a % escapes the character for inclusion in the resulting string . The default format is the date followed by the time : x X. See RWLocale in the Tools.h++ Class Reference for a complete listing of possible formats . <p> Returns with the tm argument filled out entirely , with tmisdst set to -1 . Note that the encoding for months and days of the week used in struct tm differs from that used in RWDBDateTime . If self is invalid , all fields in tm are set to -1 . <p> unsigned firstDayOfMonth() const ; <p> Returns the day of the year ( 1 - 366 ) corresponding to the first day of self 's month . <p> @ @ @ @ @ @ @ @ @ @ the day of the year ( 1 - 366 ) corresponding to the first day of the given month ( 1 - 12 ) in self 's year . <p> unsigned hash() const ; <p> Returns a suitable hashing value . <p> unsigned hour ( const RWZone&amp; zone = RWZone : : local() ) const ; <p> Returns the hour part of self , adjusted to the given time zone . <p> unsigned hourGMT() const ; <p> Returns self 's hour in UTC ( GMT ) . <p> RWBoolean isDST ( const RWZone&amp; zone = RWZone : : local() ) const ; <p> Returns TRUE if self is during daylight-saving time in the specified time zone , otherwise returns FALSE . <p> RWBoolean isEqual ( const RWDBDateTime&amp; dt ) const ; <p> Returns TRUE if compareTo ( this , &amp;dt ) == 0 , otherwise returns FALSE . <p> RWBoolean isValid() const ; <p> Returns TRUE if self represents a valid date and time , otherwise returns FALSE . 
@@75678086 @4378086/ <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvFilledLabelMatrixItem . <p> The matrix to which the item belongs . This parameter is used to compute the matrix item palette . <p> label <p> The matrix item label . <p> copy <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvFilledLabelMatrixItem . <p> The inverted palette used by the matrix item when it is selected . When using other constructors , the inverted palette is automatically computed from the matrix item palette . <p> copy <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by @ @ @ @ @ @ @ @ @ @ file input . It reads the information that was saved by the member function write to be able to create a new instance of this object . Usually , because of the availability of the constructor that expects an IlvInputFile , readItem should be equivalent to : <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvAbstractMatrixItem. 
@@75678087 @4378087/ <p> Youve embraced open source and your organization benefits from using accessible code to accelerate delivery cycles and get to innovation faster . However , open source is often thought of as being unsupported or lacking in timely support due to its community-based foundation . We can help . Fixing open source issues with us is just as easy as contacting the support line for any commercial product . <p> OpenLogic supports hundreds of the most popular open source packages , including Apache Web Server , Active MQ , JBoss , CentOS Linux , Tomcat , Wildfly , and MySQL . Acting as an insurance policy , OpenLogic provides your development team with access to Tier 4 open source architects at any time , for any question or issue . And it 's not just technical support , our architects are true experts across the stack , offering skills and experience to optimize performance , complete system upgrades , perform security and architecture reviews , hold on-site classroom training , and much more . <p> You can customize support to ensure the right level and access that your teams @ @ @ @ @ @ @ @ @ @ service level agreements to keep enterprise production applications up and running <p> Silver Support provides expert support on the configuration , integration , and use of open source software as well as recommendations for open source packages based on use case <h> Open Source Support options <p> Silver <p> Gold <p> Hours <p> 12x5 ( Business Hours ) <p> 24x7 ( Production - around the clock ) <p> Service Level Agreement <p> 4-Hour Response <p> 1-Hour Response <p> Problem Submission <p> Phone / Email / Online <p> Phone / Email / Online <p> Supported Packages <p> Hundreds of Open Source Packages CentOS Linux <p> Hundreds of Open Source Packages CentOS Linux <p> Number of Named Contacts <p> Unlimited <p> Unlimited <p> Number of support cases <p> Unlimited <p> Unlimited <p> Our enterprise-class open source support gives organizations one place to resolve open source issues , eliminating expensive component-level contracts that do n't address the complex integrations between open source packages . We solve the problem whether it originates in one open source package or is the result of complex interactions between multiple packages . Our experienced technical staff serves as @ @ @ @ @ @ @ @ @ @ source across hundreds of open source packages . <h> Support services for PHP <p> Zend support services allow you to develop , deploy , and manage your PHP applications with confidence . With both production and developer-level options , you get the flexibility needed to cover everything from technical issues within your IDE to 24x7 phone support for mission-critical issues . 
@@75678088 @4378088/ <p> Reads an object description from the file input . It reads the information that was saved by the member function write to be able to create a new instance of this object . Usually , because of the availability of the constructor that expects an IlvInputFile , readItem should be equivalent to : <p> A Boolean value specifying whether a label should be copied . If the value is IlFalse , then you must allocate some memory for the label because in any case the label characters are deleted from the memory by the IlvAbstractMatrixItem. 
@@75678089 @4378089/ <h> 2.3 File Locations <p> There are two main directory trees associated with Rogue Wave libraries : <p> Product installation locations ( parts directory tree ) <p> Product build locations ( workspaces directory tree ) <p> Software Parts Manger requires that you specify a Rogue Wave root directory . The product installation and build directory trees are located below this system location , which this guide indicates as &lt;rwroot&gt; . <p> Products are installed in the parts directory below &lt;rwroot&gt; . Each product has its own product tree within parts , beginning at a directory named with the official Rogue Wave product mnemonic , a three-digit version number , and a one-letter operating system designator . In the above figure , this consists of tls for Tools.h++ , nnn for the version number , and w for Windows ( the other possibility being u for Unix ) . <p> Within the product tree , there is a source directory that contains , in the simplest case , an etc directory holding files used by Software Parts Manager in the generation of makefiles , and a src directory containing the @ @ @ @ @ @ @ @ @ @ the library header files . For some products , there may be subdirectories below source for divisions of the product , but at the end of any branch there is always an etc and src directory pair . <p> Also within the product tree is an examples directory containing the source , header , and makefile support files for examples supplied with the product . The structure is similar to that of the source directory . <p> The docs directory contains at least the product readme file , and may contain other informational text files . It is always a good idea to have a look at any files placed in this directory . <p> Product builds take place in a workspace , and it is here you will find all the support files used by Software Parts Manager in the build and the resulting library and object files . Figure 2 shows a workspace containing the results of two library builds , for Tools.h++ and Threads.h++ . <p> Within the workspaces directory under &lt;rwroot&gt; , Software Parts Manager creates a workspace for each combination of operating system , compiler @ @ @ @ @ @ @ @ @ @ or more libraries . The example shows that there would be two separate workspaces for MSVC 5.0 builds on Windows 95 using the build types 3s and 6d . ( See Section 4.1 for an explanation of build types . ) <p> Maintaining a separate workspace for each unique build configuration avoids confusion among library builds . It also provides a central location for all the resources you need to build applications that depend on some combination of libraries and a particular build configuration . <p> The lib directory contains all the compiled libraries . See the Software Parts Manager online help for an explanation of library naming conventions . This directory also contains the build record for each build , saved under &lt;product name&gt;.rec , such as tools.rec for Tools.h++ . <p> The top level of the rw directory contains the header files for Tools.h++ -- assuming you have built this library , which is a pretty sure bet -- and two important support files : <p> config.dat -- A data file containing important information about the capabilities of your compiler . This file is generated by a script @ @ @ @ @ @ @ @ @ @ used for a particular build configuration . <p> compiler.h -- A header file containing compiler-specific settings and required for building Tools.h++ . <p> The rw directory also contains a subdirectory for each product whose library you have built in the workspace , containing the product 's header files . The one exception is Tools.h++ , whose header files are in the main rw directory . For Tools.h++ there is a stdex subdirectory , which contains Standard C++ Library-related header files . <p> The buildloc directory is where the builds themselves take place . There is a subdirectory for each built product , named with the official Rogue Wave product mnemonic , a three-digit version number , and a one-letter operating system designator . For Tools.h++ in the above example , this consists of the Tools.h++ mnemonic tls , nnn for the version number , and w for Windows ( the other possibility being u for Unix ) . Look in buildloc for the object files generated in the build and the makefile used by Software Parts Manager . <p> Normally , the source code remains in the product tree . @ @ @ @ @ @ @ @ @ @ Parts ManagerBuild dialog allows you to copy the source code to the workspace , in which case it goes into the product directory under buildloc . <p> The examples directory contains a subdirectory for each product whose examples you have built , with that subdirectory containing the source code , makefile , and resulting executables . For some products , the product subdirectory within examples may contain additional subdirectories for different example sets . 
@@75678090 @4378090/ <h> JViews <p> Demand for highly sophisticated , business-oriented graphical user interfaces ( GUIs ) that display mass amounts of data in great details and in real time is a requirement for many organizations . For many of these organizations and applications , text and numbers are n't enough . You need to see data displayed graphically to be able to quickly comprehend its meaning . Representing data graphically in charts , diagrams , and maps helps you understand the complex information , and allows you to respond to rapidly changing events . <p> JViews provides the industrys most comprehensive set of graphics tools for creating sophisticated highly-interactive , highly-graphical , and high-performance displays . <h> JViews Maps for Defense <p> Derived from the JViews Maps product , it adds domain-specific functionality for military programs . Create custom military command-and-control applications using high performance 2D and 3D map representations and data-aware symbols for handling position and status in real-time . 
@@75678092 @4378092/ <h> AEROMEXICO Flies High With New eCommerce Platform <p> Mexico City " 8/30/2016 <p> Akana , a leading provider of API Management , API security , and Microservices solutions , announced today that Aeromexico , Mexico 's global airline , has launched a new eCommerce platform that includes Akana 's API management platform as a core component . Akana enables Aeromexico to be more agile by facilitating secure and manageable application programming interfaces ( APIs ) . <p> Aeromexico is launching the e-commerce in conjunction with its all-new website , aiming to provide the best digital experience of any Latin American carrier , and part of the total digital transformation of the airline , which serves 45 destinations within Mexico , 17 in the US , 15 in Latin America , 4 in Europe , 3 in Canada and 2 in Asia . <p> The platform , which the airline integrated in only nine months , includes all-new front-end and middleware components that integrate into its existing back-end . The platforms secure and scalable APIs power both its new website and new airport check-in kiosks . Aeromexico delivered the @ @ @ @ @ @ @ @ @ @ time by 50% and increasing the number of customers being checked in without the need to be assisted by a person . <p> Built on the foundation of the Akana API Management platform that provides enhanced visibility , scale and secure integration capabilities , Aeromexico now has a business and technology platform that allows it to leapfrog ahead in its ability to support its customers - critical at a time which A.T . Kearney described as a " tipping point " for e-commerce in Mexico , demanding world-class experiences . <p> Benjamin Hernandez , CIO of Aeromexico , said , " Akana has allowed us to come to market quickly with our API , which is a critical component of our digital strategy . With our robust API powering the business rules we were able to deliver our customers fantastic new experiences both at the new check-in kiosks and on the new website in parallel and with quick time-to-market . And this is just the beginning - there are many more proprietary and third-party integrations to come , including emerging channels such as mobile OS push notifications and chatbots . @ @ @ @ @ @ @ @ @ @ of our partnership pay off with such a strategic platform launch , " said Roberto Medrano , Executive Vice President of Akana . " We are excited to be working with such a forward-looking company as Aeromexico in its transformation into a digital enterprise . " <h> About Grupo Aeromexico <p> Grupo Aeromexico , S.A.B. de C.V . is a holding company whose subsidiaries are engaged in commercial aviation in Mexico and the promotion of passenger loyalty programs . Aeromexico , Mexicos global airline , operates more than 600 daily flights and its main hub is in Terminal 2 at the Mexico City International Airport . Its destinations network features more than 80 cities on three continents , including 45 destinations in Mexico , 17 in the United States , 15 in Latin America , four in Europe , three in Canada and two in Asia . The Groups fleet of about 130 aircraft is comprised of Boeing 787 , 777 and 737 jet airliners and next generation Embraer 145 , 170 , 175 and 190 models . In 2012 , the airline announced the most significant investment strategy in @ @ @ @ @ @ @ @ @ @ including 90 MAX B737 jet airliners and 10 B787-9 Dreamliners . <p> As a founding member of SkyTeam , the airline alliance which this year celebrates its 15th anniversary , Aeromexico offers customers more than 1,000 destinations in 179 countries served by the 20 SkyTeam airline partners rewarding passengers with benefits including access to 636 premium airport lounges around the world . Aeromexico also offers travel on its codeshare partner flights with Delta Air Lines , Alaska Airlines , Avianca , Copa Airlines and Westjet with extensive connectivity in countries like the United States , Brazil , Canada , Chile , Colombia and Peru . <h> About Rogue Wave Software <p> The largest independent provider of cross-platform software development tools and embedded components in the world . Through decades of solving the most complex problems across financial services , telecommunications , healthcare , government , academia , and other industries , Rogue Wave tools , libraries , and services enable developers to write better code , faster . 
@@75678093 @4378093/ <p> Both the server and the client maintain classes that encapsulate data and functionality . The original object 's data is transferred to the client and used to create a copy . In effect , the object is passed between processes by value . After the transfer , the sender and receiver side each own an object of that class . <p> The Streams package starts with byte streams or character streams , and then moves up to data streams . Object streams are the next level in the hierarchy above data streams . Many of these streams can be chained together to provide independent control at multiple levels of abstraction . Chaining is key to the Streams package architecture ( see Section 3.4 , " Streams Package Architecture . " ) <p> Although the classes RWObjectOutputStream and RWObjectInputStream are part of the Serialization package , they are actually part of the Streams package architecture , as shown in Figure 21 and Figure 22 . The relationship between the object streams and the Streams package is the same as the relationship between Java object streams and Java data streams @ @ @ @ @ @ @ @ @ @ the handle-body pattern . This means that the classes RWObjectOutputStream and RWObjectInputStream , the handle classes , are intended to be used as-is . Object streaming behavior is extended and customized by deriving from the classes in the RWObjectOutputStreamImp and RWObjectInputStreamImp hierarchies , the body classes . Use of the handle-body pattern for streams means that they can be used as automatic variables ( on the stack ) and as instance variables without worrying about dynamic memory management . 50235 @qwx670235 
@@75678094 @4378094/ <h> 2.3 Abstract and Concrete Classes <p> This section highlights some common points among the classes in the Essential Tools Module . <p> The Essential Tools Module provides implementation , not policy . Hence , it consists mostly of a large and rich set of concrete classes that are usable in isolation and independent of other classes for their implementation or semantics . They can be pulled out and used just one or two at a time . Concrete classes are the heart of the Essential Tools Module . <p> The Essential Tools Module also includes a rich set of abstract base classes , which define an interface for persistence , internationalization , and other issues , and a number of implementation classes that implement these interfaces . <p> Some Essential Tools Module classes are further categorized as collection classes , or collections , as explained in Section 2.2.4 . <p> Collection classes generally follow the Smalltalk naming conventions and semantical model : SortedCollection , Dictionaries , Bags , Sets , and so on . They use similar interfaces , allowing them to be interchanged easily . The template-based @ @ @ @ @ @ @ @ @ @ collections require that all collected items inherit from RWCollectable . <p> Choosing which collection classes to use in your programs is not a trivial task . Appendix A can help you decide which class is the best for your purposes . The Classes Class Hierarchy tab of the SourcePro C++ API Reference Guide shows the class hierarchy of all the public Essential Tools Module classes . In addition to these public classes , the Essential Tools Modulecontains other classes for its own internal use . <p> The Essential Tools Module provides a rich set of lightweight simple classes . By lightweight , we mean classes with low-cost initializers and copy constructors . These classes include RWDateTime for dates and times , with support for various time zones and locales ) , RWCString ( for single and multibyte strings ) , and RWWString ( for wide character strings ) . Most instantiations of these classes can be stored in four bytes or less , and have very simple copy constructors ( usually just a bit copy ) and no virtual functions . The SourcePro C++ API Reference Guide provides additional information @ @ @ @ @ @ @ @ @ @ templates , give you the advantages of speed and type-safe usage . When templates are used sparingly , their code size can be quite small . When templates are used with many different types , however , their code size can become large because each type effectively generates a whole new class . If you have the C++ Standard Library , you can use the Essential Tools Module template-based collections that are based on the C++ Standard Library . If you do not have the C++ Standard Library , you can use a subset of the templates , described in Section 6.9.1 and Section 6.14 . <p> The Essential Tools Module includes a set of abstract base classes and corresponding specializing classes that provides a framework for many issues . The list below identifies some of these issues and associates them with their respective abstract base classes . The description of each class in the SourcePro C++ API Reference Guide indicates whether it is an abstract base class . 50235 @qwx670235 
@@75678096 @4378096/ <h> class CGXStyle : public CObject <p> The CGXStyle class contains all the information necessary for formatting a cell . A style consists of several attributes such as the text color , borders , control type and font attributes . All of these styles can be modified by the end user via the CGXStyleSheet dialog . <p> A very important feature of CGXStyle is its support for combining style objects . For example , you can copy only those attributes from one style to another style which are not initialized in the other style . Objective Grid uses this feature to enable a kind of inheritance . By specifying a base style , you can tell Objective Grid that it should inherit attributes from a base style at run time . <p> Base styles make it possible to group specific kinds of cells and make them have similar attributes . The predefined base styles are : row-header-style , column-header-style and standard-style . Row header cells inherit their attributes from row-header-style . Column headers inherit from column-header-style . Standard-style is the base style for all cells in the grid . @ @ @ @ @ @ @ @ @ @ include-bit . This include-bit is TRUE when an attribute is initialized and FALSE if the attribute is not initialized . When drawing the grid , Objective Grid fills up all uninitialized attributes of the cells style object with the base styles attributes . If the GetInclude ... methods return FALSE , Objective Grid will try to initialize this attribute with the base styles setting . If GetInclude ... methods return TRUE , the specific setting will be used for drawing . <p> CGXStyle also supports user-defined style attributes . You can extend the CGXStyle class with additional attributes . The end user can change these attributes through the CGXStyleSheet . Each CGXStyle object maintains a map of user attributes and provides a method to change their values . See the CGXStylesMap class for registering user-defined attributes . <p> The following attributes are provided by the CGXStyle class : <p> Value with the cells text . <p> Control I 'd . <p> Base Style . <p> Text Color . <p> Cell Pattern and color as LOGBRUSH object . <p> Borders with LOGPEN objects . <p> Font as a CGXFont object . <p> @ @ @ @ @ @ @ @ @ @ state ( disabled cells can not become the current cell ) . <p> Auto-size feature ( this allows a cell to grow automatically when the user enters large text ) . <p> Maximal Length of the text . <p> 3d-effect ( raised , inset , normal ) . <p> Vertical Scrollbar specifies if a multiline edit control should display a vertical scrollbar . <p> Wrap Text ( also known as Wordbreak ) . <p> Allow Enter specifies if the edit control should insert a newline when the user presses ENTER . <p> Choice List specifies the alternatives for a combo box , list box , radio buttons or the pushbutton or check box text . <p> TriState property for check boxes . <p> User-defined item data pointer . <p> Each attribute is associated with four attribute methods . An example is the text color : 
@@75678097 @4378097/ <p> This customer , the largest health insurer in its state , was struggling with its payments APIs . Its inability to scale the APIs securely was hampering the processing of transactions at the more than $10 billion company . <p> A large U.S. bank is leveraging its financial power and stability by innovating existing positions in the FinTech space . As the fifth-largest commercial bank in the United States , the bank has prioritized the needs of partners and consumers by investing in competitive FinTech resources enthusiastically embracing a digital transformation . <p> In 2014 , a large bank performed an internal assessment to project necessary infrastructure changes . The teams challenge was to anticipate current and future market trends and opportunities . The banks resources focused on revenue strategy and tactical development to roll out profitable , new initiatives . Energy was directed into exploring successful channels for its core competencies . This action lead to creating a successful and profitable next generation digital payments platform for the strongest areas of the bank : Business and retail banking as well as wealth management . <p> The healthcare @ @ @ @ @ @ @ @ @ @ and expectations for broad interoperability take hold in the sector , many healthcare organizations are seeking to transform themselves into lean , innovative digital enterprises . For a large Midwest healthcare provider , this journey began in 2014 . They embarked on a transformation of their IT . <p> This Fortune 500 company offers a broad range of financial products and services to consumers , small businesses , and commercial clients . The bank wanted to create better end customer experiences with a suite of tools and technology to simplify their daily lives with services to help them manage money , credit , and identity , amongst other essential things . <p> This customer is a multi-national banking corporation with a long history of providing retail and investment banking services . The bank needed to find a way to develop new revenue channels and optimize existing channels , and realized that APIs provided a great vehicle to fulfill this business strategy . <p> Taking a disrupt , or be disrupted mindset , the bank realized that it needed to open up its banking applications for partners to use as an @ @ @ @ @ @ @ @ @ @ invested in a large deployment of IBM WebSphere DataPower appliances as the foundation of its enterprise-wide SOA infrastructure . Their challenge was to plan , design , develop , deploy , and then manage IT services in the SOA . Every stage of its SOA lifecycle required the proper tools , workflows , and automated integration to ensure that it could make services operational . To realize its SOA governance objectives , the company selected the Akana SOA governance solution for DataPower . <p> Skandia Nordic , a global insurance and banking company based in Sweden , began to expose system functionality as web services on the Microsoft platform in order to gain a single view of their customers . The effort was successful but the company quickly realized they needed a unified governance solution for the growing number of web services being built on BizTalk and WCF . Skandia selected Akana Service Manager and Policy Manager to achieve automated SOA governance . 
@@75678098 @4378098/ <p> A runnable object provides the basic mechanisms used to create , control , and monitor the threads of execution within your application . Runnables are used to define the task or activity to be performed by a thread . <p> Each runnable object is reference-counted ; a runnable body instance keeps a count of the number of handles that currently reference it . A runnable object is deleted when the last handle that references the body is deleted . <p> The public interface for a runnable is provided by its handle classes . Many of the public functions in a handle simply forward control to a corresponding protected function in the body class . A runnable handle class instance may be empty . Any attempt to use an empty handle to access a runnable will produce an RWTHRInvalidPointer exception . <p> The RWRunnableSelf class provides an interface for the thread executing inside of a runnable . It defines the runnable member functions that may only be executed by the internal thread . Threads executing outside of a runnable should access the runnable using the RWRunnable handle class . @ @ @ @ @ @ @ @ @ @ from either inside or outside of a runnable . <p> To retrieve an RWRunnableSelf handle instance for the current runnable , use the rwRunnable() function . You may also convert an RWRunnable handle to an RWRunnableSelf handle by calling the member RWRunnable : : getRunnableSelf() , but any attempt to violate the thread access restrictions imposed by the separate interfaces will generally result in an RWTHRIllegalAccess exception . <p> Returns an external interface handle bound to the same runnable instance ( if any ) pointed to by this handle . <p> RWRunnableSelf getNestedRunnable(void) const ; <p> Returns a handle to the nested runnable object , if any . Possible exceptions include RWTHRInvalidPointer and RWTHRInternalError . <p> void interrupt(void) ; <p> Interrupts the calling thread executing within the runnable until the runnable is released by another thread . Changes execution state to RWTHRINTERRUPTED . Possible exceptions include RWTHRInvalidPointer , RWTHRInternalError , and RWTHRIllegalAccess . <p> void **25;12496;TOOLONG ; <p> Checks for cancellation requests , throwing an RWCancellation object if cancellation has been requested , and returning otherwise . May result in a change of execution state to RWTHRCANCELING . Other possible @ @ @ @ @ @ @ @ @ @ RWBoolean serviceInterrupt(void) ; <p> Checks for interrupt requests , blocking the calling thread if an interrupt has been requested and returning immediately if no interrupt requests are pending . May result in a change of execution state to RWTHRINTERRUPTED . This function may only be called by an internal thread . Possible exceptions include RWTHRInvalidPointer , RWTHRInternalError , and RWTHRIllegalAccess . <p> void sleep ( unsigned long milliseconds ) ; <p> Causes the calling thread , executing within the runnable , to sleep for the specified time period yielding execution to other threads . Temporarily changes the execution state to RWTHRSLEEPING while sleeping , then restores the previous execution state . The global function rwSleep() may be used instead of this function , but rwSleep() does not produce any execution state changes in a runnable instance while this member does . Possible exceptions include RWTHRInvalidPointer , RWTHRInternalError , and RWTHRIllegalAccess . <p> void yield(void) ; <p> Causes the calling thread , executing within the runnable , to yield execution to other threads . Temporarily changes the execution state to RWTHRYIELDING , and then restores the previous execution state . The @ @ @ @ @ @ @ @ @ @ , but rwYield() does not produce any execution state changes in a runnable instance while this member does . Possible exceptions include RWTHRInvalidPointer , RWTHRInternalError , and RWTHRIllegalAccess. 
@@75678100 @4378100/ <p> Constructs a matrix with a specified number of rows and columns . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . The RWUninitialized type is an enumeration type with only one value , rwUninitialized . The rwUninitialized argument is used to distinguish the last dimension size from an initial value . <p> RWGenMat ( unsigned m , unsigned n , T initval , Storage s=COLUMNMAJOR ) ; <p> Constructs a matrix with a specified number of rows and columns . Initializes each matrix element to initval . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> RWGenMat ( const T* dat , unsigned m , unsigned n , Storage s=COLUMNMAJOR ) ; <p> A matrix with m rows and n columns is constructed , using the data in the vector dat as initial data . A copy of dat is made . The vector dat must have at least n*m elements . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> A matrix with m @ @ @ @ @ @ @ @ @ @ in the vector v. The matrix is a new view of the same data as v , so no copy of the data is made . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . If the vector does not have length m times n , an exception of type MATXNUMBERPOINTS is thrown . <p> RWGenMat ( const RWGenMat&lt;T&gt;&amp; m ) ; <p> Copy constructor . The new matrix and the old matrix both view the same data . <p> RWGenMat ( const char *s , Storage s=COLUMNMAJOR ) ; <p> Constructs a matrix from the null terminated character string s . The format of the character string is the same as that expected by the global operator operator&gt;&gt; described in this entry . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> Constructs a matrix with m rows and n columns . Initialized with random numbers generated by r . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> A complex matrix is constructed from the @ @ @ @ @ @ @ @ @ @ part of the matrix equal to re and the imaginary part equal to im . A new copy of the data is made . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> Returns the result of applying the passed function to every element in the matrix . A function of type RWGenMat&lt;T&gt; : : mathFunType takes and returns a T. A function of type RWGenMat&lt;T&gt; : : mathFunType2 takes a T and returns an LONG ... For a description of this type , see rwnumerictraits&lt;T&gt; . <p> Returns an iterator that points to the element in the first row and first column of self . The optional storage specifier determines the order in which the iterator traverses the elements of the matrix ; the specifier is independent of the storage format of the matrix . A COLUMNMAJOR iterator proceeds down each column while a ROWMAJOR iterator proceeds along rows . <p> CAUTION:Binary difference and comparison operators between a ROWMAJOR iterator and a COLUMNMAJOR iterator have unpredictable results . <p> unsigned binaryStoreSize() const ; <p> Returns the number of bytes required to @ @ @ @ @ @ @ @ @ @ . <p> const RWMathVec&lt;T&gt; col ( int j ) const ; RWMathVec&lt;T&gt; col ( int j ) ; <p> Returns a vector that views a column of the matrix . <p> unsigned cols() const ; <p> Returns the number of columns of the matrix . <p> int colStride() const ; <p> Returns the stride to move through the data from one column to the next . Could be computed as &amp;A ( i , j+1 ) -&amp;A ( i , j ) . <p> T* data() ; const T* data() const ; <p> Returns a pointer to the start of a matrix 's data . Should be used with care , as this function accesses the matrix 's data directly . <p> Returns a copy with distinct instance variables . The function copy() is a synonym for deepCopy().The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> void **25;12523;TOOLONG s=COLUMNMAJOR ) ; <p> Invoking deepenShallowCopy() for a matrix guarantees that there is only one reference to that object and that its data are in contiguous storage . The optional storage indicator determines whether @ @ @ @ @ @ @ @ @ @ <p> Returns an iterator that points to one element past the last element in the matrix . The optional storage specifier determines the order in which the iterator traverses the elements of the matrix ; the specifier is independent of the storage format of the matrix . A COLUMNMAJOR iterator proceeds down each column , while a ROWMAJOR iterator proceeds along rows . <p> CAUTION : Binary difference and comparison operators between a ROWMAJOR iterator and a COLUMNMAJOR iterator have unpredictable results . <p> Returns a matrix pick . The results can be used as an lvalue . You can think of the " picked " submatrix as specifying an intersection of the rows listed in v1 and the columns listed in v2 . Before using this function , you must include the header file rw/math/matpick.h . <p> RWGenMat&lt;T&gt;&amp; **32;12550;TOOLONG m ) ; <p> Makes self a view of m 's data . The view currently associated with the matrix is lost . <p> void reshape ( unsigned m , unsigned n , Storage s=COLUMNMAJOR ) ; <p> Changes the size of the matrix to m rows and n columns @ @ @ @ @ @ @ @ @ @ undefined ; that is , they can be garbage , and probably will be . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> void resize ( unsigned m , unsigned n , Storage s=COLUMNMAJOR ) ; <p> Changes the size of the matrix to m rows and n columns , adding 0s or truncating as necessary . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . <p> Restores self from a virtual stream or an RWFile . The optional storage indicator determines whether the matrix is stored in ROWMAJOR or COLUMNMAJOR order . To use these functions with a user-defined type T , the corresponding operator &gt;&gt; must be defined : <p> Returns the stride required to move through the data from one row to the next . Could be computed as &amp;A ( i+1 , j ) -&amp;A ( i , j ) . <p> void saveOn(RWvostream&amp;) const ; void saveOn(RWFile&amp;) const ; <p> Stores self to a virtual stream , or in a binary format to an RWFile . If T is @ @ @ @ @ @ @ @ @ @ for RWvostream and/or RWFile . To use these functions with a user-defined type , the corresponding operator&lt;&lt; must be defined : <p> Returns a vector that views a slice of the matrix . The slice begins at element i , j and extends for n elements . The increment between successive elements in the vector is rowstride rows and colstride columns . For example , A.slice ( n-1,0 , n , -1,1 ) is a view of the diagonal from the bottom left to top right corners of the n x n matrix A. <p> Returns a matrix that views a slice of the matrix . The slice begins at element i , j and contains m rows and n columns . The increment between successive elements in the slice 's row is rowstr1 rows and colstr1 columns . The increment between successive elements in the slice 's column is rowstr2 rows and colstr2 columns . For example : <p> A.slice ( n-1,0 , n , n , -1,0 , 0,1 ) <p> returns a view of the n x n matrix A upside down . A more readable way @ @ @ @ @ @ @ @ @ @ matrix , with optional bounds checking . Bounds checking is enabled by defining the preprocessor macro RWBOUNDSCHECK before including the header file . All subscripting operators return a new view of the same data as the matrix being subscripted . An object of type RWRange or RWToEnd , the global object RWAll , or a character string may be substituted for an RWSlice . <p> Assignment operator with conventional meaning . There are two prototypes for each of the arithmetic assignment operators , one for matrix assignment and one for scalar assignment . For matrix assignment , the expression : <p> u += v ; <p> implies uij = uij + vij , while for scalar assignment , the same expression implies uij= uij + v. For operators that involve two matrices , the matrices must conform , that is , have the same number of rows and columns . <p> RWGenMat&lt;T&gt;&amp; operator*= ( const RWGenMat&lt;T&gt;&amp; A ) ; <p> If the optional compiler flag -DRWMATHMATRIXPRODUCT is used to build the library , this operator behaves differently than described above . If this flag is used , this operator post-multiplies @ @ @ @ @ @ @ @ @ @ the mathematical linear algebra sense . If self is a matrix with m rows and n columns and A is a matrix with n rows and p columns , self is resized to have m rows and p columns . <p> Only operator*= is affected by the optional compiler flag . The other assignment member operators remain the same as described above . <p> Returns TRUE if self and the argument are equivalent ( or not equivalent ) . That is , they must have the same number of rows as well as columns , and each element in self must equal the corresponding element in the argument . <p> operator **27;12584;TOOLONG ( ) ; <p> Implicit conversion operator to rwnumerictraits&lt;T&gt; : : promotetype . For a description of the promotetype , see rwnumerictraits&lt;T&gt; . <p> Performs the conventional operation , which is applied element-by-element . For instance , for matrices u , v , and w , the expression w=u+v implies wij = uij + vij . Therefore , operator* implies an element-by-element multiply , not the inner product . If you want the inner product , use global @ @ @ @ @ @ @ @ @ @ must conform , that is , have the same numbers of rows and columns , or an exception with value MATXMATSIZE occurs . If the library is compiled with the switch -DRWMATHMATRIXPRODUCT , operator* is changed as noted below . <p> The operator is defined only if both the library and your application files are compiled with the -DRWMATHMATRIXPRODUCT flag . When the compiler flag is used , these operators have conventional mathematical linear algebra meanings ; that is , the i , j element of the result of a matrix product A*B is the dot product of the ith row of A and the jth column of B. This means that the definition of operator* for two matrices is not element-wise multiplication as described above . If you want element-wise multiplication when this compiler flag is used , use the elementProduct() global function described in the Global Function Reference . <p> Conventional mathematical linear algebra multiplication operator ; that is , the i , j element of the result of a matrix product A%B is the dot product of the ith row of A and the jth column of @ @ @ @ @ @ @ @ @ @ operator is the same as operator* given above . <p> ostream&amp; operator&lt;&lt; ( ostream&amp; s , const RWGenMat&lt;T&gt;&amp; m ) ; <p> Outputs a matrix m to ostream s . First , the number of rows and columns is output , then the values , separated by spaces , are output row by row , beginning with a left bracket and terminating with a right bracket . <p> istream&amp; operator&gt;&gt; ( istream&amp; s , RWGenMat&lt;T&gt;&amp; v ) ; <p> Reads a matrix v from istream s . First , the number of rows and columns is read , then the matrix values , separated by white space , row-by-row . If the sequence of numbers begins with a left bracket , the operator reads to a matching right bracket . If no bracket is present , it reads to end of file . The matrix v is stored in COLUMNMAJOR order . 
@@75678102 @4378102/ <h> Development platforms , tools , and components <p> Rogue Wave delivers capabilities that help your team produce better code by simplifying all aspects of the development life cycle and reducing overall release times . Our products support multiple languages , platforms , and architectures to help you deliver software faster , easier , and with less risk . <p> Commercial PHP solutions and support for development leaders , DevOps , and developers . Zend Server with Z-Ray and Zend Studio improve application performance and quality , speed up release cycles , and mitigate risk . <p> Detect security , safety , and reliability issues in real-time by using this static code analysis toolkit that works alongside developers , finding issues as early as possible , and integrates with teams , supporting continuous integration and actionable reporting . <p> Simplify the display and analysis of complex business information by using these cross-platform C++ , Java , and Adobe and Apache Flex tools to create interactive , highly-graphical user interfaces , maps , graphs , schematics , and much more . <p> Protect access to legacy systems by using this @ @ @ @ @ @ @ @ @ @ , multiple concurrent sessions , and modernization of existing terminal-based applications through its AutoGUI feature . <p> Create the apps you want without spending time on the basics by using these enterprise-class , cross-platform C++ tools to build portable infrastructure code that you write once , and deploy to any platform . 
@@75678103 @4378103/ <p> This class maintains a collection of values , which are stored according to a hash object of type H. H must offer a const hash function for elements of type T via public member <p> unsigned long operator() ( const T&amp; x ) const ; <p> Objects within the collection will be grouped together based on an equality object of type EQ . EQ must ensure this grouping via public member <p> bool operator() ( const T&amp; x , const T&amp; y ) const ; <p> which should return true if x and y are equivalent , false otherwise . <p> Note : Any two keys that are equivalent must hash to the same value . <p> RWTValHashSet&lt;T , H , EQ&gt; will not accept an item that is equivalent to an item already in the collection . ( RWTValHashMultiSet&lt;T , H , EQ&gt; may contain multiple items that are equivalent to each other . ) Equality is based on the equality object and not on the == operator . <p> The value type must have operator== ( ) defined . This requirement is imposed by the Standard @ @ @ @ @ @ @ @ @ @ from the array of Ts pointed to by first , up to , but not including , the element pointed to by last . The underlying hash table representation will have sz buckets , will use h for its hashing function and will use eq to determine equality between elements <p> Returns true if self compares equal to s , otherwise returns false . Two collections are equal if both have the same number of entries , and iterating through both collections produces , in turn , individual elements that compare equal to each other . <p> If there exists an element t in self such that the expression ( ( *fn ) ( t , d ) ) is true , assigns t to k and returns true . Otherwise , returns false and leaves the value of k unchanged . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool insert ( constreference a ) ; <p> Adds the item a to the collection . Returns true if the insertion is successful , otherwise returns false . The function will @ @ @ @ @ @ @ @ @ @ the equivalent key . <p> Returns the number of elements t in self such that the expression ( ( *fn ) ( t , d ) ) is true . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> bool remove ( constreference a ) ; <p> Removes the first element t in self that compares equal to a . Returns false if there is no such element . <p> bool remove ( bool ( *fn ) ( constreference , void* ) , void* d ) ; <p> Removes the first element t in self such that the expression ( ( *fn ) ( t , d ) ) is true and returns true . Returns false if there is no such element . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> sizetype removeAll ( constreference a ) ; <p> Removes all elements t in self that compare equal to a . Returns the number of items removed . <p> sizetype removeAll ( bool ( *fn ) ( constreference , void* ) , @ @ @ @ @ @ @ @ @ @ self such that the expression ( ( *fn ) ( t , d ) ) is true . Returns the number of items removed . fn points to a user-defined tester function which must have prototype : 50232 @qwx670232 50233 @qwx670233 <p> void resize ( sizetype sz ) ; <p> Changes the capacity of self by creating a new hashed set with a capacity of sz . resize copies every element of self into the new container and finally swaps the internal representation of the new container with the internal representation of self . <p> rwhashset&lt;T , H , EQ&gt;&amp; std() ; const rwhashset&lt;T , H , EQ&gt;&amp; std() const ; <p> Returns a reference to the underlying collection that serves as the implementation for self . This reference may be used freely , providing access to the C++-standard interface as well as interoperability with other software components that make use of the C++-standard collections . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to @ @ @ @ @ @ @ @ @ @ off the heap , then you are responsible for deleting it . 
@@75678105 @4378105/ <p> If you associate an expression with a watchpoint ( by selecting the Conditional button in theWatchpoint Properties dialog boxentering an expression ) , TotalView evaluates the expression after the watchpoint triggers . The programming statements that you can use are identical to those used when you create an eval point , except that you ca n't call functions from a watchpoint expression . <p> The variables used in watchpoint expressions must be global . This is because the watchpoint can be triggered from any procedure or scope in your program . <p> TotalView has two variables that are used exclusively with conditional watchpoint expressions : <p> $oldval <p> The value of the memory locations before a change is made . <p> $newval <p> The value of the memory locations after a change is made . <p> The following is an expression that uses these values : <p> if ( iValue ! = 42 &amp;&amp; iValue ! = 44 ) <p> iNewValue = $newval ; iOldValue = $oldval ; $stop ; <p> When the value of the iValue global variable is neither 42 nor 44 , TotalView stores the @ @ @ @ @ @ @ @ @ @ variables . These variables are defined in the program . ( Storing the old and new values is a convenient way of letting you monitor the changes made by your program . ) <p> The following condition triggers a watchpoint when a memory location 's value becomes negative : <p> if ( $oldval &gt;= 0 &amp;&amp; $newval &lt; 0 ) $stop <p> And , here is a condition that triggers a watchpoint when the sign of the value in the memory location changes : <p> if ( $newval * $oldval &lt;= 0 ) $stop <p> Both of these examples require that you set the Type for $oldval/$newval field in the Watchpoint Properties Dialog Box . <p> If a watchpoint has the same length as the $oldval or $newval data type , the value of these variables is apparent . However , if the data type is shorter than the length of the watch region , TotalView searches for the first changed location in the watched region and uses that location for the $oldval and $newval variables . ( It aligns data in the watched region based on the size of @ @ @ @ @ @ @ @ @ @ data type is a 4-byte integer and byte 7 in the watched region changes , TotalView uses bytes 4 through 7 of the watchpoint when it assigns values to these variables . ) <p> For example , suppose you 're watching an array of 1000 integers called mustbepositive , and you want to trigger a watchpoint as soon as one element becomes negative . You declare the type for $oldval and $newval to be int and use the following condition : <p> if ( $newval &lt; 0 ) $stop ; <p> When your program writes a new value to the array , TotalView triggers the watchpoint , sets the values of $oldval and $newval , and evaluates the expression . When $newval is negative , the $stop statement halts the process . <p> This can be a very powerful technique for range-checking all the values your program writes into an array . ( Because of byte length restrictions , you can only use this technique on Solaris . ) <p> NOTE &gt;&gt; On all platforms except for IBM AIX , TotalView always interprets conditional watchpoints ; it never compiles them @ @ @ @ @ @ @ @ @ @ process or thread that writes to the watched location must wait for other instances of the watchpoint to finish executing . This can adversely affect performance . 
@@75678106 @4378106/ <p> Iterators are a generalization of pointers that allow a C++ program to uniformly interact with different data structures . The illustration below displays the five iterator categories defined by the standard library , and shows their heirarchical relationship . Because standard library iterator categories are hierarchical , each category includes all the requirements of the categories above it . <p> Because iterators are used to traverse and access containers , the nature of the container determines what type of iterator it generates . And , because algorithms require specific iterator types as arguments , it is iterators that , for the most part , determine which standard library algorithms can be used with which standard library containers . <p> To conform to the C++ standard , all container and sequence classes must provide their own iterators . An instance of a container or sequence 's iterator may be declared using either of the following : <p> class name : : iterator <p> class name : : constiterator <p> Containers and sequences must also provide const iterators to the beginning and end of their collections . These may be @ @ @ @ @ @ @ @ @ @ <p> The semantics of iterators are a generalization of the semantics of C++ pointers . Every template function that takes iterators will work using C++ pointers for processing typed contiguous memory sequences . <p> Iterators may be constant or mutable depending upon whether the result of the operator* behaves as a reference or as a reference to a constant . Constant iterators can not satisfy the requirements of an outputiterator . <p> Every iterator type guarantees that there is an iterator value that points past the last element of a corresponding container . This value is called the past-the-end value . No guarantee is made that this value is dereferencable . <p> Every function provided by an iterator is required to be realized in amortized constant time . 
@@75678107 @4378107/ <h> CGXGridCore : : RegisterControl <p> Specifies a unique I 'd for the control . This I 'd should be a string-resource-id . The string-resource should contain the name of the control to be displayed in the control-listbox of the control-page in the style-sheet . <p> pControl <p> Points to the control to be registered . The control can be any class derived from CGXControl . <p> bDefault <p> Specifies if the default control should be set to this control . Only one control can be the default control . <p> bShowInStyleSheet <p> TRUEif the control shall be shown in the controls page in the CGXStyleSheet . FALSE if it should not be shown . <h> Remarks <p> Registers the CGXControl-object associated with a unique control-id . <p> If the i 'd is already associated with a control-object , the previous control object will be destroyed and replaced with the new control-object . <p> All of the above controls can be used automatically in the grid , because when you assign one of the above controls to a cell , GetRegisteredControl will instantiate and register the control automatically . GetRegisteredControl will call @ @ @ @ @ @ @ @ @ @ Take also a look at the Control Factory Wizard . This let 's you define what cell types should be available in your application . See the section " Reducing the size of your application " in the User 's Guide for more details . <p> To change the default behavior of these controls , you can subclass them and reassign an instance of the subclassed control by calling RegisterControl in OnInitialUpdate . <p> Take a look at the file GXCTRLI.H . This file contains all standard controls . You can create any control you like with these classes and use it in the grid . <p> Note : <p> All registered control instances will be deleted by Objective Grid when the grid object is deleted . <h> Example <p> This example illustrates how to register a bitmap as user-defined control . The user can assign this bitmap to any cell in the grid through the control-page of the style-sheet. 
@@75678108 @4378108/ <h> 13.1 Class RWDBOSql <p> As we discussed in Chapter 12 , Open SQL is a database-portable set of classes for directly executing SQL statements . In this chapter , we explore the Open SQL classes in more detail , and demonstrate how to use them within your DBTools.h++ applications . Of the three classes that form the Open SQL API , class RWDBOSql is most important . <p> Class RWDBOSql is the core of the Open SQL API . Fundamentally , using Open SQL involves four activities : <p> Class RWDBOSql is an encapsulation of an SQL statement . Creating an instance of RWDBOSql is simple enough . You just instantiate one as you would any other C++ object . If you know the SQL statement you want to use , you can provide it in the constructor . For example , if you want to use the statement " SELECT * FROM MYTABLE " , you write this code : <p> An RWDBOSql can encapsulate the SQL statement provided in the constructor . However , if you do n't know what statement you want to use when @ @ @ @ @ @ @ @ @ @ using the statement() method as shown here : <p> When using RWDBOSql , please note that the statement you provide must be valid syntax for the database against which you are executing . <p> NOTE : Your SQL statement must use the correct syntax for your database . <p> The goal of RWDBOSql is to provide a database-independent way of executing statements and processing results . No attempt is made , however , to normalize SQL grammars between databases . If you are writing an application that must work with relational data in a database-independent fashion , you should use the DML classes--RWDBSelector , RWDBInserter , RWDBDeleter , and RWDBUpdater--instead of directly executing SQL statements . <p> Once a statement is provided , executing the statement encapsulated by the RWDBOSql is as simple as calling its execute() method . This call takes as a parameter the RWDBConnection on which to execute the statement : <p> Let 's look at this example more closely . On //1 , we create an RWDBConnection , aConn , from an RWDBDatabase object created earlier in the program . ( For more information on this @ @ @ @ @ @ @ @ @ @ " ) This RWDBConnection encapsulates a single connection to our database . On //2 , we create an RWDBOSql instance to encapsulate our SQL statement , in this case , " INSERT INTO MYTABLE VALUES(10) " . On //3 , we use the execute function to execute this statement on aConn . When this function is invoked , the statement is prepared and immediately executed on our database through the connection aConn . <p> One significant difference between RWDBOSql and many other classes in DBTools.h++ is that its instances are not produced by any other object . You can create an instance of RWDBOSql any time , even before you connect to a database . You can pass instances of RWDBOSql within your application , even if you are not connected . Of course , when you want to invoke execute on your RWDBOSql , you must have a valid RWDBConnection on which to execute . <p> NOTE : You can create an RWDBOSql any time , but you must establish a valid database connection to execute the encapsulated SQL statement . <p> As we know , even valid SQL @ @ @ @ @ @ @ @ @ @ as loss of connectivity , invalid data , and myriad other errors can cause an otherwise good SQL statement to fail . Fortunately , checking the success or failure of an execution with Open SQL is straightforward : you follow the same RWDBStatus-based error model used in the standard DBTools.h++ API . ( See Chapter 8 , " The Error Model . " ) <p> With Open SQL , any error that occurs during execution causes the RWDBOSql instance to become invalid , and its status is changed to reflect the error . However , the RWDBOSql instance may still be reused ; it remains invalid only until the next successful execution . <p> Let 's see how error handling works with Open SQL . Using the DBTools.h++ error model , we can easily add in-line error checking to the previous code sample : <p> In //1-//3 , we execute the statement as in the previous example . On //4 , we use the isValid() method on the RWDBOSql ; here isValid() returns FALSE if the execution of the SQL statement fails . On //5 , we use the status() @ @ @ @ @ @ @ @ @ @ error , such as a printable error message , and error codes . Although the RWDBOSql is invalid at this point , we can choose to reinvoke execute() . If the re-execution succeeds , the RWDBOSql becomes valid again , so that calling isValid() on it returns TRUE . <p> Output binding and fetching are the mechanisms for retrieving results . <p> To use RWDBOSql for exchanging data with your database in either direction , you bind your own program variables to the statement ( for input binding ) , or to a result set ( for output binding ) . <p> To provide Open SQL with information about your program variables , you use the template class RWDBTBuffer . When you use RWDBTBuffer with RWDBOSql , your data is not converted unless absolutely necessary , and no internal copy of your data is made unless absolutely necessary . Avoiding these data conversions and internal copies can result in greater performance for Open SQL in comparison with the classes of the standard API , such as RWDBInserter and RWDBReader. 
@@75678110 @4378110/ <p> Class RWbostream specializes the abstract base class RWvostream to store variables in binary format . The results can be restored by using its counterpart RWbistream . <p> You can think of it as a binary veneer over an associated streambuf . Because the RWbostream retains no information about the state of its associated streambuf , its use can be freely exchanged with other users of the streambuf ( such as ostream or ofstream ) . <p> Note that variables should not be separated with white space . Such white space would be interpreted literally and would have to be read back in as a character string . <p> RWbostream can be interrogated as to the stream state using member functions good() , bad() , eof() , etc . <p> Construct an RWbostream from the streambufs . For DOS , the streambuf must have been opened in binary mode . <p> RWbostream ( ostream&amp; str ) ; <p> Construct an RWbostream from the streambuf associated with the output stream str . For DOS , the streambuf must have been opened in binary mode . This can be done by @ @ @ @ @ @ @ @ @ @ argument to the constructor for an ofstream . Using the example above , the line to create the ofstream would read , ofstream fstr ( " data.dat " , ios : : out ios : : binary ) ; where the " " is the binary OR operator . 
@@75678111 @4378111/ <p> RWDBExpr represents expressions used in constructing SQL statements . It allows the SQL to be constructed using C++ syntax . Because there are several types of expressions , this class is simply an interface to a family of implementations that can represent numeric and string constants , columns from tables , or other expressions . By its nature , an RWDBExpr can actually represent a complete complex expression in the form of a parse tree . <p> Because instances of this class are typically created anonymously , there are constructors taking the various operands used in expressions . These include the C++ primitive types , as well as the structured types used by DBTools.h++ , such as RWCString and RWDBColumn . <p> RWDBExpr is designed around the Interface/Implementation paradigm . An RWDBExpr instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . <p> In this example , an RWDBExpr is created anonymously to be used as part of an SQL SELECT statement . The intent is to create a selector that adds the value of the @ @ @ @ @ @ @ @ @ @ default constructor builds an empty RWDBExpr , that is , one whose asString ( const RWDBPhraseBook&amp; phraseBook ) method returns an SQL NULL keyword , as specified in phraseBook . Since an empty expression can not hold a value , RWDBExpr() can not be used as NULL value . <p> Creates an RWDBExpr from an RWDBValue . When the asString function is applied to this RWDBExpr , it passes the phraseBook on to the RWDBValue for interpretation . Passing FALSE for the usePhraseBook parameter suppresses this behavior . The effect of suppressing the use of the phraseBook is to prevent strings from being quoted and RWDBDateTimes from using the database 's designated format . <p> Creates an RWDBExpr from an RWDBSelector . This constructor supports the SQL subquery construct . <p> RWDBExpr ( RWDBValueManip manip ) ; <p> Creates an RWDBExpr according to the semantics of manip . In particular , an expression representing a literal NULL may be constructed from rwdbNull . <p> RWDBExpr ( const RWCollection&amp; collection ) ; <p> Creates an RWDBExpr that represents a delimited list of the items in collection . collection must be a @ @ @ @ @ @ @ @ @ @ entire period that the RWDBExpr can be referenced , since the expression is not expanded into a string until the expr.asString() method is called , which can happen long after you assign the collectable to the expression . <p> Returns an RWCString representing self as a string based on the format found in phraseBook . Normally , references to columns in self are represented in the string with table tags attached . Setting the value of control with RWDBExpr : : suppressTagsOnColumns prevents the tags from being included in the string . <p> Arithmetic operators may be applied to RWDBExpr instances to build complex RWDBExprs . Logical operators may be applied to produce an RWDBCriterion . <p> RWDBExpr operator+ ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a dyadic expression between two subexpressions with + ( plus ) as the operator . <p> RWDBExpr operator+ ( const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a monadic expression with + ( plus ) as the operator . <p> RWDBExpr operator- ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a dyadic @ @ @ @ @ @ @ @ @ @ the operator . <p> RWDBExpr operator- ( const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a monadic expression with the operator as - ( minus ) . <p> RWDBExpr operator* ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a dyadic expression between two subexpressions with * ( multiply ) as the operator . <p> RWDBExpr operator/ ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a dyadic expression between two sub-expressions with / ( divide ) as the operator . <p> RWDBExpr operator% ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBExpr representing a dyadic expression between two subexpressions with the % ( modulo ) operator . <p> RWDBCriterion operator&amp;&amp; ( const RWDBCriterion&amp; , const RWDBCriterion&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with &amp;&amp; ( and ) as the operator , if both operands are initialized . If only one operand is initialized , returns an RWDBCriterion representing a monadic expression . <p> RWDBCriterion operator ( const RWDBCriterion&amp; , const RWDBCriterion&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic @ @ @ @ @ @ @ @ @ @ operator , if both operands are initialized . If only one operand is initialized , returns an RWDBCriterion representing a monadic expression . <p> RWDBCriterion operator ! ( const RWDBCriterion&amp; ) ; <p> Returns an RWDBCriterion representing a monadic expression with the operator ! ( not ) . <p> RWDBCriterion operator== ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with the == ( equality ) operator . <p> RWDBCriterion operator ! = ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with the ! = ( inequality ) operator . <p> RWDBCriterion operator&gt; ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with the &gt; ( greater than ) operator . <p> RWDBCriterion operator&lt; ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with the &lt; ( less than ) operator . <p> RWDBCriterion operator&gt;= ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a @ @ @ @ @ @ @ @ @ @ than or equal to ) operator . <p> RWDBCriterion operator&lt;= ( const RWDBExpr&amp; , const RWDBExpr&amp; ) ; <p> Returns an RWDBCriterion representing a dyadic expression between two subexpressions with the &lt;= ( less than or equal to ) operator . <p> These functions may be applied to RWDBExpr instances to build RWDBExprs representing SQL functions.The SQL syntax for these functions typically varies among the various vendors ' implementations . DBTools.h++ hides the variations by providing the database-specific syntax at runtime . <p> DBTools.h++ also provides an extensible mechanism for applications to define their own functional notation . See RWDBExprFormDefinition for details . <p> RWDBExpr rwdbAvg ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> AVERAGE(expr) <p> RWDBExpr rwdbCast ( const RWDBExpr&amp; expr , const RWDBValue&amp; type ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> CHARACTERLENGTH(expr) <p> RWDBExpr rwdbCount ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : @ @ @ @ @ @ @ @ @ @ representing the database-specific equivalent of the SQL function : <p> COUNT(*) <p> RWDBExpr rwdbCountDistinct ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> COUNT DISTINCT ( expr ) <p> RWDBExpr rwdbCurrentUser ( ) ; <p> Returns an RWDBExpr representing the database-specific function that returns the name of the current user . <p> RWDBCriterion rwdbExists ( const RWDBSelectorBase&amp; select ) ; <p> Returns an RWDBCriterion representing the database-specific equivalent of the SQL expression **32;12640;TOOLONG . In this expression , &lt;select-statement&gt; is the SQL select statement encapsulated by select . <p> RWDBExpr rwdbLower ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> TOLOWER(expr) <p> RWDBExpr rwdbMax ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> MAX(expr) <p> RWDBExpr rwdbMin ( const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> MIN(expr) <p> RWDBExpr rwdbName ( const RWCString&amp; name , const RWDBExpr&amp; expr ) ; <p> Returns an RWDBExpr representing the @ @ @ @ @ @ @ @ @ @ For example , to encapsulate the SQL statement : <p> SELECT employeeName = name from employees <p> write : <p> mySelector &lt;&lt; rwdbName ( " employeeName " , employees " name " ) ; <p> RWDBExpr rwdbPosition ( const RWDBExpr&amp; expr1 , const RWDBExpr&amp; expr2 ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> POSITION ( expr1 , expr2 ) <p> The goal is to produce an SQL statement that gives the index of the string expr1 in expr2 . <p> RWDBExpr rwdbSessionUser() ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> SESSIONUSER() <p> The details of the SESSIONUSER() function are vendor-specific . <p> RWDBExpr rwdbSubString ( const RWDBExpr&amp; expr1 , const RWDBExpr&amp; expr2 ) ; <p> Returns an RWDBExpr representing the database-specific equivalent of the SQL function : <p> SUBSTRING ( expr1 , expr2 ) <p> The goal is to produce an SQL statement that gives the substring of expr1 starting at the index given by expr2. 
@@75678112 @4378112/ <h> 2017 Open Source Support Report <p> Open source software is leveraged for flexibility and innovation , but can seem impossible to support . Learn the statistics , realities , and results of open source in the field so you can innovate faster without the risk . Read the report . <h> PHP 7.1 Certification <p> The new Zend Certified Engineer ( ZCE ) 2017 PHP test course is now available , bringing the testing current to PHP 7.1 . ZCE is globally recognized as the industry standard for benchmarking and validating PHP expertise . Learn more . <p> Keep Up-to-date <h> About Rogue Wave <p> The largest independent provider of cross-platform software development tools , components , and platforms in the world . Through decades of solving the most complex problems across financial services , telecommunications , healthcare , government , academia , and other industries , Rogue Wave tools , components , platforms , and services enable developers to write better code , faster . 
@@75678113 @4378113/ <p> The same GUI can be connected to several databases managed by different connections . <p> Once connected , data updates from the data source are automatically reflected in the user interfaces controls . Likewise , changes in the user interface ( due to user interaction ) are transmitted back to the data . <p> Port across operating systems and across databases simply by recompiling . <h> Highly scalable modeling framework <p> Represent the elements and topology of a supervised system as shared in-memory services with Rogue Wave Server . Modeling abstractions match those offered by object-oriented design notation like UML , and Server bridges the gap between business model design and implementation . Because objects stored in the Server-based mediation server are active , all business events , such as object modifications and structural changes , are registered and buffered for forwarding to subscribing clients . 
@@75678114 @4378114/ <h> 9.2 Message Patterns in WSDL <p> HydraExpress determines the message pattern for a given operation by evaluating the pattern of input and output messages for the operation in the service WSDL file . Based on this analysis , it generates code appropriate to the message patterns being used . <p> This section discusses each message pattern , with an introduction to the WeatherSummary.wsdl that is used for illustration . It also includes a brief discussion on synchronous and asynchronous behavior as it relates to message patterns . <p> The Weather Summary service represents a centralized provider of weather condition data for some number of subscribers in some area . <p> A client subscribes ( or unsubscribes ) to receive area weather data , and receives a confirmation from the server . This interaction represents a request-response operation . <p> Subscribers can choose to send weather data to the service when local conditions change , using the one-way operation . <p> The service sends notifications of changed conditions to all subscribers through the notification operation . <p> Finally , when the service receives a subscription request , it uses @ @ @ @ @ @ @ @ @ @ reachable , using the result to determine whether the subscription request succeeds . <p> The operation subscribe contains an input message subscribe , which is the client request , and an output message subscribeResponse , which is the server response . The contents of these messages are then defined in the WSDL file 's message element : <p> The message subscribe contains three parts of type xsd:string that tell the service where and how to send messages . <p> The message subscribeResponse contains two parts , a status of type xsd:boolean indicating success or failure of the request , and a message string . <p> The implementation of this pattern occurs in the client-side WeatherSummaryClient.cpp , a sample implementation that uses the generated class in WeatherSummaryProxy.cpp , and in the server-side WeatherSummaryImp.cpp , the server implementation that receives the request and sends a response . <p> The message contains a complex type WeatherSummary element that provides updated weather conditions for the local area . The WeatherSummary type is defined by an embedded XML Schema in the types element of the WSDL file . See Section 6.3 , " Complex Data @ @ @ @ @ @ @ @ @ @ the client-side WeatherSummaryClient.cpp , a sample implementation that uses the generated class in WeatherSummaryProxy.cpp , and in the server-side WeatherSummaryImp.cpp , the server implementation that receives the request . <p> The message contains a WeatherSummary element with updated weather conditions for the zip code specified in the WeatherSummary element . <p> HydraExpress uses special notification architecture to support this pattern . This architecture is described in Chapter 13 . <p> This pattern is implemented on the server side by WeatherSummaryImp.cpp , which makes a call to the weatherNotification() operation method in the server-side notification proxy **35;12674;TOOLONG , and on the client side in **33;12711;TOOLONG , which sets up a listener on the client to receive the notification . <p> For an additional examples on the notification pattern , see Chapter 10 . <p> This is the response message from the client back to the server . If the request reaches the client , it simply responds with a boolean true . Otherwise , the server receives some kind of error and knows that the client could not be reached . <p> This operation is implemented on the server side in @ @ @ @ @ @ @ @ @ @ in **35;12746;TOOLONG to send the verification request to the client . On the client side , the client implementation WeatherSummaryClient.cpp sets up a listener and a notification class , implemented in **33;12783;TOOLONG , receives the notification message . <p> The request-response and the solicit-response patterns are generally synchronous , as their usage usually assumes that the requestor will receive an immediate response . <p> The one-way and the notification patterns are inherently asynchronous in that the requestor expects no response . <p> While one of the strengths of WSDL is that it allows any mix of message patterns and transports in a single service , it is important to be aware that the behavior of a service is tied to the type of transport being used . For example , an asynchronous service will not behave asynchronously if it is sent using a synchronous transport , such as HTTP . This is because HTTP requires a response as a receipt . Even if the C++ function calling the web service is multithreaded and returns before the response is received , the transport itself must block until the HTTP response is @ @ @ @ @ @ @ @ @ @ over the same channel . <p> For this reason , it may be wise to build one-way and notification messages asynchronously to avoid having the client block for a transport receipt . In addition , using the asynchronous methods for one-way and notification builds more responsiveness and adaptability into your program without much more complication . <p> For a general discussion on building services asynchronously , see Chapter 13 . <p> The Rogue Wave name and logo are registered trademarks of Rogue Wave Software , and HydraExpress is a trademark of Rogue Wave Software . All other trademarks are the property of their respective owners.Contact Rogue Wave about documentation or support issues . 
@@75678115 @4378115/ <p> The easiest way to create a thread with Threads.h++ is to begin with rwtMakeThreadFunction . By supplying a global or member function pointer you control what your thread will do after starting . If you wish your thread to start by calling a function that takes arguments , rwtMakeThreadFunction allows you to specify the values that should be passed to that function . Note that threads created with rwtMakeThreadFunction will ignore any return values from the associated function . To create threads from which you can extract a return value , see rwtMakeThreadIOUFunction . <p> rwtMakeThreadFunction comes in two flavors . First , there is a set of overloaded global function templates . Since not all compilers are able to handle templates to the degree required by these functions , we also provide a corresponding set of macros . The template functions are slightly easier to use and you only have to remember one name . The macros are more portable but they do require more arguments , and as we can not overload macros , each must have a unique name . <p> In naming the macros @ @ @ @ @ @ @ @ @ @ to remember . Each name begins with rwtMakeThreadFunction , which will be followed by either a G if the macro is expecting a global function , or an M if it is expecting a member function . At that point the name is complete if the associated global or member function takes no arguments . Otherwise we add one of A1 , A2 , or A3 for functions with 1 , 2 , or 3 arguments respectively . For example , you will use macro rwtMakeThreadFunctionG to create a thread that calls a global function that takes no arguments . The macro rwtMakeThreadFunctionMA2 will create a thread that calls a member function that takes two arguments . 
@@75678116 @4378116/ <p> RWDBSelector is an encapsulation of an SQL SELECT statement . Its methods provide an application with explicit control over the SELECT statement 's select list , as well as its FROM , WHERE , ORDER BY , and GROUP BY clauses . The set operators + , * , and - ( union , intersection , and difference ) may be applied to RWDBSelectors in order to achieve the semantics of the SQL UNION , INTERSECTION , and DIFFERENCE operations . See the entry for RWDBCompoundSelector . An RWDBSelector may be used to instantiate an RWDBExpr , so subqueries are also supported . See the entry for RWDBExpr . <p> The insertion operator &lt;&lt; is used to add items to an RWDBSelector select list ; the where() method is used to specify a WHERE clause . The items which are inserted into an RWDBSelector are RWDBExprs , which may be any combination of constants , column references , predefined functions , or RWDBSelectors combined by arithmetic or functional operators . The WHERE clause is encapsulated by an RWDBCriterion , which is some number of RWDBExprs combined with logical @ @ @ @ @ @ @ @ @ @ is an SQL table expression . DBTools.h++ represents this concept as a ResultTable . Hence , the following are equivalent : <p> RWDBSelector is designed around the Interface/Implementation paradigm . An RWDBSelector instance is an interface to a reference-counted implementation ; copy constructors and assignment operators produce additional references to a shared implementation . An RWDBSelector implementation is a base class from which a family of database-specific selector implementations is derived . <p> Most RWDBSelector methods return a reference to self . This allows calls to be stacked , as in : <p> Notice that it is not necessary to specify the FROM clause . DBTools.h++ deduces what tables to select from the column references in the select list ; it generates a member of the FROM clause for each unique table reference . You can override this behavior by using the from() member function . <p> Assuming that the name and city columns mentioned above are strings , we would read the results of our query like this : <p> This example introduces the binding of application variables within a WHERE clause of a SELECT statement . This allows @ @ @ @ @ @ @ @ @ @ constructing the WHERE clause each time . The following example uses an AutoParts table in the database , with text column name and integer column i 'd : <p> The default constructor creates an RWDBSelector whose status is RWDBStatus : : notInitialized . This constructor is provided as a convenience , for example , for declaring an array of RWDBSelectors . Usable RWDBSelectors are obtained from RWDBDatabase . <p> RWDBSelector ( const RWDBSelector&amp; select ) ; <p> Copy constructor . The created object shares an implementation with select . <p> The insertion operator adds an item to self 's select list . The supplied expr may be made up of constants , column references , predefined functions , or RWDBSelectors , combined with arithmetic or functional operators . See RWDBExpr . Returns a reference to self . <p> RWDBSelector&amp; operator&lt;&lt; ( const RWDBTable&amp; table ) ; <p> Use this method to specify SELECT * FROMtable . Returns a reference to self . <p> RWDBColumn operator ( const RWCString&amp; name ) const ; <p> Inherited from RWDBSelectorBase . Returns a deep copy of the first RWDBColumn in self 's schema whose name @ @ @ @ @ @ @ @ @ @ with self , that is , the table() method of the returned RWDBColumn returns this selector . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : ColumnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . <p> RWDBColumn operator ( sizet position ) const ; <p> Returns a deep copy of the RWDBColumn in self 's schema whose position matches the given position . The RWDBColumn returned is associated with self . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : ColumnNotFound . A deep copy is made so that the application can modify the returned RWDBColumn without modifying self 's schema . <p> Returns an RWDBBulkReader able to read the result set associated with the execution of self . The RWDBBulkReader executes using the supplied connection . <p> RWDBStatus clear() ; <p> Clears self 's clauses , selection lists , and internal controls . <p> RWDBColumn column ( const RWCString&amp; name ) const ; <p> Inherited from RWDBSelectorBase . Returns a deep copy of @ @ @ @ @ @ @ @ @ @ the given name . The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this selector . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . <p> Inherited from RWDBSelectorBase . Returns a deep copy of the first RWDBColumn in self 's schema whose name matches the given name . The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this selector . If no matching column is found , returns an RWDBColumn whose status is RWDBStatus : : columnNotFound . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . The casecompare argument toggles case sensitivity when comparing column names . Valid arguments are RWCString : : exact and RWCString : : ignoreCase . <p> RWDBColumn column ( sizet index ) const ; <p> Inherited from RWDBSelectorBase . Returns a deep copy of the @ @ @ @ @ @ @ @ @ @ The RWDBColumn returned is associated with self , that is , the table() method of the returned RWDBColumn returns this selector . If index is out of range , returns an RWDBColumn with status RWDBStatus : : invalidPosition . A deep copy is made so that applications can modify the returned RWDBColumn without modifying self 's schema . <p> Inherited from RWDBSelectorBase . Produces an RWDBCursor for execution of the SQL select statement encapsulated by self . The cursor is created on a default database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . <p> Inherited from RWDBSelectorBase . Produces an RWDBCursor for execution of the SQL statement encapsulated by self . The cursor is created on the supplied database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . This function can behave asynchronously if executed using an asynchronous connection . <p> Inherited from RWDBSelectorBase . Produces an RWDBCursor for execution of the SQL select statement encapsulated by self . The argument @ @ @ @ @ @ @ @ @ @ UPDATE OF column-name , column-name , ... <p> Some SQL dialects require this form . The cursor is created on a default database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . <p> Inherited from RWDBSelectorBase . Produces an RWDBCursor for execution of the SQL statement encapsulated by self . The cursor is created on the supplied database connection , using the type and access specifications provided . The connection is held by the RWDBCursor until the RWDBCursor is destroyed . The argument updateCols is used in building a clause : <p> FOR UPDATE OF column-name , column-name , ... <p> Some SQL dialects require this form . This function can behave asynchronously if executed using an asynchronous connection . <p> RWDBDatabase database() ; <p> Inherited from RWDBSelectorBase . Returns the RWDBDatabase that produced this selector . If there is no such object , for example , if this selector was created using the default constructor , returns an RWDBDatabase with a status of RWDBStatus : : notInitialized . <p> By default , adds the DISTINCT @ @ @ @ @ @ @ @ @ @ If Distinct is specified as FALSE , removes the DISTINCT keyword if it is present . Returns a reference to self . <p> RWDBResult execute() ; <p> Inherited from RWDBSelectorBase . Uses a default database connection to submit the SQL SELECT statement encapsulated by self for execution . There will always be one or more RWDBTables in the returned RWDBResult . <p> RWDBResult execute ( const RWDBConnection&amp; connection ) ; <p> Inherited from RWDBSelectorBase . Uses the supplied connection to submit the SQL SELECT statement encapsulated by self for execution . There will always be one or more RWDBTables in the returned RWDBResult . This function can behave asynchronously if executed using an asynchronous connection . <p> virtual RWBoolean fetchSchema() ; <p> Executes the SQL statement associated with self , then populates self 's internal schema with the result set , that is , the columns in the table that resulted from the execution of the SQL statement . The function fetchSchema() returns TRUE if successful . <p> To obtain schema information , DBTools.h++ uses a default database connection to query the database . If no schema can be obtained @ @ @ @ @ @ @ @ @ @ const RWDBConnection&amp; connection ) ; <p> Executes the SQL statement associated with self , then populates self 's internal schema with the result set , that is , the columns in the table that resulted from the execution of the SQL statement . The function fetchSchema() returns TRUE if successful . <p> To obtain schema information , DBTools.h++ uses the supplied connection to query the database . If no schema can be obtained , fetchSchema() returns FALSE . <p> RWDBSelector&amp; from ( const RWDBJoinExpr&amp; jexpr ) ; <p> Adds jexpr to self 's explicit FROM clause . This method is used for adding outer join constructs to the FROM clause . Each call to from() adds an entry to the explicit FROM clause . The tables that need not be part of the outer join can be added through the other from() methods . Use the function fromClear() to discard the explicit FROM clause and revert to the default behavior . However , the default behavior does not add any outer join constructs to the tables in the FROM clause . See Section 4.6.3 in the User 's Guide and @ @ @ @ @ @ @ @ @ @ generating appropriate outer join constructs . If outer join constructs have been added to the FROM clause , the join columns may have to be indicated through the on() or using() methods of RWDBSelector . <p> RWDBSelector&amp; from ( const RWCString&amp; tableName ) ; <p> Adds tableName to self 's explicit FROM clause . Normally , RWDBSelector has no explicit FROM clause . It can deduce which tables to query from the column references in its select list . By using the from() method , an application programmer overrides default FROM clause generation and causes an explicit FROM clause to be maintained . Each call to from() adds an entry to the explicit FROM clause . Note that explicit and implicit FROM clause generation can not be mixed ; if from()is used , it must be used to specify all tables required by the select . Use fromClear() to discard the explicit FROM clause and revert to the default behavior . Returns a reference to self . <p> RWDBSelector&amp; from ( const RWDBTable&amp; table ) ; <p> Adds table 's name to self 's explicit FROM clause . Normally , @ @ @ @ @ @ @ @ @ @ which tables to query from the column references in its select list . By using the from() method , an application programmer overrides default FROM clause generation and causes an explicit FROM clause to be maintained . Each call to from() adds an entry to the explicit FROM clause . Note that explicit and implicit FROM clause generation can not be mixed ; if from()is used , it must be used to specify all tables required by the select . Use fromClear() to discard the explicit FROM clause and revert to the default behavior . Returns a reference to self . <p> Specifies column as a GROUP BY column for self . A select statement may have multiple GROUP BY columns ; successive calls to groupBy() add GROUP BY columns to self . The order of groupBy() calls is retained . Returns a reference to self . <p> RWDBSelector&amp; groupBy ( int columnNumber ) ; <p> Specifies columnNumber as a GROUP BY column for self . A select statement may have multiple GROUP BY columns ; successive calls to groupBy() add GROUP BY columns to self . The order of @ @ @ @ @ @ @ @ @ @ . <p> RWDBSelector&amp; groupByClear() ; <p> Clears self 's GROUP BY clause . Returns a reference to self . <p> RWDBSelector&amp; having ( const RWDBCriterion&amp; criterion ) ; <p> Specifies criterion as self 's HAVING clause . If self already has a HAVING clause , this method replaces it . This method is most often used in conjunction with groupBy() . Returns a reference to self . <p> Specifies the INTO clause of a select statement . If self already has an INTO clause , this method replaces it . A blank tableName removes the clause from self . If self 's database does not support SELECTINTO , DBTools.h++ does not attempt to emulate this functionality . In such cases this method sets self 's status to RWDBStatus : : notSupported . Returns a reference to self . <p> RWBoolean isValid() ; <p> Inherited from RWDBSelectorBase . Returns TRUE if self 's status is RWDBStatus : : ok , otherwise returns FALSE . Does not return FALSE if the previous executed statement failed . You must check the status of the RWDBResult returned from execute() instead of the status of @ @ @ @ @ @ @ @ @ @ column ) ; <p> This adds the column to self 's SQL USING clause . The SQL USING clause specifies the join columns for outer join constructs . Returns a reference to self . <p> RWDBSelector&amp; on ( const RWDBCriterion&amp; criterion ) ; <p> This specifies the join condition for outer join constructs as self 's SQL ON clause . If self already has an ON clause , this method replaces it . Returns a reference to self . <p> RWDBSelector&amp; orderBy ( const RWDBColumn&amp; column ) ; <p> Specifies column as an ORDER BY column for self . A select statement may have multiple ORDER BY columns ; successive calls to orderBy() add ORDER BY columns to self . The order of orderBy() calls is retained . Returns a reference to self . <p> RWDBSelector&amp; orderBy ( int columnNumber ) ; <p> Specifies columnNumber as an ORDER BY column for self . A select statement may have multiple ORDER BY columns ; successive calls to orderBy() add ORDER BY columns to self . The order of orderBy() calls is retained . Returns a reference to self . <p> RWDBSelector&amp; @ @ @ @ @ @ @ @ @ @ Returns a reference to self . <p> RWDBSelector&amp; orderByDescending ( const RWDBColumn&amp; column ) ; <p> Specifies column as an ORDER BY DESCENDING column for self . A select statement may have multiple ORDER BY columns ; successive calls to orderBy() add ORDER BY columns to self . The order of orderBy() calls is retained . Returns a reference to self . <p> RWDBSelector&amp; orderByDescending ( int columnNumber ) ; <p> Specifies columnNumber as an ORDER BY DESCENDING column for self . A select statement may have multiple ORDER BY columns ; successive calls to orderBy() add ORDER BY columns to self . The order of orderBy() calls is retained . Returns a reference to self . <p> RWDBReader reader ( sizet cache=0 ) const ; <p> Inherited from RWDBSelectorBase . Produces an RWDBReader that can be used to read data from self one row at a time . Uses a default database connection which is held by the RWDBReader until the RWDBReader is destroyed . <p> Inherited from RWDBSelectorBase . Produces an RWDBReader that can be used to read data from self one row at a time . Uses @ @ @ @ @ @ @ @ @ @ until the RWDBReader is destroyed . This function can behave asynchronously if executed using an asynchronous connection . <p> Inherited from RWDBSelectorBase . Returns a deep copy of self 's RWDBSchema . The copy is made so that an application can modify the returned RWDBSchema without modifying self 's schema . The schema is empty until self 's fetchSchema() method is called . 
@@75678117 @4378117/ <h> Charts for planning and scheduling <p> Time and activity charts most commonly take the form of a bar chart . The main purpose of such a chart is to represent the relationship of events , activities , or actions to time by using combinations of words , numbers , and graphics to represent activities and events . Time is displayed on the horizontal axis . <p> Activities or resources are displayed on the vertical axis . Resources might be people , places , or things related to performing the activities . <p> Blocks of time are delimited by using horizontal bars , colors , symbols , and so forth . <p> The relationship between activities and time can also be displayed in the form of a calendar view . The main purpose of such a view is to represent the relationship of activities to the days of a month or to the working hours in a day . Blocks of time are delimited by overlaying horizontal bars and symbols on top of a calendar or hourly grid . <p> Typical uses of time and activity charts are for @ @ @ @ @ @ @ @ @ @ activities <p> Time and activity charts are used to communicate information in these domains in a way that is easy to assimilate because of its graphic representation . <p> The size and complexity of these charts range from small scheduling charts used to plan office-based tasks to very complicated charts used for major projects that require updating by computer . <p> There are specific types of time and activity chart , but these types of chart are often customized to fit user requirements . <p> Time and activity bar charts are frequently used to plan activities , such as projects , that have a distinct start and end . This type of chart is often called a Gantt chart . <p> A Gantt chart is a time and activity bar chart that is used for planning , and controlling projects or programs that have a distinct beginning or end . In a Gantt chart , each main activity that is involved in the completion of the overall project or program is represented by a horizontal bar . <p> The ends of the bar represent the start and end of the @ @ @ @ @ @ @ @ @ @ times if the chart is used for planning purposes only . When a chart is used for planning and tracking , the start and end times of future activities are estimated . The historical parts of the chart show the real start and end times of completed activities . <p> Significant information can be indicated by the bars in addition to marking the real or projected time intervals . For example , the bars can show the difference between elapsed time and worked time , the major steps or phases of an activity , or the internal or external assignment of resources to an activity . <p> When an activity is estimated to take a considerable amount of time , it can be broken down into smaller chunks . The completion of each chunk is recorded as a milestone . A specific visual representation is associated with milestones . The chunking of an activity and the use of milestones provide closer control and earlier detection of slippages or other difficulties . This type of Gantt chart is sometimes called a milestone chart . <p> The following figure shows a Gantt @ @ @ @ @ @ @ @ @ @ things will happen , to make sure that there is no overlapping , or to coordinate multiple activities or resources . You could have activities or resources along the vertical axis . <p> The following figure shows charts for scheduling . <p> Charts for showing the work assigned to a resource , such as a person or a machine , represent the loading of that resource . A blank cell indicates that nothing is assigned to a resource in the given period . A filled cell shows that work has been assigned to the resource . The objective is often to achieve maximum utilization of resources , with every cell filled . <p> The following figure shows a Load chart . <p> The dependency of an activity upon another can be indicated , usually by an arrowed line pointing from one task to another . For example , if an arrow leads from one bar to another , you can interpret it to mean that the task represented by the bar ending at the base of the arrow must be completed before the task represented by the bar starting at @ @ @ @ @ @ @ @ @ @ without interconnecting arrows , the tasks they represent can be considered to be independent . <p> A type of chart that displays all interdependencies is called a PERT chart . <p> Activity bar charts can display the relationship of activities to absolute or relative horizontal time scales . In contrast , activity calendar views display the relationship of activities to absolute dates and times arranged in a monthly or hourly grid . This type of chart is useful for showing how activities relate to weekends , holidays , and other milestones that are external to the project schedule . 
@@75678118 @4378118/ <h> Monetize Your Digital Assets <p> Customers are spending more time on apps across mobile devices and other digital channels . Securely externalize your applications and data as API 's and license and package them in customized bundles to maximize revenue . <h> Create Customized Licenses and Rate Plans <p> Create customized packages and tailored plans for partners and developers to consume your application , license them accordingly , and maximize revenue based on usage . Create different levels ( i.e. Platinum , Silver , Bronze ) and guide partners gradually through the levels . <h> Market and Brand your Data as APIs <p> Market and monetize your data and applications , in part or as a whole . Surface the hidden potential of your data by exposing them as simple , marketable APIs as you make them easy to adopt by partners and developers . Partition and segment your data , market data in different ways , and enforce selective access to maximize revenue . <h> Open up Existing Applications <p> Securely open up your data while protecting your enterprise against threats and unauthorized access . Transform any @ @ @ @ @ @ @ @ @ @ API , abstracting the complexity of internal systems and backend applications . Find news ways to monetize existing applications . <h> Analyze , Monitor and Deliver <p> Manage quality-of-service for your APIs , quotas and service-levels for individual apps . Ensure that the appropriate data is being delivered through the right APIs , to the right partner app . Optimize the delivery and performance through caching and global delivery , which can elastically respond to demand . Advanced monitoring allows you to troubleshoot and react problems before they can adversely impact your business or brand . <p> Web APIs heighten security exposure for enterprise information assets across the big three of information security : Confidentiality , integrity and reliability . Learn how some large organizations succeed in API security . 
@@75678119 @4378119/ <p> As systems and environments become more complex and connected , developers have to figure out how to deliver applications faster and reduce the risk of failure as a result of programmatic errors or security flaws . Producing clean applications becomes even more challenging when you factor in all the different languages , platforms , and standards that development teams employ . That 's why delivering safe , robust code requires tools that help identify potential issues early , fit cleanly into development environments , and minimize impact on delivery times . <p> CodeDynamics brings the power and speed of full-featured dynamic analysis to solve complex problems in complex , long-running applications . CodeDynamics digs deep into the state of your running program to efficiently discover memory errors and leaks , and to diagnose subtle problems like deadlocks and race conditions . Supporting C and C++ platforms , it allows you analyze multiple processes and threads , perform reverse debugging , and visualize data to isolate issues faster and more accurately . <p> Running an HPC environment ? TotalView is the de facto standard for run-time analysis and debugging . @ @ @ @ @ @ @ @ @ @ multithreaded , or multiprocess programs . Purpose-built for multicore and parallel computing on C , C++ , and Fortran on Linux , and Mac OS X platforms , TotalView delivers a set of tools providing unprecedented control over processes and thread execution , along with deep visibility into program states and data . <p> Z-Ray is a revolutionary new addition to a PHP developer 's toolkit . It displays all the under-the-hood details of a page request , across all the PHP scripts involved in building the page . Z-Ray injects into responses coming from your PHP app and displays right in the browser you 're using for development : you get vastly greater insight without changing your development workflow . With Z-Ray live , you can easily debug mobile and web services requests originating from a browser , mobile device , or machine-to-machine communications . <p> All software applications have the potential to incur fault , flaw , or failure that 's introduced as soon as the developer types in the first variable declaration . Klocwork static code analysis works at this exact moment , when code is being typed @ @ @ @ @ @ @ @ @ @ of hundreds of different types of errors , security vulnerabilities , and coding standard violations . Using sophisticated inter-procedural control and data flow analysis , variable estimation , and runtime simulation , Klocwork works across the entire development team to identify errors as early as possible , making them easier and less costly to fix . 
@@75678120 @4378120/ <p> The class RWLocaleSnapshot implements the RWLocale interface using Standard C Library facilities . To use it , the program creates an RWLocaleSnapshot instance . The constructor of the instance queries the program 's environment ( using Standard C Library functions such as localeconv() , strftime() , and , if available , vendor specific library functions ) to determine the formatting conventions in effect at the moment of instantiation . When done , the locale can then be switched and another instance of RWLocaleSnapshot created . <p> By creating multiple instances of RWLocaleSnapshot , your program can have more than one locale active at the same time , something that is difficult to do with the Standard C Library facilities . <p> Note : RWLocaleSnapshot does not encapsulate character set , collation , or message information . <p> Class RWLocaleSnapshot contains a set of public data members initialized by its constructor with information extracted from its execution environment . <p> For a description of the static members of the RWLocale interface that operate on objects of type RWLocaleSnapshot , see the RWLocale class description . <p> Constructs an RWLocale @ @ @ @ @ @ @ @ @ @ It uses the Standard C Library function setlocale() to set the named locale , and then restores the previous global locale after formats have been extracted . If localeName is 0 , it simply uses the current locale . The most useful locale name is the empty string , " " , which is a synonym for the user 's chosen locale ( usually specified by the environment variable LANG ) . <p> Note : All previous member functions are redefined from class RWLocale . These virtual functions follow the interface described under class RWLocale . They generally work by converting values to and from strings using the rules specified by the structlconv values ( see &lt;locale.h&gt; ) encapsulated in self . <p> virtual const RWCString&amp; currencysymbol() const <p> Returns a string to use as the currency symbol for this locale . <p> virtual const RWCString&amp; decimalpoint() const <p> Returns a string to use as the numerical decimal separator . <p> virtual const RWCString&amp; grouping() const <p> Returns a string identifying the number of digits to be included in a numerical group . A group is simply the digits between @ @ @ @ @ @ @ @ @ @ string is an integer that specifies the number of digits in a group , starting with the right most group . <p> If the value is equal to 0 , the previous element is used repeatedly for the remainder of the digits . <p> If the value is equal to CHARMAX , no further grouping is to be performed . 
@@75678121 @4378121/ <h> 2.3 Building Objective Toolkit <p> You can build Objective Toolkit in many different ways to support a variety of operating systems and VC++/MFC configurations . For example , you can build Objective Toolkit for any of the latest Visual Studio compilers . ( For a full support matrix , go to the Stingray product page on the Rogue Wave web site , **40;12818;TOOLONG , and click on Supported Platforms . ) In addition , your build configuration may specify any combination of build flags such as debug or release , Unicode or ANSI , static or DLL . <p> You can obtain prebuilt versions of the libraries by request to Rogue Wave technical support . Libraries are available for Windows XP and Vista with the currently supported compilers . We recommend , however , that you build the libraries yourself . The prebuilt libraries are built with a particular instance of Visual Studio and the Windows operating system . Building the libraries yourself ensures that they are compatible with your version of the compiler and the operating system they are built on . <p> A Build Configuration Wizard @ @ @ @ @ @ @ @ @ @ Build Wizard is a powerful tool that allows you to build various versions of the Objective Toolkit library with different configurations . For example , you can build a version of the library that only includes the features that pertain to your project . This is an effective technique for reducing the binary size of the resulting Objective Toolkit libraries and DLLs . <p> Objective Toolkit is distributed with build files for the default configuration that includes all the Toolkit features . You do not need to run the Build Wizard to build the default configuration . <p> The SRC subdirectory contains build files for every version of Visual Studio that Objective Toolkit supports . To build Objective Toolkit , open the appropriate build file . After you load it , examine the different build configurations that specify the settings such as debug or release , Unicode or ANSI , static linking or DLL , and more . You can choose a particular configuration and build only that library variant , or select the All configuration and build every variant of the Objective Toolkit library in one build session . @ @ @ @ @ @ @ @ @ @ the Set Active Configuration combo box in Visual Studio or start a Batch Build and select several variants to be built at once . <p> The Build Configuration Wizard is a wizard dialog that allows you to select every feature you want to include in the resulting library . After you answer a few simple questions , the Build Wizard automatically generates a custom tailored makefile that you can build to create the Objective Toolkit library in the configuration you specified . You can customize the names of the libraries to avoid any potential name collisions or versioning problems . <p> You can generate multiple library configurations with the Build Wizard . For example , you could generate one with just a tree control and another with only the docking windows code . Several different configurations can coexist on your hard disk simultaneously . The Wizard dialogs describe this procedure . Give the target libraries of different build configurations different target names to avoid name collisions . <p> The Objective Toolkit components are now built into two libraries : Stingray Foundation Library ( SFL ) and OT . If you @ @ @ @ @ @ @ @ @ @ configuration , you should run the Build Wizard for both libraries , specifying the same configuration name . <p> On the second panel , specify the configuration name ( for example , MyConfig ) . Use the Build Wizard to specify custom library names for the common library . <p> Run the Objective Toolkit library Build Wizard . After you enter the configuration name ( for example , MyConfig ) , select the components you want to include in the build of the library , and then enter names for your custom library . <p> The Build Wizards automatically generate custom linking header files that you can include in your project . These header files are located in the includetoolkitconfig directory for the Toolkit library and includefoundationconfig directory for the SFL library . The Build Wizard created these files when you rebuilt the library . They have the same name as the library to which they link , with the added prefix sfl or ot . <p> To link to the custom configuration in your application , insert the following lines into stdafx , before you include toolkitsecall.h or any @ @ @ @ @ @ @ @ @ @ custom configuration of Objective Toolkit , you must specify a unique DLL target name . When you build a subset of the Objective Toolkit features or make a change to the Objective Toolkit source or header files , the signature of the library changes . So , when you build a DLL that incorporates a subset of Objective Toolkit features or your own changes , you need to treat the target DLL like a completely unique DLL . If you change the signature of Objective Toolkit and do not specify a new DLL target name , other applications that link to the Objective Toolkit DLL may fail . <h> Table 1 : Objective Toolkit flags <p> Prevents the Objective Toolkit autolink mechanism from working . If this is defined , you need to explicitly list the Objective Toolkit libraries you want to link to in your project 's link settings . <p> SECNOMSG <p> Prevents the output of Objective Toolkit related messages when you build . <p> SECNOTLB <p> Objective Toolkit automatically includes its ScriptHost.tlb as resource 1 when the ActiveScript headers are included in an application . This can @ @ @ @ @ @ @ @ @ @ this problem from occurring . <p> The following table shows the default library names for the various configurations , where &lt;ver&gt; stands for the current product version number . Refer to the naming convention described above . <p> Library name <p> Objective Toolkit library configuration <p> MFC configuration <p> Unicode supported <p> Build Type <p> OT&lt;ver&gt; <p> Static <p> Static <p> No <p> Release <p> OT&lt;ver&gt;d <p> Static <p> Static <p> No <p> Debug <p> OT&lt;ver&gt;a <p> Static <p> DLL <p> No <p> Release <p> OT&lt;ver&gt;ad <p> Static <p> DLL <p> No <p> Debug <p> OT&lt;ver&gt;as <p> DLL <p> DLL <p> No <p> Release <p> OT&lt;ver&gt;asd <p> DLL <p> DLL <p> No <p> Debug <p> OT&lt;ver&gt;u <p> Static <p> Static <p> Yes <p> Release <p> OT&lt;ver&gt;ud <p> Static <p> Static <p> Yes <p> Debug <p> OT&lt;ver&gt;au <p> Static <p> DLL <p> Yes <p> Release <p> OT&lt;ver&gt;aud <p> Static <p> DLL <p> Yes <p> Debug <p> OT&lt;ver&gt;asu <p> DLL <p> DLL <p> Yes <p> Release <p> OT&lt;ver&gt;asud <p> DLL <p> DLL <p> Yes <p> Debug <p> Objective Toolkit makefiles place . lib , . dll and . pdb files into the @ @ @ @ @ @ @ @ @ @ , or vc9 , and &lt;Plat&gt; is x86 or x64 ) . Add this directory to your executable path , or manually copy the DLLs to your Windows directory . <p> Whenever you run the Build Wizard , it overwrites sflversion.h in the SFL ( includefoundation ) include directory or secver.h in the Objective Toolkit ( includetoolkit ) include directory with the names of the libraries . This information is used to link the libraries to your project automatically . <p> If you are maintaining more than one library configuration on your system , this can cause problems . Your projects link to whatever configuration was last set up by the Build Wizard . <p> To avoid problems when switching library configurations , run the Build Wizard specifying the desired configuration for each of the Objective Toolkit libraries . <p> If you check the Project SettingsC/C++ tabPreprocessor Definitions for several target configurations , you can see how the compiler flags link to the appropriate Objective Toolkit library variant automatically . <p> You indicate exactly which Objective Toolkit library you want to link by defining a combination of DEBUG , AFXDLL @ @ @ @ @ @ @ @ @ @ definitions . <p> After you build the libraries , you can start using Objective Toolkit classes in your own applications . Follow the steps below to add Objective Toolkit to an existing application . <p> Load your project into Visual Studio . <p> Add the following the line to the end of your stdafx.h header file . Because stdafx.h is normally included in all your source files , this makes the Objective Toolkit classes available throughout your project . You can optimize your application 's build speed by using the Objective Toolkit component-specific headers instead of secall.h . <p> #include " toolkitsecall.h " <p> If you are linking to a custom library configuration , include the custom headers before the secall.h include . For example : <p> Finally , add includes for these header files , common to all Stingray Studio products : <p> Add #include **28;12892;TOOLONG at the top of the includes . <p> The conditional platform information is displayed in the application 's output window . The output information is helpful when developing and deploying across one or more platforms . <p> Add #include &lt;ManifestDefs.h&gt; at the end @ @ @ @ @ @ @ @ @ @ of manifest definitions for Windows Visual Styles . <p> Open the ViewResource Includes dialog and add the following line to the list of read-only symbol directives . <p> #include " toolkitsecres.h " <p> Add the next line to the list of compile-time directives . <p> #include " toolkitsecres.rc " <p> Add a combination of DEBUG , UNICODE , AFXDLL , and SECDLL to the Project SettingsC/C++ tabPreprocessor Definitions . This automatically causes the correct variant of the Objective Toolkit library to be included in your project . AFXDLL and DEBUG may be defined automatically by other project settings . <p> If you have any problems using a specific class , refer to the online Objective Toolkit Class Reference . Each section of the Class Reference discusses one class or a group of related classes and includes an overview , step-by-step instructions , and important member functions . We also cite Objective Toolkit samples that demonstrate the use and capabilities of the class . 50236 @qwx670236 
@@75678122 @4378122/ <p> This architecture introduces the interface DBEngine ( abstract base class , CGXDBEngine ) , which exposes an interface through which a grid can access any kind of datasource . You can bind an implementation of this abstract base class to a specific data access technology , such as Rogue Wave 's SourcePro DB ( version 5.1 ) . <p> The APIs exposed by the engine are divided into three groups : Initializing , Fetching , and Updating . <p> There is no initializing API in the base CGXDBEngine class , because the parameters required for initializing typically vary in count and type depending on how you are accessing the database . The concrete implementation of the CGXDBEngine class specifies the APIs for initializing . The concrete implementation provides one-time initialization through the constructors and/or special functions to initialize/re-initialize the engine . The engine can re-initialize in three different ways . <p> Requery with the same parameters , usually to get the most current version of the underlying data . <p> Requery with modified parameters but the result set would have the same schema . <p> Re-initialize with different @ @ @ @ @ @ @ @ @ @ . This amounts to closing the engine and re-opening it . <p> The concrete implementation needs to support one or more of the techniques for reinitializing the engine . The technique you use to re-initialize the engine affects the bound grid . If you requery the grid , it redraws to refresh its state and display . If you re-initialize the grid with different parameters , a new schema is created and InitFromEngine() is called to re-initialize the grid . <p> Most of the database driver APIs expose the result of a query in the form of records , so you can fetch the data in the records one at a time . Although this is suitable for data-processing applications , data-presentation applications like the grid prefer the resultant data in a tabular form . Accordingly , the CGXDBEngine interface exposes a table-like API . <p> Because the grid ultimately renders a string to the screen , it is optimal for GetValue() to return a string . <p> You need to fetch records for the grid incrementally . When you are working with large tables , you should fetch a @ @ @ @ @ @ @ @ @ @ as necessary . Typically , more records need to be fetched when the user scrolls down to see more records . The CGXDBEngine exposes a convenient API to handle fetching records . <p> A side effect of fetching incrementally is that we do not know if the count returned by GetRecordCount reflects the total record count or only the number of records fetched so far . The following API solves that problem . <p> Unlike the fetch data , the grid likes to see update data as records rather than in tabular form . This is because the grid subscribes to the popular database editing technique of editing and updating one record at a time . The following update APIs allow such a technique . <p> virtual BOOL Edit ( long nRecord ) = 0 ; // Call Edit before editing a record via SetValue ... virtual BOOL SetValue ( long nRecord , long nField , CString* strValue ) ; virtual BOOL Update ( CString* strError = NULL ) = 0 ; // Complete the editing on a record by calling Update ... virtual long AddRow() = 0 ; // @ @ @ @ @ @ @ @ @ @ // be used in SetValue ... virtual BOOL DeleteRows ( long nFrom , long nTo ) = 0 ; <p> Calling Edit() begins an edit mode on a particular record . After a record is in edit mode , you can call SetValue() on that record only . After you finish editing the record , call Update() to store the changes inside the datasource . Complete the same steps to add a new row . <p> There are also APIs that allow you to cancel a current edit mode , ensure that the engine is initialized , ensure that the result set can be updated , requery the result set , and more . For a comprehensive listing of the APIs exposed , see CGXDBEngine in the Objective Grid Class Reference . <p> Essentially , the logic involved in communicating with the datasource is decoupled from the grid in an implementation of CGXDBEngine . You can easily bind the grid with your datasource by implementing the simple interface specified in the abstract CGXDBEngine. 50236 @qwx670236 
@@75678123 @4378123/ <h> 2.9 Stored Procedures <p> Stored procedures are encapsulated by class RWDBStoredProc . The implementation of stored procedures by the DB Access Module for DB2 CLI provides full support for DB2 stored procedures . This includes support for : <p> creating or registering stored procedures <p> retrieving stored procedure text and parameter definitions <p> executing stored procedures <p> processing multiple result sets , output parameters , and return values <p> DB2 CLI supports stored procedures written in the SQL language as well as external procedures written in other languages . Please see the DB2 CLI documentation for details regarding stored procedures written in languages other than SQL . <p> Stored procedures can be created by calling the createProcedure() method of RWDBDatabase . The DB Interface Module creates the parameter list from a schema you supply , while the body of the stored procedure is supplied by the application . Here is a simple SQL procedure example , which returns the average employee salary as an output parameter , returns the total of all salaries as a return value , and returns a table of all the employees whose salary @ @ @ @ @ @ @ @ @ @ uses the DB2 SQL statement CREATE PROCEDURE . For this reason , it can also register stored procedures with the application server when they are written in languages other than SQL . Please see the DB2 documentation for more information . <p> DB2 stored procedures can be written in several different languages . Once a stored procedure is registered with the server , a client application can execute it . Stored procedures are executed using the ODBC CALL statement . An application has the option of processing output parameters , a return value , and/or the result sets returned by the procedure . <p> increase the performance of stored procedures by eliminating the usual parameter fetch required for instantiation . The schema must include the RWDBColumn : : ParamType of each parameter in the stored procedure . The column is ignored as all SQL procedures in DB2 CLI return an integer . For example , the code in Section 2.9.1 uses the schema params to create the stored procedure ; params could also be used to instantiate an RWDBStoredProc. 
@@75678126 @4378126/ <h> PV-WAVE Toolkits <p> The PV-WAVE Image Processing Toolkit includes an extensive set of filters , transforms , and image processing operators designed to meet the needs of even the most demanding image processing application . <p> The PV-WAVE Signal Processing Toolkit provides a broad selection of pre-defined and readily customized digital signal processing ( DSP ) functions , designed to improve data analysis and simulations . Filters are transfer-function-based for easy design , analysis , and realization of custom filters . The toolkit includes functions and procedures for the Fourier and wavelet analysis of a signal , as well as utilities and source code to facilitate custom function development . <h> TS-WAVE <p> Using PV-WAVE as the underlying language and technology , TS-WAVE is a robust time series analysis application . In addition to being an excellent example of the complexity possible when building PV-WAVE applications , it is highly focused on : <p> Performing plot creation and batch processing of time series data <p> Use of any of the four general functional areas provided : time history , tabular data , x-y plotting , and batch processing 
@@75678127 @4378127/ <p> The class IlvBasicActivityBar draws a rectangle to render the duration of a given activity in a Gantt sheet . It also renders an optional text label inside the rectangle . The text label and tooltip properties of this renderer are not computed dynamically from the activity that is being rendered . Therefore , this renderer is primarily intended to be used when you apply CSS style sheets to the Gantt or Schedule chart . In this case , the CSS styling mechanism will handle dynamic updates to the renderer based upon its interpretation of the style sheets and the data model . If you are not using CSS styling and you want the text label of the renderer to be dynamically computed from a property of the activity , you should use the IlvActivityBar renderer instead . 
@@75678128 @4378128/ <p> Both classes also have methods first() , last() , index() , rindex() , and contains() that search for characters or strings of characters contained with a string . <p> Both classes have methods compareTo() for lexically ordering strings . <p> RWBasicUString differs from RWCString in that an RWBasicUString instance contains a series of Unicode characters encoded in UTF-16 , while an RWCString instance contains bytes encoded in an arbitrary encoding . RWBasicUString also performs conversion between UTF-16 and UTF-8 . Because RWBasicUString contains UTF-16 , its API has some methods that RWCString does not . For example : <p> Methods requiresSurrogatePair() , isHighSurrogate() , and isLowSurrogate() indicate whether a 21-bit Unicode code point requires a surrogate pair of UTF-16 code units . Most characters can be represented in the UTF-16 encoding form with a single 16-bit code unit . Only characters in the range 0x10000 to 0x10FFFF must be represented with a surrogate pair of two UTF-16 code units . <p> Method computeCodePointValue() returns the appropriate RWUChar32 code point given a surrogate pair of RWUChar16 code units . <p> Methods highSurrogate() and lowSurrogate() return the first and second @ @ @ @ @ @ @ @ @ @ . <p> Methods compareCodeUnits() and compareCodePoints() perform code unit and code point ordering of strings , respectively . Code unit ordering of two strings may differ from code point ordering if either string contains surrogate pairs . <p> Methods codeUnitLength() and codePointLength() return the number of code units or code points in a string . The standard length() method is equivalent to codeUnitLength() . <p> Method toUtf8() returns an RWCString containing a UTF-8 representation of the string . <p> Method toUtf32() returns a std : : basicstring templatized on RWUChar32 containing a UTF-32 representation of the string . <p> Method toWide() returns an RWWString containing a UTF-16 or UTF-32 representation of the contents of the string . The representation depends on the size of wchart . If sizeof(wchart) is 2 , the RWWString is encoded in UTF-16 . If sizeof(wchart) is 4 , the RWWString is encoded in UTF-32 . <p> Method validateCodePoint() throws an RWUConversionErr if a given RWUChar32 code point is not a valid Unicode character , or returns the code point if it is valid . This method can be used to validate a code point value @ @ @ @ @ @ @ @ @ @ typical usage , an RWBasicUString instance owns and manages the memory required to hold an array of RWUChar16 values . Like RWCString , RWBasicUString normally copies input data to an internal buffer . This usage is both safe and convenient . <p> In some cases , however , such as constant strings or large strings , it may be more efficient to avoid this initial copy by having RWBasicUString use an externally-supplied buffer . Therefore , RWBasicUString can also be constructed with two alternate memory management strategies : <p> An RWBasicUString instance can reference an external buffer in a read-only fashion . In this case , a client supplies the constructor with a Duration value of Persistent . Any attempt to modify the external buffer causes RWBasicUString to copy its contents to an internal buffer . This strategy is primarily used to treat static arrays or arrays of some other long storage duration as RWBasicUString instances . For example : <p> An RWBasicUString instance can assume ownership of an external buffer , and use it in a read-write fashion . To pass ownership of a buffer to an RWBasicUString , @ @ @ @ @ @ @ @ @ @ : Deallocator object that can be used to deallocate the buffer . ( See Section 3.4.2.1 . ) This strategy is reminiscent of that offered by std : : autoptr&lt;T&gt; , except that RWBasicUString implements copy construction and assignment via reference counting . An RWBasicUString mutator modifies the external buffer directly if its capacity is large enough . Otherwise , the mutator copies the buffer 's contents to an internal buffer , deallocates the external buffer , then modifies the internal buffer . <p> Note that in both cases , although the client 's choice of constructor determines the initial memory management strategy , RWBasicUString will abandon an externally-supplied buffer in favor of an internal buffer as necessary . <p> Passing ownership of a buffer to an RWBasicUString involves supplying the RWBasicUString with an RWBasicUString : : Deallocator object . RWBasicUString : : Deallocator is an abstract base class that can not be instantiated directly . Instead , a deallocator can be created in one of two ways : <p> An RWUBasicUString : : StaticDeallocator object wraps a pointer to a class static method or a global function . As @ @ @ @ @ @ @ @ @ @ , USEFREE() , and USENONE() . For example , the following code creates an RWUBasicUString : : StaticDeallocator that invokes delete to deallocate string buffers . These buffers are returned from a third-party library that allocates buffers via new : <p> The subclass can deallocate string buffers in the manner of its choice , to match the manner in which the buffers are allocated . <p> The use of RWBasicUString : : Deallocator allows the client to choose delete , free() , or custom memory-management mechanisms . The use of an externally supplied deallocation method can also be used to satisfy the heap management requirements of MS-Windows dynamic linked libraries , which in some situations may create their own heap in addition to that of the calling process . <p> Given sufficient capacity , RWBasicUString adds a null terminator to any non-static array passed to it . This terminating null is not considered part of the contents , and is not included in the count returned by length() . <p> RWUString extends RWBasicUString in the Essential Tools Module of SourcePro Code . RWUString is used throughout the API in the @ @ @ @ @ @ @ @ @ @ string normalization , and conversions between UTF-16 and hundreds of other encodings--all functionality added to RWBasicUString . For example , the comparison methods on RWBasicUString simply compare the numerical values of the individual code units or code points , but RWUString can be used in conjunction with RWUCollator in the Internationalization Module to perform locale-sensitive collation ( Chapter 6 ) . RWUString also has access to the comprehensive set of properties for each -Unicode code point in the Unicode Character Database , so methods such as toUpper() and toLower() behave in a locale-sensitive manner . <p> When an RWUString is constructed from a non-Unicode character or string , the non-Unicode character or string is converted into Unicode . Some RWUString constructors accept RWUToUnicodeConverter arguments to specify explicitly how to convert from a non-Unicode string to a Unicode string . For example : <p> RWUString provides the toBytes() method that accepts an RWUFromUnicodeConverter instance , and returns an RWCString containing the byte sequence produced when the contents of the RWUString are converted into the specified encoding . For example , assuming source is an RWUString : <p> The stream insertion operator @ @ @ @ @ @ @ @ @ @ of bytes that are produced when the contents of a string are converted into the encoding specified by the currently active **31;12922;TOOLONG . For example , assuming str is an RWUString : <p> RWUString provides the unescape() method that replaces hexadecimal character escapes with their corresponding Unicode characters . The recognized escape sequences are shown in Table 1 . The value of any other escape sequence is the value of the character that follows the backslash . <h> Table 1 : Recognized Escape Sequences <p> Escape Sequence <p> Unicode <p> uhhhh <p> 4 hexadecimal digits in the range 0-9A-Fa-f <p> Uhhhhhhhh <p> 8 hexadecimal digits <p> xhh <p> 1 or 2 hexadecimal digits <p> ooo <p> 1 , 2 , or 3 octal digits in the range 0-7 <p> a <p> U+0007 : alert ( BEL ) <p> b <p> U+0008 : backspace ( BS ) : <p> t <p> U+0009 : horizontal tab ( HT ) <p> n <p> U+000A : newline/line feed ( LF ) <p> v <p> U+000B : vertical tab ( VT ) <p> f <p> U+000C : form feed ( FF ) <p> r <p> @ @ @ @ @ @ @ @ @ @ U+0022 : double quote <p> ' <p> U+0027 : single quote <p> ? <p> U+003F : question mark <p> <p> U+005C : backslash <p> Note that when you create an RWUString from a string literal containing an escaped character , you must use a double-backslash sequence to escape characters , as the C++ compiler itself treats the character as special , denoting the beginning of an escape sequence embedded in the C++ source code . For example : <p> The characteristics of UTF-16 imply that the number of 16-bit code units in an RWUString may differ from the number of code points . Furthermore , the nature of Unicode implies that the number of code points may differ from the number of characters , as interpreted by the end user . Several methods are provided to determine the length of a string : <p> The inherited length() and codeUnitlength() methods return the number of UTF-16 code units in an RWUString . <p> The inherited codePointLength() method returns the number of code points in an RWUString . <p> Note that codePointLength() may be slower than length() or codeUnitLength() because codePointLength() must @ @ @ @ @ @ @ @ @ @ surrogate code unit pairs . Since the majority of code points in the current Unicode Standard do not require a surrogate representation , many applications can rely on length() or codeUnitLength() to determine or estimate the number of code points . <p> An RWUBreakSearch can also be used to iterate over the characters of an RWUString , in the context of a particular locale . ( See Chapter 7 . ) <p> RWUString performs comparisons on a lexical basis . Methods such as compareTo() , contains() , first() , last() , index() , rindex() , strip() , and the global comparison operators compare the bit values of individual code units , not the logical values of code points or characters . In contrast , RWUCollator performs comparisons on a logical basis , following the conventions specified in a given locale . The logical comparisons made by RWUCollator are more likely to match an end user 's expectations regarding string equality and ordering . The lexical comparisons made by RWUString , however , are likely to be faster . If two strings contain characters from the same script , and are @ @ @ @ @ @ @ @ @ @ adequate for many purposes . See Chapter 6 for more information on RWUCollator and locale-sensitive collation . <p> The range within a referenced RWUString is defined by a starting position and an extent . For example , the 7th through the 11th elements , inclusive , would have a starting position of 6 and an extent of 5 . <p> There are no public constructors for substrings . Substrings are constructed by various functions of the RWUString class . Typically , substrings are created and used anonymously , then destroyed immediately . For example : 50235 @qwx670235 
@@75678129 @4378129/ 50231 @qwx670231 <p> View class . <p> Library : display <p> This is an abstract class without any constructor . Thus , instances can only be created from subtypes of this class . Objects of the IlvAbstractView class and its derived subclasses give rise to actual windows or views that are displayed on your screen . A view is a visual place holder -- a rectangular object on your screen -- to display elements of an application . A window on the screen is an associated set of one or several views . <p> Every view is distinguished by its location ( x , y coordinates ) , size ( height and width ) , and visibility ( that is , an existing view can be visible or not visible ) . <h> Member Function Documentation <p> This member function is called by the changeValue function and must not be called directly . Moreover , no drawing operations are carried out here ( and should not be ) . If you add your own new IlvValue , do not forget to override applyValue as well as changeValue and queryValue @ @ @ @ @ @ @ @ @ @ member function makes sure the given rectangle rect is visible to the user . This is meaningful only if isScrolled returns IlTrue , that is , if this object is scrolled in a system scrolling view . The parent scrolling view takes care of its subwindow displacement to guarantee the visibility of rect . <p> If rect represents a bigger rectangle than the scrolling window is able to display , then the subwindow is centered in the scrolling region on the center of rect . That is , the center of rect is moved to the center of the scrolling window , but the boundaries of rect are not visible . <p> This member function makes sure the given point p is visible to the user . This is meaningful only if isScrolled returns IlTrue , that is , if this object is scrolled in a system scrolling view . The parent scrolling view takes care of its subwindow displacement to guarantee the visibility of p . <p> Is set to the absolute geometry of this view , including the title bar and the frame if the window is a @ @ @ @ @ @ @ @ @ @ the upper left corner of the window , in screen coordinates . <p> The cursor currently set in this view . This cursor should never be deleted . If you want to use it , you should consider using lock and unLock on this resource ( see IlvResource : : lock and IlvResource : : unLock ) . <p> IlTrue if this window is the subwindow of a system scrolling window ( see IlvScrollView ) . Scrolling windows own a single subwindow , from which they display only a rectangular region . This allows you to manipulate bigger windows than your screen can display , and navigate within these by means of a smaller rectangular area . <p> The current behavior of this window concerning the event that may occur within its frame . If IlFalse is returned , no keyboard or pointing device events are received by this object . The window is said to be sensitive if it can receive these events and isSensitive returns IlTrue . <p> virtual void IlvAbstractView : : lower <p> ( <p> ) <p> virtual <p> Pushes this view below the others . @ @ @ @ @ @ @ @ @ @ the screen . This is meaningful only if this view is a top window . <p> The bitmap provided ( if it is not 0 ) is locked . The previous bitmap , if there was one , is unlocked . If the bitmap provided is 0 , the background color is used to ( erase the view . To remove properly a background bitmap that was previously set , you must do the following : <p> Sets the given cursor pattern for your pointing device whenever it enters this window . This member function calls lock on the cursor provided as an argument , then unLock on the old cursor to release a reference to it ( see IlvResource : : lock and IlvResource : : unLock ) . <p> Gives this window entire control of keyboard events , that is it " gets the focus . " When you call this function , all keyboard events are sent to this object . The only way to let another window receive keyboard events is by giving the focus to another window . <p> Warning : <p> Each windowing system @ @ @ @ @ @ @ @ @ @ window or another . Check that setFocus does not lock your system permanently . <p> Layered windows only work in Windows 2000 or higher systems . Layered windows are rendered in an offscreen bitmap by the system , and then blended to the screen using various attributes such as partial translucency . This attribute allows improved performance for shaped windows . 50234 @qwx670234 <p> layered <p> The new layered value of this view . The view becomes layered if the layered argument is IlTrue . <p> This method has only an effect on Windows 2000 and higher systems . The view must be a top window . All pixels painted in the window using this color will be transparent . The method setLayered(IlTrue) is called to set the layered attribute . <p> Is set to the visible rectangle of this window . This return value is meaningful only if this object is the subwindow of a scrolling window ( that is , has a hidden area because of the view hierarchy ) . If this is not the case , sizeVisible has the same meaning as boundingBox. 
@@75678134 @4378134/ <p> When constructing a RWDecimalPortable from a string , the constructor parses the initial characters of the string until the first non-digit , behaving similarly to C 's strtod ) ( function . For example , a string " 99E44 " <p> If an RWDecimalPortable is provided an invalid string , either in the constructor or through assignment , it does not throw an exception . Use isNumber() to determine if the object is valid . <p> The validity or non-validity of the provided string is locale-dependent , as discussed below in the description for the constructor that takes a string . <p> In the first example above , the likely value of the RWDecimalPortable would be 555 . That is , the string parser parses until it encounters an invalid character , and constructs the number from the characters up to that point . <p> Parses the initial portion of input formatted as a decimal number up to the end of the string , or the first non-decimal character , whichever comes first . The parse behavior is locale-dependent ( for decimal points , thousands separator , grouping @ @ @ @ @ @ @ @ @ @ the default locale is used , and parsing behavior will be defined by that locale , creating possibly unexpected results . To ensure predictable and expected behavior , the program should explicitly specify the locale before using this constructor , and input strings should be formatted according the numeric string facets for that locale . <p> Returns the number of bytes required to store self using the saveOn() methods . <p> friend unsigned hash() const ; <p> Returns a value suitable for hashing . <p> bool isNumber() const ; <p> Returns false if self represents a NaN , a missing value , or a NULL ; otherwise returns true . <p> NOTE -- Note : In this instance , the mathematical rather than the RDBMS meaning of NULL is intended . Please see the entry for the RWDBNullIndicator class in the SourcePro DB Reference Guide . <p> RWCString asString ( const RWLocale&amp; ) const ; <p> Returns self as an RWCString using the provided RWLocale instance for numeric formatting . For example , an English locale could return strings such as -23.21 , 0.32 , or 432 . <p> RWCString @ @ @ @ @ @ @ @ @ @ the global locale as determined by the static member function RWLocal : : global() for numeric formatting . For example , an English locale could return strings such as -23.21 , 0.32 , or 432 . <p> friend void restoreFrom ( RWFile&amp; file ) ; <p> Reads file , replacing the contents of self . <p> friend void **27;12955;TOOLONG vis ) ; <p> Reads vis , replacing the contents of self . <p> friend void saveOn ( RWFile&amp; file ) const ; <p> Writes the contents of self to file . <p> friend void saveOn ( RWvostream&amp; vos ) const ; <p> Writes the contents of self to vos . <p> void trimZeros() ; <p> Removes leading zeros before self 's decimal point and trailing zeros after . 
@@75678135 @4378135/ <h> 7.3 Using the Handle-Body Classes <p> The handle-body idiom is a foundation-level pattern with many uses across a wide variety of domains . Rogue Wave designed the handle-body implementation in the Smart Pointer package especially for multithreaded programming , making it a useful tool with the other packages in Threads.h++ for building high-performance applications . <p> Among other benefits , the handle-body idiom allows you to simplify memory management without giving up efficiency , let 's you decompose complex abstractions into simpler ones , and enables the separation of interfaces from implementations so they can vary independently . <p> Often programmers face a quandary . They would like to pass objects by value , because it 's simpler than passing pointers or references . When passing pointers or references , they have to worry about how the object is being shared throughout the application and where and when the object should be deleted . Worse , when passing a pointer to a graph of objects , the party responsible for deleting the objects may not have access to all the pointers necessary to do so , and even if @ @ @ @ @ @ @ @ @ @ great care not to delete the same pointer twice . None of this is a concern when passing objects by value . <p> Passing by value presents its own problems , however . It can be expensive . A heavyweight object can be orders of magnitude more expensive to copy than a simple pointer , which can usually be passed in a register . It can also be just plain wrong to pass by value . Sometimes it 's important for the receiver of an object to be using the same instance as the sender , not a copy ( when passing a stream , for example ) . <p> The handle-body idiom is an elegant solution for side-stepping this trade-off . With handle-body , you get the simplicity of value semantics with the efficiency and sharing of pointer semantics . This is achieved by putting lightweight handles in the public interface , which the user can pass by value . Each handle points to a body that holds the state and does the real work of the object . The methods on the handle are typically inline calls that @ @ @ @ @ @ @ @ @ @ result . The body also maintains a reference count to keep track of the number of handles pointing to it . As a handle is passed around an application , all copies of the handle point to the same body , with each copy increasing the reference count . When a handle goes out of scope , it decrements the body 's reference count . If the count goes to zero , the body is deleted . Thus , the body is guaranteed to live as long as necessary , but no longer . This memory management is completely transparent to the user of the handle . <p> Be warned that the internal reference count , which you can only see by peering into a body object with a debugger , is one less than the number of handles pointing to the body . Thus , a body referenced by a single handle has an internal count of 0 , a body shared by two handles has an internal count of 1 , and so on . <p> NOTE : Member functions returning a body 's reference count return the @ @ @ @ @ @ @ @ @ @ internal count shown in the debugger . <p> The diagrams in this chapter show the logical reference count - the number of handles referencing the body - not the internal private state you see in a debugger . <p> Occasionally a single object has different roles to play in different parts of an application . Threads.h++ is designed to give users of its objects the simplest interface possible that is suitable to their needs . A " fat " interface can be confusing , and it might include methods that are dangerous or inappropriate in a given context . <p> The handle-body idiom allows you to offer different interfaces , using separate handle classes , to the same body . Examples in Threads.h++ include escrows in the Interthread Communication package and threads themselves in the Threading package . Escrows are a thread-communication device that provides an area where one thread can write a result , which other threads can retrieve when ready . The Interthread Communication package provides two separate handle classes with minimal interfaces for the escrow implementation , one for reading and one for writing . Thread object @ @ @ @ @ @ @ @ @ @ contexts . When a thread has a handle to itself , it is of a different handle class than the class that would implement a handle to some other thread . In this way , the interface is tailored to prevent a thread from making a request on itself that requires it to take action before returning - a classic deadlock situation . The request wo n't return until the thread takes action , and the thread ca n't do anything until the request returns . Decomposing abstractions with handle-body keeps the programmer from accidentally falling into this trap . <p> Readers of Design Patterns ( see the Bibliography ) may recognize handle-body as an alias for the Bridge Pattern . The intent of Bridge is to " decouple an abstraction from its implementation so that the two can vary independently . " While the full implications of the Bridge pattern are beyond the scope of this guide , the primary benefit , again , is simplicity . Handle-body allows for simplicity without giving up flexibility . Often the complexity of a class hierarchy stems from implementation considerations , like @ @ @ @ @ @ @ @ @ @ an object must accomplish its task . In many cases , these variations can and should be hidden from the user . For example , a printer object should have the same simple interface regardless of the brand of printer that is currently selected . Behind the scenes , however , each printer probably requires its own class to issue commands peculiar to its brand . A single printer handle can point to any of many printer implementation bodies . Not only does the user deal with one simple interface , but the handle also takes care of which concrete body to instantiate . With a single hierarchy , on the other hand , the user would have to figure out which printer is currently selected in the application and instantiate the appropriate one . <p> Now imagine you want to extend your printer hierarchy by adding a two-sided printer class . Here 's where the separation of interface from implementation really pays off . You can simply derive , say , handle class TwoSidedPrinter from handle class Printer . This is all the user needs to see . On @ @ @ @ @ @ @ @ @ @ as well as one- and two-sided printers within those brands . Trying to do this all within one class hierarchy is difficult . Handle-body makes it clean . In Threads.h++ , the use of handle-body in the Functor package is a prime example . <p> When you use a copy constructor to create one handle from another , for example when passing a handle as a parameter , the new handle is bound to the same body instance , if any , pointed-to by the other handle . Figure 35 shows the result . <p> Similarly , assigning one handle to another causes the left-hand instance to detach from its current representation , if any , and then binds it to the same body instance pointed to by the right-hand instance . Figure 36 shows how assignment works in the same bicycle example . <p> Whenever possible , implement your handles to automatically create the appropriate body instance . This is easiest for users of your handle class . Sometimes there is a one-to-one correspondence between your handle and body classes . In those cases , it is trivial to @ @ @ @ @ @ @ @ @ @ Other times the choice of body depends on some context or the current environment . If so , you 'll have to add some intelligence to your handle or use an external factory object . <p> For the body class : <p> Derive your own body class from RWBodyBase . Add a suffix to it , to differentiate its name from the handle class name . ( The convention for the Threads.h++ classes is that all body classes end in Imp . ) <p> To enforce that the bodies are created only by handles , make the body class 's constructors protected and grant friendship to the handle class . <p> For the handle class : <p> Derive your own handle class from RWHandleBase . In your class , replicate the interface of the body , taking into consideration the way handles and bodies work together : <p> Handle constructors create body implementations on the heap . <p> All other methods forward their calls to the corresponding body implementation methods . <p> Override the body() method to return a reference to the most derived body . <p> Sometimes you have @ @ @ @ @ @ @ @ @ @ classes to choose a particular body for a given handle . For example , a Shape handle might be able to point to any of the bodies in a shape implementation hierarchy containing triangles , circles , rectangles , and so on . If your application is such that the Shape handle ca n't know which concrete shape to use for the body , the user has to decide . One approach is to give the body classes responsibility for creating handles , instead of the other way around as in the first scenario above . The bodies provide a public static make() member function that returns a handle bound to the body containing the make() function . <p> For the body class : <p> Derive your own class hierarchy from RWBodyBase . Add suffixes , to mark the classes as bodies for use with a handle . <p> Make the body constructors protected . <p> For each constructor , implement an equivalent static make() function that creates an instance but returns a handle to that instance , instead of the instance itself . This ensures that bodies can not @ @ @ @ @ @ @ @ @ @ . 
@@75678137 @4378137/ <p> B-splines provide a particularly convenient and suitable basis for a given class of smooth ppoly functions . Such a class is specified by giving its breakpoint sequence , its order k , and the required smoothness across each of the interior breakpoints . The corresponding B-spline basis is specified by giving its knot sequence . The specification rule is as follows : If the class is to have all derivatives up to and including the j-th derivative continuous across the interior breakpoint , then the number should occur k - j - 1 times in the knot sequence . Assuming that and are the endpoints of the interval of interest , choose the first k knots equal to and the last k knots equal to . This can be done because the B-splines are defined to be right continuous near and left continuous near . <p> When the above construction is completed , a knot sequence of length M is generated , and there are m : = M-k B-splines of order k , for example , spanning the ppoly functions on the interval with the indicated smoothness @ @ @ @ @ @ @ @ @ @ has a unique representation as a linear combination of B-splines . A B-spline is a particularly compact piecewise polynomial function . is a nonnegative function that is nonzero only on the interval . More precisely , the support of the i-th B-spline is . No piecewise polynomial function in the same class ( other than the zero function ) has smaller support ( i.e. , vanishes on more intervals ) than a B-spline . This makes B-splines particularly attractive basis functions since the influence of any particular B-spline coefficient extends only over a few intervals . 
@@75678138 @4378138/ <p> RWFixedDecimal&lt;T&gt; classes are exact representations of decimal fractions with a fixed number of digits after the decimal point . In most ways , they behave exactly like the corresponding RWDecimal&lt;T&gt; classes . The exception is that rounding automatically occurs to insure the correct number of decimal places . <p> RWFixedDecimal&lt;T&gt; is templatized . Three short type names are provided : **30;12984;TOOLONG , **30;13016;TOOLONG , and **30;13048;TOOLONG . Each type provides a different amount of precision , as described below in the " Limits " section . The trade-off is simple : the more precision , the slower the class . <p> You may also write your own RWFixedDecimal&lt;T&gt; class . Throughout this section , when we refer to the RWFixedDecimal&lt;T&gt; class , you can assume that it applies to any of the three provided classes , or to one you have defined . <p> Class RWFixedDecimal&lt;T&gt; provides three static member functions that can be used to define the limits on an RWFixedDecimal&lt;T&gt; object . These functions return the precision , maximum value , and minimum value : <p> Note that the precision returned by maxDigits() does not usually @ @ @ @ @ @ @ @ @ @ object . Rather , it indicates the maximum number of digits supported by that object without returning an overflow error . For example the number shown in , Table 12 as the maximum value for **30;13080;TOOLONG has 19 digits . Notice , however , that any number larger than the 19-digit number shown will cause an overflow error because it exceeds the maximum value . There fore , **30;13112;TOOLONG : : maxDigits() returns 18 , because that is the number of digits that will always be supported without an overflow error . <p> The following code snippets demonstrate when an overflow condition caused by exceeding a maximum value will occur : <p> As well as representing a decimal fraction , an RWFixedDecimal&lt;T&gt; can also represent one of several non-numeric values . This concept has several uses , including , for example , representing a null entry from a database or indicating a missing value in data that is to be subjected to a statistical analysis . Money.h++ supports three sorts of non-numeric values : null , missing , and NaN ( Not a Number ) . <p> The result of @ @ @ @ @ @ @ @ @ @ a missing or an NaN . An arithmetic operation in which one operand is a null returns either a valid number or an NaN ( details are given below ) . Thus , missings and NaNs propagate while nulls do not . <p> The special static variables RWFixedDecimal : : missing , RWFixedDecimal : : null , and RWFixedDecimal : : NaN are the prototype missing and null values ; to set up a non-numeric RWFixedDecimal&lt;T&gt; use these static variables along with either the copy constructor or the assignment operator . To test for a non-numeric value , use these values along with an equality operator . You can use the member function isNumber() to test if an RWFixedDecimal&lt;T&gt; has a numeric value . <p> For the most part , arithmetic between RWFixedDecimal&lt;T&gt; objects is defined very simply : you get back an exact representation of the result of the operation . There are several special cases , however : <p> Loss of precision . If the result can not be exactly represented as an RWFixedDecimal&lt;T&gt; object because it has more than 18 significant digits , then the result is @ @ @ @ @ @ @ @ @ @ the precisionLoss error handler is called . <p> Overflow/underflow . If the magnitude of the result exceeds the range of RWFixedDecimal&lt;T&gt; , then the overflow error handler is called . <p> Operand ofmissing . If one of the operands is the value missing , then the result of the arithmetic operation is also a missing . <p> Operand ofnull . If both operands are null , the result is also null . In addition and subtraction , a null value behaves as if it were zero . In multiplication , a null behaves like a one . Dividing by a null value returns the numerator , i.e. , a null in the denominator behaves like one . Using a null as the numerator in a division returns an NaN . <p> Copy constructor . Constructs an RWFixedDecimal&lt;T&gt; that is a copy of the argument . <p> RWFixedDecimal ( const RWDecimal&amp; ) ; <p> Copy constructor . Constructs an RWFixedDecimal&lt;T&gt; that represents the same value as the parameter . The number of decimal places is fixed to be the same as the parameter . <p> RWFixedDecimal ( const char *s ) @ @ @ @ @ @ @ @ @ @ string s . Since we write numbers using base 10 and the RWDecimal&lt;T&gt; class stores numbers using base 10 , the number constructed is an exact representation of the string . If the string can not be successfully parsed as a number , the RWDecimal&lt;T&gt; is initialized to null . If the number in the string can not be exactly represented ( for example , it has too many significant digits ) then the appropriate error handler ( either the inexact or overflow handler ) is called . The string may contain embedded commas to separate groups of digits and may have a leading dollar sign . Negatives can be indicated with a negative sign or by using parentheses . A technical description of the exact input grammar allowed is given in the " Technical Notes " section of this manual . <p> RWFixedDecimal ( long int x ) ; RWFixedDecimal ( int x ) ; <p> Constructs an RWFixedDecimal&lt;T&gt; with value x . The explicit integer constructors prevent initializations from 0 from being ambiguous . Without the int constructor , the compiler would not know whether to convert 0 @ @ @ @ @ @ @ @ @ @ RWFixedDecimal ( long int x , int e ) ; RWFixedDecimal ( int x , int e ) ; <p> Constructs an RWFixedDecimal&lt;T&gt; with value x*10-e where e represents the number of digits after the decimal point . <p> Returns TRUE if self represents a decimal fraction ; returns FALSE if self is not a representation of a number : for example , self is a null or missing value . <p> void **28;13144;TOOLONG ; void restoreFrom(RWFile&amp;) ; <p> Restores value of self from a virtual stream or an RWFile . The virtual streams and RWFile classes are provided with Rogue Wave 's Tools.h++ class library . These functions require that you link in the Tools.h++ library . <p> void saveOn(RWvostream&amp;) const ; void saveOn(RWvostream&amp;) const ; <p> Stores value of self to a virtual stream , or in binary format to an RWFile . The virtual streams and RWFile classes are provided with Rogue Wave 's Tools.h++ class library . These functions require that you link in the Tools.h++ library . <p> The equality operator returns TRUE if the two operands are exactly the same , and FALSE otherwise @ @ @ @ @ @ @ @ @ @ the complement . <p> istream&amp; operator&gt;&gt; ( istream&amp; , **28;13174;TOOLONG ) ; <p> Reads an RWFixedDecimal&lt;T&gt; from an input stream . The format expected is ( -xxx.yyy ) where the xxx and yyy are integers ( which may begin with zeros ) and all the parts - parentheses , minus sign , xxx , decimal point , and yyy - are optional . Since we write numbers using base 10 , and the RWFixedDecimal&lt;T&gt; class stores numbers using base 10 , the number constructed is an exact representation of the input . <p> ostream&amp; operator&lt;&lt; ( ostream&amp; , const **28;13204;TOOLONG ) ; <p> Writes an RWFixedDecimal&lt;T&gt; to an output stream . Output is written in the form -xxx.yyy where the xxx and yyy are integers and only the necessary parts are written . For more elaborate formatting , use an RWDecimalFormat object . <p> Converts the argument to an integer . The method of rounding is controlled by the optional last parameter , as described in detail above in the description of the global function round . <p> RWCString toString ( const **28;13234;TOOLONG ) ; <p> Converts an RWFixedDecimal&lt;T&gt; to @ @ @ @ @ @ @ @ @ @ the xxx and yyy are integers and only the parts necessary are written . For more elaborate formatting , use an RWDecimalFormat object . <p> Converts a floating point value to an RWDecimal . The results may be inexact . <p> static int maxDigits() ; <p> Returns the maximum number of digits that an RWDecimal&lt;T&gt; of the indicated type can contain . <p> static int maxDigits() ; <p> Returns the maximum number of digits that an RWFixedDecimal&lt;T&gt; of the indicated type is guaranteed to represent without overflow . In most cases , an RWFixedDecimal&lt;T&gt; can represent some numbers of length actualDigits , where actualDigits=maxDigits() + 1 . For example , the maxDigits() value for class RWDecimal&lt;T&gt; is 18 , even though the number of digits in the maxValue() for the class is 19 . <p> static RWDecimal&lt;T&gt; maxValue() ; <p> Returns the maximum value that can be represented by this class . The maximum value +1 will always generate an overflow error . <p> static RWDecimal&lt;T&gt; minValue() ; <p> Returns the minimum value that can be represented by this class . The minimum value -1 will always generate an overflow @ @ @ @ @ @ @ @ @ @ an " inexact " error occurs . This type of error most often indicates use of an arithmetic operation that will cause loss of precision in the result . The default error handler , defaultInexactHandler , prints an error message , but does not throw an exception . <p> Sets the function that is called when an " overflow " error occurs . This type of error most often indicates the use of an arithmetic operation that will cause a result larger than can be stored . The default error handler , defaultOverflowHandler , simply throws the error object as a C++ exception . 
@@75678139 @4378139/ <p> When it comes to the extremely competitive web development market , focusing on the user and differentiating yourself from the crowd are the top priorities . Choosing development tools that get you from concept to production in less time while meeting these goals is key - the right choices can mean the difference between meeting the release schedule or missing it , between building a solid code foundation or refactoring applications year after year . Our web development tools are built to ease development and testing efforts across both middleware and the presentation layer , and form the foundation for web deployments around the world . <p> Todays applications are more scalable , portable , and need to support rapid innovation more than ever before . Rogue Wave architects ensure that your PHP and Java applications follow established software design best practices through a comprehensive evaluation of application code and workflows . We focus on scalability , supportability , and code quality . Our architecture audits provide an objective , independent review of the application to significantly reduce the risk of missing deadlines , releasing critical flaws and @ @ @ @ @ @ @ @ @ @ Zend Framework , Apache , ActiveMQ , MySQL , and other open source technologies training from the basics through advanced topics . Each course , led by our live expert instructors , offers real-life examples and interactivity to provide a robust and hands-on training experience that sharpens your skills and adds new best practices to your development toolkit . Our classes bring you our unique experience based on years or developing , architecting , and contributing to many of the most popular open source projects including PHP 7 , Zend Framework , CentOS , Apigility , Expressive , IBM i toolkit and more , to ultimately help you sharpen your existing skills or learn entirely new skills . <p> Bring powerful visuals and interactivity to your web apps with Visualization . This set of cross-platform C++ , Java , and Adobe Flex tools allow you to upgrade your user interfaces to better model , analyze , and communicate complex business information to your users : <p> PHP development involves a mix of tools , from coding to testing to deployment , that often behave differently from each other and sometimes @ @ @ @ @ @ @ @ @ @ PHP Development Suite removes the configuration and collaboration confusion by providing all the necessary tools in one place . By offering everything from a fully optimized PHP stack ( Zend Server ) and purpose-built IDE ( Zend Studio ) to server-side debugging tools and license distribution management , the suite allows you to create , test , deploy , and distribute your apps without worrying about finding and learning about different tools for different jobs . <p> Leveraging existing business logic without spending a lot of time developing new web services is where HydraExpress can help . The HydraExpress framework allows you to expose C++ business logic for use in a service-oriented architecture ( SOA ) application with minimal effort . Based on your specification , it automatically creates a service that handles all the protocols , standards , and networking specific to your infrastructure . 
@@75678140 @4378140/ <p> RWDecimals are exact representations of decimal fractions . They behave very similarly to the built-in floating point types , float and double . However , because the built-in types use base 2 , they can not store decimal fractions exactly , resulting in rounding errors and a loss of precision . Since the RWDecimal&lt;T&gt; classes use base 10 , they can do decimal math exactly . <p> RWDecimal&lt;T&gt; is templatized . Three short type names are provided : **25;13264;TOOLONG , **25;13291;TOOLONG , and **25;13318;TOOLONG . Each type provides a different amount of precision , as described below in the " Limits " section . The trade-off is simple : the more precision , the slower the class . <p> You may also write your own RWDecimal&lt;T&gt; class . Throughout this section , when we refer to the RWDecimal&lt;T&gt; class , you can assume that it applies to any of the three provided classes , or to one you have defined . <p> Class RWDecimal&lt;T&gt; provides three static member functions that can be used to define the limits on an RWDecimal&lt;T&gt; object . These functions return the precision , @ @ @ @ @ @ @ @ @ @ <p> Note that the precision returned by maxDigits() does not usually represent the number of digits in the maximum value of an RWDecimal&lt;T&gt; object . Rather , it indicates the largest number of digits that will always be supported by that object without returning an overflow error . For example , Table 1 indicates that the maximum value for **25;13345;TOOLONG has 19 digits . Notice , however , that larger 19-digit numbers will cause an overflow error because they exceed the maximum value . Therefore , **25;13372;TOOLONG : : maxDigits() returns 18 , because that is the number of digits that will always be supported without an overflow error . <p> The following code snippets demonstrate when an overflow condition caused by exceeding a maximum value will occur : <p> As well as representing a decimal fraction , an RWDecimal&lt;T&gt; can also represent one of several non-numeric values . This concept has several uses , including , for example , representing a null entry from a database or indicating a missing value in data which is to be subjected to a statistical analysis . Money.h++ supports three of non-numeric values @ @ @ @ @ @ @ @ @ @ number ) . The missing and NaN values propagate while null values do not . This means that arithmetic operations performed using a missing or an NaN result in a missing or an NaN value , whereas arithmetic operations performed with a null operand return either a valid number or an NaN . Details are given below . <p> The special static variables RWDecimal : : missing , RWDecimal : : null , and RWDecimal : : NaN are the prototype missing and null values . To set up a non-numeric RWDecimal&lt;T&gt; use these static variables along with either the copy constructor or assignment operator . To test for a non-numeric value , use these values along with an equality operator . You can use the member function isNumber() to test if an RWDecimal&lt;T&gt; has a numeric value . <p> For the most part , arithmetic between RWDecimal&lt;T&gt; objects is defined very simply : you get back an exact representation of the result of the operation . However , there are several special cases : <p> Loss of precision . If the result can not be exactly represented as an @ @ @ @ @ @ @ @ @ @ the result is set to an approximation of the true result , and the precisionLoss error handler is called with an RWDecimalInexactErr object . <p> Overflow/underflow . If the magnitude of the result exceeds the range of RWDecimal&lt;T&gt; , then the overflow error handler is called with an RWDecimalOverflowErr object . <p> Operand ofmissing : If one of the operands is a missing value , then the result of the arithmetic operation is also a missing value . <p> Operand ofnull : If both operands are null , the result is also null . In addition and subtraction , a null value behaves as if it were zero . In multiplication , a null behaves like a one . Dividing by a null value returns the numerator , thus here a null behaves like one . Using a null as the numerator in a division returns an NaN . <p> Copy constructor . Constructs an RWDecimal&lt;T&gt; that is a copy of the argument . <p> RWDecimal ( const char *s ) ; <p> Constructs an RWDecimal&lt;T&gt; from the null-terminated character string s . Since we write numbers using base 10 @ @ @ @ @ @ @ @ @ @ , the number constructed is an exact representation of the string . If the string can not be successfully parsed as a number , the RWDecimal&lt;T&gt; is initialized to null . If the number in the string can not be exactly represented ( for example , it has too many significant digits ) then the appropriate error handler ( either the inexact or overflow handler ) is called . The string may contain embedded commas to separate groups of digits and may have a leading dollar sign . Negatives can be indicated with a negative sign or by using parentheses . A technical description of the exact input grammar allowed is given in the " Technical Notes " section of this manual . <p> RWDecimal ( long int x ) ; RWDecimal ( int x ) ; <p> Constructs an RWDecimal&lt;T&gt; with value x . The explicit integer constructors prevent initializations from 0 from being ambiguous . Without the int constructor , the compiler would not know whether to convert 0 to a constchar* or a long int . <p> RWDecimal ( long int x , int e ) ; @ @ @ @ @ @ @ @ @ @ Constructs an RWDecimal&lt;T&gt; with value x*10-e , so that e represents the number of digits after the decimal point . <p> RWDecimal ( const RWDecimalPortable&amp; ) ; <p> Constructs an RWDecimal&lt;T&gt; representation of the argument . This constructor is most often used implicitly to provide type conversion from one RWDecimal&lt;T&gt; type to another using an RWDecimalPortable object as an intermediate representation . <p> Returns TRUE if self represents a decimal fraction ; returns FALSE if self is not a representation of a number : for example , self is a null or missing value . <p> void restoreFrom ( RWvistream&amp; ) ; void restoreFrom(RWFile&amp;) ; <p> Restores value of self from a virtual stream or an RWFile . The virtual streams and RWFile classes are provided with Rogue Wave 's Tools.h++ class library . These functions require that you link in the Tools.h++ library . <p> void saveOn ( RWvostream&amp; ) const ; void saveOn(RWFile&amp;) const ; <p> Stores value of self to a virtual stream , or in binary format to an RWFile . The virtual streams and RWFile classes are provided with Rogue Wave 's Tools.h++ class library @ @ @ @ @ @ @ @ @ @ library . <p> Performs the operation between self and the argument , and then stores the results in self . If the resulting operation causes loss of precision or overflow in the result , the appropriate error handler will be called before the function returns . <p> RWDecimalPortable operator RWDecimalPortable() const ; <p> Conversion to a portable decimal object . This is most often used implicitly to interface with a facility such as I/O or type conversion . <p> These arithmetic operators have their conventional meanings . If the resulting operation causes loss of precision or overflow in the result , the appropriate error handler will be called before the function returns . <p> The equality operator returns TRUE if the two operands are exactly the same , and FALSE otherwise . The not equal operator , ! = , does the complement . <p> istream&amp; operator&gt;&gt; ( istream&amp; , RWDecimal&lt;T&gt;&amp; ) ; <p> Reads an RWDecimal&lt;T&gt; from an input stream . Since we write numbers using base 10 and the RWDecimal&lt;T&gt; class stores numbers using base 10 , the number constructed is an exact representation of the input . @ @ @ @ @ @ @ @ @ @ digits and may have a leading dollar sign . Negatives can be indicated with a negative sign or by using parentheses . A technical description of the exact input grammar allowed is given in the " Technical Notes " section of this manual . <p> ostream&amp; operator&lt;&lt; ( ostream&amp; , const RWDecimal&lt;T&gt;&amp; ) ; <p> Writes an RWDecimal&lt;T&gt; to an output stream . Output is written in the form -xxx.yyy where the xxx and yyy are integers and only the necessary parts are written . For more elaborate formatting , use an RWDecimalFormat object . <p> Returns x raised to the exponent n . This computation is likely to cause a loss of precision ( and a corresponding call to the precision error handler ) if n is at all large , and x has any decimal places . <p> Returns x rounded to n decimal places . The method of rounding is controlled by the optional last parameter as shown in the table below . The last three columns indicate the result of rounding three example numbers to one decimal place . Rounding a negative number returns exactly the @ @ @ @ @ @ @ @ @ @ the result negative . <p> Converts the argument to an integer . The method of rounding is controlled by the optional last parameter as described in detail above in the description of the global function round . <p> RWCString toString ( const RWDecimal&lt;T&gt;&amp; ) ; <p> Converts an RWDecimal&lt;T&gt; to a string . The string produced by this function has the form -xxx.yyy where the xxx and yyy are integers to the left and right of the decimal . Digits only appear if necessary . For more elaborate formatting , use an RWDecimalFormat object . <p> Converts a floating point value to an RWDecimal . Results may be inexact . <p> static int maxDigits() ; <p> Returns the maximum number of digits that an RWDecimal&lt;T&gt; of the indicated type is guaranteed to represent without overflow . In most cases , an RWDecimal&lt;T&gt; can represent some numbers of length actualDigits , where actualDigits=maxDigits() + 1 . For example , the maxDigits() value for class RWDecimal&lt;T&gt; is 18 , even though the number of digits in the maxValue() for the class is 19 . <p> static RWDecimal&lt;T&gt; maxValue() ; <p> Returns the @ @ @ @ @ @ @ @ @ @ The maximum value +1 will always generate an overflow error . <p> static RWDecimal&lt;T&gt; minValue() ; <p> Returns the minimum value that can be represented by this class . The minimum value -1 will always generate an overflow error . <p> Sets the function that is called when an " inexact " error occurs . This type of error most often indicates the use of an arithmetic operation that will cause loss of precision in the result . defaultInexactHandler , the default error handler , prints an error message , but does not throw an exception . <p> Sets the function that is called when an " overflow " error occurs . This type of error most often indicates the use of an arithmetic operation that will cause a result larger than can be stored . defaultOverflowHandler , the default error handler , simply throws the error object as a C++ exception . 
@@75678143 @4378143/ <h> Protected Member Functions 50231 @qwx670231 <p> Pane container class . <p> Library : ilvadvgdt <p> The IlvPanedContainer class is a high-level class that let 's you arrange IlvPane instances , called panes , either horizontally ( from top to bottom ) or vertically ( from left to right ) . Since an IlvPane object encapsulates a view ( by means of the IlvViewPane class ) , you can build complex structures composed of nested paned containers . <p> The direction of the paned container . Valid values are : IlvVertical ( panes are arranged from top to bottom ) , and IlvHorizontal ( panes are arranged from left to right ) . See IlvPanedContainer constructors for more details . <p> visible <p> A Boolean value specifying whether the dockable container should be visible ( IlTrue ) . <p> Applies the specified function to all the panes of the paned container . <p> This member function is recursive , and thus , all the panes contained into sub-paned containers will also be crossed . Note that if the function func returns a non-zero value , the process will be stopped @ @ @ @ @ @ @ @ @ @ <p> The function to be applied . <p> arg <p> The argument that will be passed to the function func . <p> Returns : <p> The result of the function that stopped the operation , or 0 if nothing stopped the operation . <p> The instance of the IlvSliderPane class that is inserted between two resizable panes when the paned container is set to manage sliders automatically . You may want to override this method to create your subclass of IlvSliderPane . <p> A Boolean value specifying whether the search should be recursive . If all is set to IlTrue , the pane is searched for recursively in each view pane of the paned container that encapsulates an IlvPanedContainer object . <p> The new direction of the paned container . Valid values are IlvVertical and IlvHorizontal . When a paned container is vertical , panes are arranged from top to bottom . When it is horizontal , panes are arranged from left to right . 
@@75678145 @4378145/ <h> Enterprise API Management <p> Community Manager - a sophisticated developer community product to help enterprises attract , manage , and support the developers that build Apps using their APIs <p> Portfolio Manager - provides planning capabilities to help ensure the alignment of APIs with strategic IT investments and business opportunities <p> Lifecycle Manager - provides API and App lifecycle management capabilities to help customers build APIs that meet current and future business requirements <p> Policy Manager - provides the services and APIs that support the rest of the product family . It is required by API Manager and Community Manager , and is a recommended option for Portfolio Manager and Repository Manager 
@@75678148 @4378148/ <h> Protected Member Functions 50231 @qwx670231 <p> The main class for the Tree Layout algorithm . <p> Library : ilvtree <p> The Tree Layout places the nodes of a tree starting from the root of the tree to the leaves . If the graph has parts that are disconnected , it arranges each connected component as an individual tree . The Tree Layout algorithm is primarily designed for a forest of pure trees . In a tree , each node except the root has a parent node . All the nodes that have the same parent are called children with respect to the parent and sibling among themselves . The Tree Layout algorithm can also be used for non-trees , for example cyclic graphs . In this case , the layout algorithm ignores those links that violate the tree structure and takes only the spanning tree of the graph into account . <p> The algorithm has several layout modes : <p> The nodes can be arranged freely in a horizontal or vertical way . This is suitable for a graph with a large variation of node sizes . <p> @ @ @ @ @ @ @ @ @ @ . This is suitable for a graph that contains nodes of approximately the same size . <p> The nodes can be arranged radially on concentric circles or ellipses around the root of the tree . <p> To simplify the explanations of the layout parameters , we use the compass directions north , south , east , and west . We consider the center of the root node of a tree to be the north pole . If the root node is placed at the top border , then north is always upwards , south towards the bottom , west towards the left , and east towards the right side of the layout . If the root node is placed at the left border , then north is left and south is right . In radial mode , the root is placed in the center , hence the notation of north and south depends on where a node is placed relative to the root : the north side of any node is the side that is closer to the root , and the south side is the side that is further @ @ @ @ @ @ @ @ @ @ provided . In particular , the free layout mode allows the tip over alignment , which means that subtrees are arranged serial instead of parallel : if the subtrees starting at one node are normally arranged horizontally , then the tip over alignment arranges them vertically . The tree layout provides layout modes that automatically adapt the tip over alignment to fit the layout best to a given aspect ratio . <p> Two sample drawings produced by the Tree Layout algorithm . The left drawing uses the level layout mode . The flow direction of the links is towards the bottom , and the nodes are south justified ( means here : at the bottom ) within each level . The right drawing is the same tree in free layout mode ( which uses always north justification ) : <p> Another sample drawing in free layout mode with tip over alignment at some leaf nodes : <p> Two sample drawings in the two radial layout modes . The normal radial mode in the left drawing places the nodes of the same level on a circle around the root node . @ @ @ @ @ @ @ @ @ @ nodes of the same level alternating on two circles around the root node . This results in a better space usage . <p> In non-radial layout modes , the Tree Layout algorithm supports different styles of links in the same drawing . The following sample drawing shows orthogonal and straight line links . It also shows nodes that are aligned at the center ( see the red nodes ) , at the east ( green ) , and at the west ( blue ) of their children . The drawing was created by the free layout mode with link flow direction to the right , hence north is to the left . <p> The Tree Layout algorithm also supports node neighboring in all modes . The following sample drawing shows a tree layout with flow direction towards the top . Some nodes are not placed as children but rather as neighbors at the same level as the corresponding parent node . The red links , which are perpendicular to the flow direction , are between nodes that were specified as neighbored . <p> See the corresponding chapter of the User @ @ @ @ @ @ @ @ @ @ of graphs for which this algorithm can be used , the features and limitations , code samples , and so on . <p> Note the following points : <p> If no root node is specified , the layout algorithm takes the direction of links into account to calculate one . Besides that , the direction of links does not influence the layout . <p> The layout algorithm is designed to work stable on incremental changes . If nodes are added or removed after a layout , the next layout tries by a heuristic to adjust the layout only minimally and to avoid major structural reorganizations . <p> The initial position of the nodes ( at the moment you start the layout ) affect the resulting layout because the algorithm tries to preserve the relative order of the children on incremental changes . <h> Constructor &amp; Destructor Documentation <p> IlvTreeLayout : : IlvTreeLayout <p> ( <p> ) <p> Creates a new instance of the Tree Layout algorithm . <p> To indicate the grapher you want to lay out , use the method attach(IlvGrapher) . To indicate the graph model you want @ @ @ @ @ @ @ @ @ @ perform the layout , use the method performLayout() . To modify the layout parameters , use the different methods provided in this class and its superclass . <p> When you attach a new graph model to the layout instance , it is not necessary to detach the old graph model because this is done automatically when you call attach . The detach() method performs cleaning operations on the graph model or the grapher . In addition to the cleaning operations in the base class , Tree Layout removes the alignment and root preference specifications of individual nodes , the node neighboring specifications , and the link style specifications of individual links . <p> Returns the backward links that were used in reverse direction as part of the spanning tree during layout . <p> This can be called after layout , if the link categorization option was set to IlTruebefore layout by using the method setCategorizingLinks . <p> The backward tree links have the property that the " to " node is the parent of the " from " node in the tree layout . These links are reshaped by the @ @ @ @ @ @ @ @ @ @ tree , some links will not be part of the spanning tree that forms the base structure for the layout . These links are not part of this list . Also , the links that do not need to be reversed but form the spanning tree are not part of this list . <p> Returns : <p> The list of links that are part of the backward spanning tree , or null if the link categorization option was switched off during the last run of layout . <p> Returns the forward links that were used as part of the spanning tree during layout . <p> This can be called after layout , if the link categorization option was set to IlTruebefore layout by using the method setCategorizingLinks . <p> The forward tree links have the property that the " from " node is the parent of the " to " node in the tree layout . These links are reshaped by the layout algorithm . <p> If the graph was not a tree , some links will not be part of the spanning tree that forms the base structure for @ @ @ @ @ @ @ @ @ @ tree , some links need to be reversed to form the spanning tree . These links are not part of this list . <p> Returns : <p> The list of links that are part of the forward spanning tree , or null if the link categorization option was switched off during the last run of layout . <p> Returns the links that were neither forward nor backward links in the spanning tree during layout . <p> This can be called after layout , if the link categorization option was set to IlTruebefore layout by using the method setCategorizingLinks . <p> The non-tree tree links have the property that neither the " from " node is the parent of the " to " node nor the " to " node is the parent of the " from " node in the tree layout . These links are not reshaped by the layout algorithm . <p> If the graph was not a tree , some links will not be part of the spanning tree that forms the base structure for the layout . Only these links are part of this list . @ @ @ @ @ @ @ @ @ @ routing layout algorithm after the tree layout ( for example , by IlvOrthogonalLinkLayout ) . <p> Warning : <p> note Links that are specified as fixed links or that are adjacent to fixed nodes are not part of this list even though they are also not part of the spanning tree . <p> Returns : <p> The list of links that are not part of the spanning tree , or null if the link categorization option was switched off during the last run of layout . <p> This can be called after layout . If there are more than one connected components , each component has a root . If no root was specified , the layout algorithm automatically selects an appropriate node . If too many roots were specified , some specified roots will not become calculated roots during layout . <p> Note that this does not necessarily mean that these nodes are selected as real roots , because the specification may have conflicts ( for example , each connected component can only have one root , thus specifying two roots for the same connected component causes a conflict @ @ @ @ @ @ @ @ @ @ really used as roots during the layout , call the method getCalcRoots() . <p> In layout modes IlvTreeLayoutRadialMode and **34;13399;TOOLONG , the nodes are placed in circular layers if the aspect ratio is 1 , otherwise in elliptic layers . <p> In layout modes IlvTreeLayoutTipOverMode , **29;13435;TOOLONG , **30;13466;TOOLONG , and **38;13498;TOOLONG , the nodes are placed as in in free mode , but local tip-over alignments are automatically added to fit the layout better to the aspect ratio . <p> Sets the minimal offset between neighbored nodes that belong to different branches in the tree . <p> This is the offset between neighbored nodes that are not siblings . The offset is in the opposite direction to the link flow . <p> If the flow direction is towards the top or bottom and the layout mode is not radial , this is a horizontal offset . If the flow direction is towards the left or right and the layout mode is not radial , this is a vertical offset . If the layout mode is radial , this is an offset tangential to the circles or ellipses . <p> @ @ @ @ @ @ @ @ @ @ level to the west of the eastNode . This implies conversely that the eastNode is the first neighbor at the same level to the east of the westNode . <p> For instance in free layout mode and flow direction towards the bottom , the east node is placed as immediate neighbor at the right side of the west node at approximately the same y coordinate . A link between both nodes is routed as a straight horizontal line between both nodes . In radial layout mode , the east node is placed as immediate neighbor in the same circle as the west node . A link between both nodes is routed tangential to the node circle as a straight line . <p> Note that each node can have at most one east neighbor and one west neighbor . Children of tip over alignments have for technical reasons special area requirements , therefore they can have a west neighbor but no east neighbor . This means that if the parent node of the westNode has tip over alignment , the east-west neighboring is ignored . <p> East west neighboring is possible @ @ @ @ @ @ @ @ @ @ The layout algorithm considers both nodes as if they were conceptually connected by a link . <p> IlvLayoutCenterAlignment - A parent is centered over its children , taking the center of the children into account . <p> **30;13538;TOOLONG - A parent is centered over its children , taking the border of the children into account . <p> IlvLayoutEastAlignment - A parent is aligned with the border of its easternmost child . <p> IlvLayoutWestAlignment - A parent is aligned with the border of its westernmost child . <p> **25;13570;TOOLONG - A parent is outside the border of the children , while the children are placed sequential instead of parallel . This alignment style is not possible in the radial or level layout modes . <p> IlvLayoutMixedAlignment - Each node can have a different alignment option . In this case , the alignment of each individual node can be set by the method setAlignment ( IlAny , IlvLayoutAlignment ) , such that different alignments can occur in the same graph . <p> This feature can be useful if the graph contains links that can have intermediate points and are not straight-line links @ @ @ @ @ @ @ @ @ @ global link style is IlvLayoutMixedLinkStyle , all links have the same style of shape . <p> The default value is **30;13597;TOOLONG . <p> Note that , when the graph attached to the layout is of type IlvGrapher , the effect of the link reshaping depends on the type of link . For the following link types , the reshaping has no effect : <p> However , if the option isLinkReplacementAllowed returns IlTrue , the layout calls the method ensureReshapeableLinks or ensureStraightLineLinks to ensure that all the links can be reshaped as needed . Note that in this case , the links that can not be reshaped can be replaced with new links of a different type . <p> IlvTreeLayoutFreeMode - All links flow roughly in the flow direction . Nodes of different tree branches ( this is , nodes with different parent node ) are not justified to each other , therefore the level justification parameter is ignored . Tip over alignment is possible , if specified as alignment . All link styles are possible . The aspect ratio is ignored . <p> IlvTreeLayoutLevelMode - All links flow roughly in @ @ @ @ @ @ @ @ @ @ are justified at their borders or center according to the level justification parameter . Tip over alignment is not possible , but all link styles are possible . The aspect ratio is ignored . <p> IlvTreeLayoutTipOverMode - Similar to the mode IlvTreeLayoutFreeMode . However in mode IlvTreeLayoutTipOverMode , the algorithm tries to optimize the layout automatically to fit best the specified aspect ratio . By a fast heuristic , it chooses for some nodes the local alignment **25;13629;TOOLONG , but keeps the alignment of all other nodes as specified . This heuristic is a fast compromise between the modes **30;13656;TOOLONG , **29;13688;TOOLONG , and **38;13719;TOOLONG . <p> **30;13759;TOOLONG - Similar to the mode IlvTreeLayoutTipOverMode . The algorithm tries to optimize the layout automatically to fit best the specified aspect ratio . This slow heuristic tries to tip over starting from the leaves and chooses the best layout . It keeps the alignment of all nodes close to the root as specified . <p> **29;13791;TOOLONG - Similar to the mode IlvTreeLayoutTipOverMode . The algorithm tries to optimize the layout automatically to fit best the specified aspect ratio . This slow heuristic @ @ @ @ @ @ @ @ @ @ the best layout . It keeps the alignment of all nodes close to the leaves as specified . <p> **38;13822;TOOLONG - Similar to the mode IlvTreeLayoutTipOverMode . The algorithm tries to optimize the layout automatically to fit best the specified aspect ratio . This slow heuristic tries to tip over starting from the roots and from the leaves , and chooses the best layout . It keeps the alignment of all nodes in the middle between roots and leaves as specified . <p> IlvTreeLayoutRadialMode - The root node is in the center , the links flow radial away from the center , and the nodes are placed in circular layers around the root node according to the level justification . Tip over alignment and orthogonal link style are not possible . If an aspect ratio is specified , the layers are ellipses around the center . <p> **34;13862;TOOLONG - This is the same as mode IlvTreeLayoutRadialMode , with the exception that children of the same node are placed alternating in different circular layers , if this results in a smaller radius and better usage of the space . Tip over @ @ @ @ @ @ @ @ @ @ an aspect ratio is specified , the layers are ellipses around the center . <p> This feature sets the justification of the nodes within each level . It can be used in layout modes IlvTreeLayoutLevelMode , IlvTreeLayoutRadialMode , and **34;13898;TOOLONG . <p> If the nodes are center justified , all nodes of the same level are placed with their centers along a line . Otherwise , all nodes of the same level are placed with the specified border justified to a line . For instance if the link flow direction is to the right , the justification IlvLayoutNorthAlignment means that the nodes are justified to the left , and the justification IlvLayoutSouthAlignment means that the nodes are justified to the right . <p> In the radial layout modes , the justification IlvLayoutNorthAlignment means that the nodes are aligned along a circle with the border that is closer to the root , and justification IlvLayoutSouthAlignment means that the nodes are aligned along a circle with the border that is further away from the root . <p> This link style is only used if the global link style is set to IlvLayoutMixedLinkStyle @ @ @ @ @ @ @ @ @ @ If the global link style is not IlvLayoutMixedLinkStyle , all links of the spanning tree have the style that is specified as the global link style . Links that are not part of the spanning tree have the link style **27;13934;TOOLONG . <p> Valid values are : <p> **28;13963;TOOLONG - The link gets an orthogonal shape , that is , a shape consisting of a sequence of orthogonal line segments . This option is not available for the radial layout modes . <p> **30;13993;TOOLONG - The link gets a straight-line shape . <p> **27;14025;TOOLONG - No reshape is performed on the link . <p> This feature can be useful if the link can have intermediate points and is not a straight-line link , for instance , a link of type IlvPolylineLinkImage . <p> The default value is **30;14054;TOOLONG . <p> Note that , when the graph attached to the layout is of type IlvGrapher , the effect of link reshaping depends on the type of link . For the following link types , the reshaping has no effect : <p> However , if the option isLinkReplacementAllowed returns IlTrue , the @ @ @ @ @ @ @ @ @ @ all the links can be reshaped as needed . Note that in this case , the links that can not be reshaped can be replaced with new links of a different type . <p> This is the maximal angle between the two rays from the parent to its two outermost children . The angle must be between 0 and 360 degrees . The angle 0 means that the angle is unspecified . <p> The default value is 0 . <p> In radial mode , children of one single node may nearly cover completely one circular layer . This sometimes looks unbalanced , in particular because the links from the node to its outermost children are likely to cross other nodes . In order to avoid this effect , a maximal angle can be specified such that the children are placed more in the same direction and are not spread too widely around the parent . This angular restriction is applied to all children except the children of the root node . As a side effect , specifying a small maximal children angle enlarges the radius of the circles . <p> @ @ @ @ @ @ @ @ @ @ 180 degrees for good results . The algorithm uses a heuristic that has precision deviations below 30 degrees and above 180 degrees . If an aspect ratio is specified , the layout algorithm uses ellipses instead of circles . In this case , precision deviations may occur as well . <p> This is an expert option . It has no effect in layout modes other than radial . <p> Sets the percentage of the parent child offset that determines the location where the orthogonal link routing places the bends in order to fork the routing towards the children . <p> This has only effect if the orthogonal link style is chosen . <p> The default value is 45% . <p> This is an expert option . In all normal cases , it is not necessary to change the option . It is recommended to choose the orthogonal fork percentage always larger than the overlap percentage to obtain a good layout . <p> Sets the percentage a node is considered smaller in the flow direction . <p> This allows nodes to be placed closer together . However , in layout modes @ @ @ @ @ @ @ @ @ @ , outgoing links of a node may in seldom cases cross neighbored leaf nodes if the overlap percentage is high . In order to avoid this , set the parameter to 0% . <p> The default value is 30% , which is for many graphs a good compromise between wasting space and the risk of links crossing nodes . <p> This is an expert option . In all normal cases , it is not necessary to change the option . It is recommended to choose the orthogonal fork percentage always larger than the overlap percentage to obtain a good layout . <p> If the flow direction is towards the top or bottom and the layout mode is not radial , this is a vertical offset . If the flow direction is towards the left or right and the layout mode is not radial , this is a horizontal offset . If the layout mode is radial , this is an offset radial to the circle or ellipses . <p> If there are more than one connected components , it is possible to select a root for each component . If @ @ @ @ @ @ @ @ @ @ selected as root . For a directed tree , the canonical root node with indegree 0 is selected unless otherwise specified . <p> Setting the root node by this method is identical to setting the root preference of this node to 10000 . <p> The higher the preference , the more likely the node will be selected as root node . <p> If a negative value is passed as input , the preference of the node is unspecified , in which case the algorithm calculates a preference such that for directed trees the canonical root nodes with indegree 0 have the highest preference . <p> Sets the minimal offset between siblings , that is between nodes that have the same parent in the tree structure . <p> If the flow direction is towards the top or bottom and the layout mode is not radial , this is , a horizontal offset . If the flow direction is towards the left or right and the layout mode is not radial , this is a vertical offset . If the layout mode is radial , this is an offset tangential to the @ @ @ @ @ @ @ @ @ @ first neighbor at the same level to the west of the eastNode . This implies conversely that the eastNode is the first neighbor at the same level to the east of the westNode . <p> This method is identical to **28;14189;TOOLONG eastNode , IlAny westNode ) with reversed argument order , and is available for convenience . Note that , for instance , in flow direction towards the bottom , east is right of west , therefore it resembles more the argument order of setWestEastNeighboring , while in flow direction towards the top , east is left of west , therefore this resembles more the argument order of setEastWestNeighboring . <p> Indicates that this layout class allows the user to specify fixed nodes . <p> Fixed nodes are not moved during the layout if the method **32;14219;TOOLONG is called with an IlTrue argument . Links that are incident to fixed nodes are not reshaped during the layout . Fixed nodes are ignored by the Tree Layout algorithm , which may lead to node overlapping . The effect is similar to if the node is filtered away during layout . 
@@75678149 @4378149/ <p> **27;14253;TOOLONG is an ordered collection . That is , the items in the collection have a meaningful ordered relationship with respect to each other and can be accessed by an index number . In the case of **27;14282;TOOLONG , objects are inserted such that objects " less than " themselves are before the object , objects " greater than " themselves after the object . An insertion sort is used . Duplicates are allowed . <p> Stores a copy of the inserted item into the collection according to an ordering determined by the less-than ( &lt; ) operator . <p> Note that a sorted vector has a length ( the number of items returned by length() or entries() ) and a capacity . Necessarily , the capacity is always greater than or equal to the length . Although elements beyond the collection 's length are not used , nevertheless , in a value-based collection , they are occupied . If each instance of class T requires considerable resources , then you should ensure that the collection 's capacity is not much greater than its length , otherwise unnecessary @ @ @ @ @ @ @ @ @ @ possible to alter objects that are contained in a **27;14311;TOOLONG , it is dangerous since the changes may affect the way that operator&lt; ( ) and operator== ( ) behave , causing the **27;14340;TOOLONG to become unsorted . <p> Returns the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one . No bounds checking is performed . When used as an lvalue , care must be taken so as not to disturb the sortedness of the collection . <p> T&amp; operator ( sizet i ) ; const T&amp; operator ( sizet i ) const ; <p> Returns the ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between zero and the number of items in the collection less one , or an exception of type RWBoundsErr will be thrown . When used as an lvalue , care must be taken so as not to @ @ @ @ @ @ @ @ @ @ ith value in the vector . The first variant can be used as an lvalue , the second can not . The index i must be between 0 and the length of the vector less one , or an exception of type RWBoundsErr will be thrown . When used as an lvalue , care must be taken so as not to disturb the sortedness of the collection . <p> void clear() ; <p> Removes all items from the collection . <p> RWBoolean contains ( const T&amp; a ) const ; <p> Returns TRUE if the collection contains an item that is equal to a . A binary search is done . Equality is measured by the class-defined equality operator . <p> const T* data() const ; <p> Returns a pointer to the raw data of the vector . The contents should not be changed . Should be used with care . <p> sizet entries() const ; <p> Returns the number of items currently in the collection . <p> RWBoolean find ( const T&amp; target , T&amp; ret ) const ; <p> Performs a binary search and returns TRUE if the @ @ @ @ @ @ @ @ @ @ target and puts a copy of the matching object into ret . Returns FALSE otherwise and does not touch ret . Equality is measured by the class-defined equality operator . <p> const T&amp; first() const ; <p> Returns the first item in the collection . An exception of type RWBoundsErr will occur if the vector is empty . <p> sizet index ( const T&amp; a ) const ; <p> Performs a binary search , returning the index of the first item that is equal to a . Returns RWNPOS if there is no such item . Equality is measured by the class-defined equality operator . <p> void insert ( const T&amp; a ) ; <p> Performs a binary search , inserting a after all items that compare less than or equal to it , but before all items that do not . " Less Than " is measured by the class-defined ' &lt; ' operator for type T. The collection will be resized automatically if this causes the number of items to exceed the capacity . <p> RWBoolean isEmpty() const ; <p> Returns TRUE if there are no items in @ @ @ @ @ @ @ @ @ @ const ; <p> Returns the last item in the collection . If there are no items in the collection then an exception of type RWBoundsErr will occur . <p> sizet length() const ; <p> Returns the number of items currently in the collection . <p> sizet occurrencesOf ( const T&amp; a ) const ; <p> Performs a binary search , returning the number of items that are equal to a . Equality is measured by the class-defined equality operator . <p> RWBoolean remove ( const T&amp; a ) ; <p> Performs a binary search , removing the first object which is equal to the object a and returns TRUE . Returns FALSE if there is no such object . Equality is measured by the class-defined equality operator . <p> sizet removeAll ( const T&amp; a ) ; <p> Removes all items which are equal to a , returning the number removed . Equality is measured by the class-defined equality operator . <p> T removeAt ( sizet i ) ; <p> Removes and returns the object at index i . An exception of type RWBoundsErr will be thrown if i is @ @ @ @ @ @ @ @ @ @ to the number of items in the list less one . <p> T removeFirst() ; <p> Removes and returns the first object in the collection . An exception of type RWBoundsErr will be thrown if the list is empty . <p> T removeLast() ; <p> Removes and returns the last object in the collection . An exception of type RWBoundsErr will be thrown if the list is empty . <p> void resize ( sizet N ) ; <p> Changes the capacity of the collection to N. Note that the number of objects in the collection does not change , just the capacity . <p> Looks at the next object on the input stream strm and either creates a new collection off the heap and sets p to point to it , or sets p to point to a previously read instance . If a collection is created off the heap , then you are responsible for deleting it . 
@@75678151 @4378151/ <h> Data Types <h> Member Functions <p> RWFunctor0 represents the group of functors that are invoked without any arguments and whose invocation returns no value . <p> A function object , or a functor , is an object that encapsulates a call to an associated global or member function . When a functor is invoked , it calls the associated function . <p> Instances of class RWFunctor0 act as handles to functor implementations or bodies . Such implementations are created by using either the rwtMakeFunctor0() global functions or macros . Each of these methods creates a new body instance , and returns the handle to that instance . See the example below . <p> Note that although an instance of this class is invoked with no arguments , and returns no value , the encapsulated function may have both arguments and a return value . <p> The arguments that will be passed to the encapsulated function are provided to the functor at the time of creation . They are stored within the functor object , and are retrieved at the time of invocation . <p> Any return value of @ @ @ @ @ @ @ @ @ @ hence not passed back to the user . If you are interested in the function 's return value , see the RWTFunctorR0 group of classes . <p> Assignment operator . Detaches this handle instance from any functor body instance it currently references , and binds it to the functor body instance , if any , associated with the second handle instance . <p> void operator() ( void ) const ; <p> Invokes the functor , calling the encapsulated function . Throws an RWTHRInvalidPointer exception if the handle has no associated body . 
@@75678152 @4378152/ <p> A function object , or functor , is an object that encapsulates a call to an associated global or member function . When a functor is invoked , it calls the associated function . <p> The rwtMakeFunctor0 functions and macros are provided to construct functors based on the RWFunctor0 class . The RWFunctor0 class acts as the handle for a family of functor implementation classes based on the RWFunctor0Imp class . A functor based on RWFunctor0 is invoked with no arguments and returns no value , but the implementation classes can accept functions with up to three arguments and any return type . The values for the additional arguments are defined when an implementation class instance is constructed , and are passed to the function each time the functor is invoked . <p> Each rwtMakeFunctor0 function or macro instantiates and constructs an appropriate functor implementation class instance and returns an RWFunctor0 handle that is bound to that instance . <p> rwtMakeFunctor0 comes in two flavors . First , there is a set of overloaded global function templates . Since not all compilers are able to handle templates to @ @ @ @ @ @ @ @ @ @ a corresponding set of macros . The template functions are slightly easier to use and you only have to remember one name . The macros are more portable but they do require more arguments ; and because we can not overload macros , each must have a unique name . <p> In naming the macros we have employed a convention to make the names easier to remember . Each name begins with rwtMakeFunctor0 , which will be followed by either a G if the macro is expecting a global function , or an M if it is expecting a member function . At that point the name is complete if the associated global or member function takes no arguments . Otherwise we add one of A1 , A2 , or A3 for functions with 1 , 2 , or 3 arguments respectively . For example , you will use macro rwtMakeFunctor0G to create a functor that calls a global function that takes no arguments . The macro rwtMakeFunctor0MA2 will create a functor that calls a member function that takes two arguments . 
@@75678153 @4378153/ <h> News 2014 <p> Rogue Wave Software , the largest independent provider of cross-platform software development tools and embedded components , will be highlighting their products at Supercomputing 2014 conference from November 17-20 at Ernest N. Morial Convention Center in New Orleans . Rogue Wave will have new and updated product offerings , as well as several chances to educate , explore , and learn at this years conference . <p> Rogue Wave Software , the largest independent provider of cross-platform software development tools and embedded components , announces a new version of its static analysis tool , Klocwork . This release underscores the ongoing commitment by Rogue Wave to help software developers accelerate great code . <p> Getting bug free code can be time consuming . The loop created between a developer passing over code for testing , only to get it back for revision , can be a long one . It becomes longer when more developers are working on the same project as the matrix which becomes the solution shifts with every new input from a member of the team . <p> Klocwork , a global @ @ @ @ @ @ @ @ @ @ code , announced today it had been selected as a finalist for Red Herring 's Top 100 North America award , a prestigious list honoring the years most promising private technology ventures from the North American business region . Klocwork was acquired by Rogue Wave Software in January 2014 . <p> Rogue Wave Software , the largest independent provider of cross-platform software development tools and embedded components , announced an update release of its leading parallel debugger , TotalView 8.13 . <p> The UK Science and Technology Facilities Council ( STFC ) and Rogue Wave Software , the largest independent provider of cross-platform , software development tools and embedded components , have signed a Collaboration Agreement to work together on software tools to increase significantly the productivity of software development for scientific computing . <p> Rogue Wave Software today announced it will showcase the industrys first end-to-end toolset for deep software risk assessment and mitigation at the RSA Conference in San Francisco , California ( Feb. 24-28 ) and at Embedded World in Nuremberg , Germany ( Feb. 25-27 ) . 
@@75678155 @4378155/ <h> Server <h> Highly scalable modeling framework <p> Represent the elements and topology of a supervised system as shared in-memory services with Rogue Wave Server . Modeling abstractions match those offered by object-oriented design notation like UML , and Server bridges the gap between business model design and implementation . Because objects stored in the Server-based mediation server are active , all business events , such as object modifications and structural changes , are registered and buffered for forwarding to subscribing clients . <h> Synchronize hundreds of C++ GUIs <p> Define one or more mappings from the physical systems object model to the graphical model with ready-to-use graphical models for Views Data Access . GUI clients subscribe to a view of the sy of events , through bidirectionstem , such as a sub-part of the system or a categoryal connectors called Dynamic Views . The clients are notified when the system is modified , and can send modification requests to the server . The GUI can be connected using the fast communication layer for C++ . <h> High-performance notification engine <p> Hundreds of clients can be connected to a @ @ @ @ @ @ @ @ @ @ per second through our sophisticated optimization . Server supports a pyramid architecture in which low-level servers receive events for part of the network and report to a higher-level server that aggregates the events for a wider part of the network . This is particularly important for supervising very large systems , like region-wide telecommunications networks with millions of monitored elements . <h> Rapid prototyping <p> Develop customized prototypes in record time . Rapidly demonstrate a prototype for scalability or functionality tests with Server . The business object model corresponding to the supervised system can be defined using the XMI format , enabling communication with production specification environments , including IBM Rational . Server features an implementation of JavaScript , which enables code to be added to the server without the need for C++ compilation . Rapidly create a GUI through drag-and-drop editing , and connect it directly to the business object model . <h> Web-enabled supervision <p> Control-room managers often need to have a synthetic view of a system and see the status of the problems requiring attention . Server provides a specific client , based on the Java Servlet @ @ @ @ @ @ @ @ @ @ By providing both Java integration and thin-client capabilities , Server is ideal for creating Web-enabled supervision applications . 
@@75678157 @4378157/ <p> The radial layout mode partitions the node into levels and arranges the levels in circles around the root node . Radial Layout Mode shows an example of the radial layout mode . The compass icons show the compass directions in this drawing . <p> Most layout parameters that work for the free and level layout mode work as well for the radial layout mode . You can set the spacing offsets , the level justification , the global or individual link style , and the global or individual alignment . See Free Layout Mode and Level Layout Mode for details . <p> Here is a list of differences from the other modes : <p> The tip-over alignment does not work in radial layout mode . <p> The orthogonal link style does not work in radial mode . <p> The parent-child offset parameter controls the minimal distance between the circular levels . However , it is sometimes necessary to increase the offset between circular levels to obtain enough space on the circle to place all nodes of a level . <p> The level justification north means justification at the @ @ @ @ @ @ @ @ @ @ towards the root ) , and the level justification south means justification at the outer border of the circular level ( that is , away from the root ) . <p> The level justifications north and south sometimes result in node overlapping . <p> The overlap percentage has no effect in radial layout mode . <p> Alternating Radial Mode <p> If levels contain many nodes , it is sometimes necessary to increase the radius of the circular level to provide enough space on the circumference of the circle for all the nodes . This may result in a considerable distance from the previous level . To avoid this , there is an alternating radial mode . This mode places the nodes of a level alternating onto two circles instead of one circle , resulting in a better space usage of the layout . <p> The alternating radial mode uses two circles only when necessary . For many small and light trees , there will be no difference from the normal radial mode . Only for large graphs with a high degree of children will the alternating radial mode have an @ @ @ @ @ @ @ @ @ @ layout mode : <p> LONG ... <p> Radial and Alternating Radial Layout Mode <p> Aspect Ratio <p> If the drawing area is not a square , arranging levels as circles is not always the best choice . You can specify the aspect ratio of the drawing area to better fit the layout to the area . In this case , the algorithm uses ellipses instead of circles . See Sample Tree Layout in Radial Layout Mode with Aspect Ratio 1.3 for an example . <p> If the drawing area is a view ( a subclass of IlvAbstractView ) , you can use this method : <p> Note that the sibling and branch offsets are minimal distances tangential to the circles or ellipses , while the parent-child offset is a minimal distance radial to the circles or ellipses . Figure 4.17 shows the spacing parameters in radial mode . <p> Spacing Parameters in Radial Layout Mode <p> For Experts : Further Parameters <p> If a node has many children , they may cover a major part of the circle , and hence are placed nearly 360 degree around the node . @ @ @ @ @ @ @ @ @ @ deficiency can be fixed by increasing the offset between parent and children . However , this influences the layout globally , also affecting nodes without the deficiency . To avoid a global change , you can limit the maximal angle between the two rays from the parent ( if it is not the root ) to its two outermost children . This increases the offset between parent and children only where necessary . Use the following method to set and obtain the angle in degrees : <p> Recommended values are between 30 and 180 . Setting the value to 0 means the angle is unrestricted . The calculation of the angle is not very precise above 180 degrees , or if the aspect ratio is not 1.0. 
@@75678158 @4378158/ <h> Fortran Numerical Library <h> Embeddable numerical analysis functions for Fortran applications <p> The IMSL Fortran Numerical Library is the standard for high performance computing commercial mathematics and statistics libraries , providing : <p> Superior accuracy and reliability through 40 years of refinement <p> Embeddable in applications <p> A comprehensive set of 1000+ algorithms <p> Supporting parallel processing architectures since 1990 <p> Learn what 's new with in the latest release or see a full features list here . <p> Portable with software and hardware upgrades as wide range of OSs , compilers and chip sets are supported <p> Fully supported by Rogue Wave <p> " It was much faster to use procedures from the imsl fortran library than create those same procedures on my own . " <p> Dr. Rasmus Lents , University of Wisconsin <p> Professor , Department of Economics <h> The gold standard for over four decades <p> With over 1000 fully supported algorithms , the IMSL Fortran Numerical Library is the most comprehensive mathematics and statistics library available . Highly robust and reliable , it contains proven technology that has been thoroughly tested , well @ @ @ @ @ @ @ @ @ @ used by developers worldwide for four decades . Instead of writing , testing and documenting complex mathematical and statistical algorithms from scratch or getting them from open source , developers use the algorithms provided in the IMSL Fortran Numerical Library to help accelerate application development and time to market . <h> The original , easy-to-use Fortran Library <p> The IMSL Fortran Numerical Library is the most convenient to use Fortran library available today . Features that make your developers more productive include : <p> Convenient optional arguments : Allow users to utilize the fast , convenient optional arguments of modern Fortran syntax for all of the relevant algorithms in the library , saving significant coding time and helping to avoid errors <p> Backward compatibility : Ensuring that legacy code can run on future releases <p> Naming conventions : Function names resemble actual algorithm names , so users do not have to learn and remember special function names <p> Over 1,000 algorithms : The most comprehensive math and statistics library available 
@@75678160 @4378160/ <h> class CGXCheckBox : public CGXControl <p> The CGXCheckBox class implements a checkbox control that can be used in grid cells . When constructing a CGXCheckBox , you can choose between 3d-look and old MS Windows 3. x look . <p> You might also draw your own bitmaps for selected and unselected state and pass the resource i 'd of a bitmap to the CGXCheckBox constructor . Take a look at the default bitmaps in gxres.rc ( e.g. , GXIDBCHECK95 ) . <p> You can specify the checkbox text with CGXStyle : : SetChoiceList , and you can specify if you want to have tri-state checkbox with CGXStyle : : SetTriState.The user can change these style settings through the CGXStyleSheet dialog ( " control " -page ) . <p> The state of the checkbox is passed through the style objects value-attribute ( CGXStyle : : SetValue ) . The representation for the checked and unchecked state is set to be " 1 " and " 0 " by default ( as defined by the user attributes below ) . In a tri-state checkbox an empty string in the corresponding style @ @ @ @ @ @ @ @ @ @ specify the checked/unchecked representation in the style object with the user attributes GXIDSUACHECKBOXCHECKED and GXIDSUACHECKBOXUNCHECKED . The default setting is " 1 " for checked and " 0 " for unchecked . Other values are treated as undetermined . <p> the user clicks the checkbox , the controls OnClickedButton method is called . The default behavior of OnClickedButton is to toggle the checkbox state and store the new value in the grid . As a final step it calls CGXGridCore : : OnClickedButtonRowCol . <p> To process this event , you can either subclass CGXCheckBox and override the controls OnClickedButton method or simply override OnClickedButtonRowCol in your CGXGridCore-derived class . <p> The default ids for CGXCheckBox controls are : +GXIDSCTRLCHECKBOX with old Windows 3. x look+GXIDSCTRLCHECKBOX3D with newer 3d-look . <p> You can apply checkboxes to cells with <p> SetStyleRange ( range , CGXStyle() . **31;14369;TOOLONG ) ; <p> See the attached example , which shows how to implement an ownerdrawn checkbox . <p> #include &lt;gxall.h&gt; <h> Example <p> This sample class implements an ownerdrawn checkbox . When the bitmap is loaded from the resource file , all white pixels @ @ @ @ @ @ @ @ @ @ color as specified in the system settings . 
@@75678161 @4378161/ <h> 3.2 Setting Environment Variables <p> You must properly define all compiler-specific and database-specific environment variables and system settings before building the DBTools.h++ libraries . <p> Table 10 lists an environment variable for each of the DBTools.h++ access libraries and describes the typical settings required . The rest of this section provides operating system-specific instructions for setting the variables . <p> The environment variables can be set in your autoexec.bat file , by using the SET directive followed by the variable name for your database ( from Table 10 ) , an equal sign , ( " = " ) , and the name of the drive and directory that contains the header files and libraries . For example , to point to the Sybase Client-Library directory , include the following in your autoexec.bat file : <p> SET SYBASE=c : sybase <p> Including environment variables in your autoexec.bat file allows you to indicate the location of more than one database . You will need to reboot for the changes to autoexec.bat to take effect . <p> Append the name of the drive and directory that contains the header files @ @ @ @ @ @ @ @ @ @ the value that appears in the registry.MSVC users : The include path for ODBC is already entered if you are using MSVC . <p> lib <p> Append the name of the drive and directory that contains the libraries for your database to the existing lib path . Donotreplace the value that appears in the registry.MSVC users : The lib path for ODBC is already in place if you are using MSVC . <p> 1 <p> If your environment variables are already set for some other version of the same product , you may need to delete those references , or prepend the new data .. <p> If you are working in a Korn or a Bourne shell , use export to set the environment variable . Refer to Table 10 for the variable you must set for your database . For example , to set the variable for the Informix database , you might use something like the following : <p> export INFORMIXDIR=/informix <p> If you are running in other than a Bourne or Korn shell , you may be able to use setenv , as in the following : @ @ @ @ @ @ @ @ @ @ please check these two requirements : <p> The grep , sed , and dirname utilities must reside in /bin . If they do n't , use whereis &lt;file&gt; to determine the location of any utility that is not in /bin , then run a symbolic link from &lt;file&gt; to /bin using : <p> ln -s &lt;full path to file&gt; /bin . <p> The ksh utility is required when using SPM to build Rogue Wave products . If your Linux installation does not include ksh , create a symbolic link from zsh-- a shell provided with most , if not all Linux distributions--to /bin/ksh , using : 
@@75678164 @4378164/ <h> 5.1 Introducing the Serialization Package <p> The Serialization package provides a way to flatten objects , so they can be easily transported across communication boundaries or stored to disk . This object serialization mechanism includes two processes : <p> Translation of an object or set of related objects in memory into a linear series of atomic events or tokens <p> Translation of such a series back into an equivalent object or set of related objects <p> The classes , macros , and functions in the Serialization package help you to define serializable objects with a minimum of custom code , while retaining control over the formats and policies used . To make your C++ classes serializable , you prepare them with a small set of streaming macros . These macros encapsulate the details associated with streaming protocols , shielding your application from the implementation details but otherwise not affecting your application code . You have a choice of intrusive serialization for your own classes or external serialization for classes that you ca n't modify , such as classes from a third-party library . The package also includes a @ @ @ @ @ @ @ @ @ @ various formats . <p> Collectable classes can be streamed out in the Rogue Wave persistence format , or in the format of a particular object stream . To stream a collectable class in Rogue Wave persistence format you only need to include the RWCollectableIO.h header file and define the macro LONG ... for the class ( see Section 6.5.1 , " Using Object Streams with RWCollectable-Derived Objects . " ) . Now an object of this class will be embedded within the stream using the Rogue Wave persistence format ( regardless of the format of the object stream itself ) . To stream out a collectable in the format for the object stream you are using you must declare **30;14402;TOOLONG and then use the external serialization macros just as you would for a class from any other library ( see Section 6.5.2 , " Making RWCollectable Objects That Are Also Serializable . " ) . <p> The most common use for object serialization is to save the state of a program to disk , so that the state can be restored when the program starts again . Rather than developing @ @ @ @ @ @ @ @ @ @ to your application , you can use the Serialization package 's tools and industry-standard formats . <p> Object serialization is also useful for distributed applications . Often you run into the trade-off between passing a reference to a remote object from one process to another or passing the object itself between processes . If the objects are not large , have static state , and will be accessed often , you may decide to send them by value between processes . Rather than writing custom network protocols to transmit application objects and writing code to read and write these protocols , you can use the Serialization package , which transmits serialized objects as blocks of raw data using generic protocols . 
@@75678165 @4378165/ <h> SourcePro Net <p> SourcePro Net handles the creation of secure or non-secure networked and Internet-enabled applications by focusing on the granular details of socket programming and Internet protocols . Ddesigned with a layered architecture , Developers can code with the most abstract layer for ease of use , or access the protocol layer if they need fine control over critical details . <h> SourcePro Net Modules <p> Offers an intuitive , high-level API for networking applications , allowing developers to focus on their application logic . This module is designed with a flexible three-layer architecture . The low-level Communication Adapter Layer offers fine-grained control over the details of the socket protocol while the Portal Layer provides a single interface to multiple platforms , network services and protocols . Finally , the high-level Communication Services Layer allows for transport-independent communication services , letting developers stream data across a network without needing to know how the data is sent . <p> Provide a clean , intuitive API for developing Internet-enabled client-side applications , abstracting away the complexity of dealing directly with the granular details of the major Internet protocols : @ @ @ @ @ @ @ @ @ @ and SMTP . <p> The module provides conditional support for the HTTP 1.1 specification , including support for PUT , TRACE , DELETE , OPTIONS , GET , POST and HEAD , as well as user-defined methods . It also facilitates connections with multiple servers for improved performance and offers support for persistent connections , resumable downloading and authorization . <p> The Internet Protocols Module is designed with a two-layer architecture . The Agent Layer offers a simple , higher-level interface to major Internet protocols , while the Client Layer provides control over the fine-grained details of a given protocol . <p> Finally , the MIME Package in the Internet Protocols module offers a higher-level , intuitive API that encapsulates the low-level details of the MIME message format . <p> The Secure Communication Module also offers a C++ API to the SSL/TLS implementations , including the Open SSL implementation , providing a higher-level , consistent C++ interface to the security algorithms . <p> Perform complete protocol transactions with minimal code to quickly add Internet capabilities to C++ client applications or drill down for control over the fine-grained details of the @ @ @ @ @ @ @ @ @ @ <p> Provides a C++ implementation of key areas of the latest HTTP specification , allowing developers to take advantage of specification improvements and create Internet applications conforming to the latest standards . <p> C++ encapsulation of the MIME message format <p> Encapsulates the low-level details of the MIME message format with a higher-level , intuitive API , reducing development time and allowing developers to quickly add MIME support to their applications . <p> Support for both encryption and authentication ( X509 certificates ) <p> Provides everything needed to quickly implement a simple secure connection between a client and a server . <p> Intuitive API for secure communication using HTTPS <p> Higher-level , intuitive API to the HTTPS protocol reduces development time because developers do n't have to deal with protocol level code . <p> Based on proven , respected SSL/TLS implementations <p> Higher-level , consistent C++ interface to the leading vendors ' security algorithms that developers know and trust . 
@@75678168 @4378168/ <h> Static Public Member Functions 50231 @qwx670231 <p> Abstract base class for interactors . <p> Library : views <p> This class let 's you define a behavior that can be associated with an IlvGraphic object . <p> IlvInteractor instances can be shared between several graphic objects . Each subclass can provide a predefined shared instance that is stored in a registry . This instance can be accessed by its registered name through the IlvInteractor : : Get function . To register a predefined shared instance , you must use the **32;14434;TOOLONG macro in the implementation file of your interactor . <p> Warning : <p> Interactor instances should never be allocated on the stack as they are automatically deleted with the delete operator when they are no longer referenced ( see the IlvInteractor : : unLock method ) . <p> If you provide a non-0 pointer to an array of strings in the parameter names , it is set on return to point to an array of strings that describe each of the callback types . Some of these descriptions may be 0 . You must not modify nor delete this @ @ @ @ @ @ @ @ @ @ array of symbols in the parameter types , it is set on return to point to an array of symbols that define each of the callback types . You must not modify nor delete this array . If you create a new callback type and want it returned by a call to getCallbackTypes , you can use the static member function IlvGraphic : : AddToCallbackTypeList . The default implementation registers one callback with the shared name of the interactor as symbol . For example , the IlvMoveInteractor class has a callback registered on the symbol " Move " . 50234 @qwx670234 <p> count <p> The number of elements in the returned arrays names and types . This parameter must be set to 0 before calling this method . 
@@75678169 @4378169/ <h> Community Manager - API Developer Portal <p> Community Manager is an API Portal that enables API producers to engage partners and developers and help them onboard , manage and test their Apps . Community Manager unites API providers and App developers through a single common portal that can be easily branded and customized . Community Manager allows API Providers to publish , document , promote and support their APIs , and App Developers to easily find , consume and get support for the APIs their Apps use . <h> Engage and Onboard your Developers and Partners <p> Attract and support developers and partners with a customized , secure online API Portal . Quickly onboard partners and establish active social channels with them . Help developers find the right API , make API provisioning and key management a snap and walk developers through a simple process with easy to understand approvals for getting access to APIs . <p> Enable a community with discussions , tickets , alerts , reviews and ratings . <p> Allow developers to learn how to use APIs with searchable documentation <h> Package and License APIs @ @ @ @ @ @ @ @ @ @ for partners and developers to consume your APIs , license them accordingly , and maximize revenue based on usage . Create different service-levels ( i.e. Platinum , Silver , Bronze ) and guide partners gradually through the levels . <h> Personalized Dashboard and Notifications <p> Keep partners engaged and provide them with personalized dashboards for analytics and monitoring of API and App performance . Provide partners with insights into how your APIs are driving their business and allow them to explore areas where they can further optimize and grow . <p> View real-time API performance , usage metrics and API health <p> Monitor medium and long-term trends <p> Powerful alert management , monitoring , and distribution . <h> Dynamic API Documentation and Testing Tools <p> Allow API administrators to upload and manage API documentation and tables of contents . Keep track of versions and allow for rollback if needed . Reduce the effort involved in authoring API documents with dynamically generated documents . <p> Support multiple countries with multi-language support <p> Control visibility of documents and document elements based on licenses <p> Users can request access to an API on @ @ @ @ @ @ @ @ @ @ selecting from pre-defined policies - initiating a workflow process with optional approval and activation steps involving the administrators of the API and App . The default workflow provides for : <p> Automatic approval and activation of requests to a sandbox API endpoint <p> API administrator approval required for access to production endpoints <p> App administrator activation required for production access <p> API administrators can suspend and reactivate , or even cancel an Apps access to their API <p> Akana Community Manager is a sophisticated developer community product that helps enterprises attract , manage , support , and communicate among the developers who build apps using their APIs . Learn more . 
@@75678170 @4378170/ <h> com.imsl.stat Class LinearRegression <p> Fits a multiple linear regression model with or without an intercept . If the constructor argument hasIntercept is true , the multiple linear regression model is <p> where the observed values of the ' s constitute the responses or values of the dependent variable , the ' s , ' s , ' s are the settings of the independent variables , are the regression coefficients , and the ' s are independently distributed normal errors each with mean zero and variance . If hasIntercept is false , is not included in the model . <p> LinearRegression computes estimates of the regression coefficients by minimizing the sum of squares of the deviations of the observed response from the fitted response <p> for the observations . This minimum sum of squares ( the error sum of squares ) is in the ANOVA output and denoted by <p> In addition , the total sum of squares is output in the ANOVA table . For the case , hasIntercept is true ; the total sum of squares is the sum of squares of the deviations of from @ @ @ @ @ @ @ @ @ @ ; it is denoted by <p> For the case hasIntercept is false , the total sum of squares is the sum of squares of --the so-called uncorrected total sum of squares ; it is denoted by <p> See Draper and Smith ( 1981 ) for a good general treatment of the multiple linear regression model , its analysis , and many examples . <p> In order to compute a least-squares solution , LinearRegression performs an orthogonal reduction of the matrix of regressors to upper triangular form . Givens rotations are used to reduce the matrix . This method has the advantage that the loss of accuracy resulting from forming the crossproduct matrix used in the normal equations is avoided , while not requiring the storage of the full matrix of regressors . The method is described by Lawson and Hanson , pages 207-212 . <p> From a general linear model fitted using the ' s as the weights , inner class **31;14468;TOOLONG can also compute predicted values , confidence intervals , and diagnostics for detecting outliers and cases that greatly influence the fitted regression . Let be a column vector @ @ @ @ @ @ @ @ @ @ The leverage is defined as <p> ( In the case of linear equality restrictions on , the leverage is defined in terms of the reduced model . ) Put with if the -th diagonal element of is positive and 0 otherwise . The leverage is computed as where is a solution to . The estimated variance of <p> is given by , where . The computation of the remainder of the case statistics follows easily from their definitions . <p> Let denote the residual <p> for the th case . The estimated variance of is where is the residual mean square from the fitted regression . The th standardized residual ( also called the internally studentized residual ) is by definition <p> and follows an approximate standard normal distribution in large samples . <p> The th jackknife residual or deleted residual involves the difference between and its predicted value based on the data set in which the th case is deleted . This difference equals . The jackknife residual is obtained by standardizing this difference . The residual mean square for the regression in which the th case is deleted @ @ @ @ @ @ @ @ @ @ and follows a distribution with degrees of freedom . <p> Cook 's distance for the th case is a measure of how much an individual case affects the estimated regression coefficients . It is given by <p> Weisberg ( 1985 ) states that if exceeds the 50-th percentile of the distribution , it should be considered large . ( This value is about 1 . This statistic does not have an distribution . ) <p> DFFITS , like Cook 's distance , is also a measure of influence . For the th case , DFFITS is computed by the formula <p> Hoaglin and Welsch ( 1978 ) suggest that greater than <p> is large . <p> Often predicted values and confidence intervals are desired for combinations of settings of the effect variables not used in computing the regression fit . This can be accomplished using a single data matrix by including these settings of the variables as part of the data matrix and by setting the response equal to Double.NaN . LinearRegression will omit the case when performing the fit and a predicted value and confidence interval for the missing @ @ @ @ @ @ @ @ @ @ effect variables . <h> getCaseStatistics <p> Returns the case statistics for an observation and future response count for the desired prediction interval . 50234 @qwx670234 <p> x - a double array containing the independent ( explanatory ) variables . Its length must be equal to the number of variables set in the constructor . <p> y - a double representing the dependent ( response ) variable <p> pred - an int representing the number of future responses for which the prediction interval is desired on the average of the future responses . <p> Returns : <p> the CaseStatistics for the observation . <h> getCoefficients <p> public double getCoefficients() <p> Returns the regression coefficients . <p> Returns : <p> a double array containing the regression coefficients . If hasIntercept is false its length is equal to the number of variables . If hasIntercept is true then its length is the number of variables plus one and the 0-th entry is the value of the intercept . <h> getCoefficientTTests <h> getR <p> Returns a copy of the R matrix . R is the upper triangular matrix containing the R matrix from a @ @ @ @ @ @ @ @ @ @ : <p> a double matrix containing a copy of the R matrix <h> getRank <p> public int getRank() <p> Returns the rank of the matrix . <p> Returns : <p> the int rank of the matrix <h> update <p> public void update ( double x , double y ) <p> Updates the regression object with a new set of observations . 50234 @qwx670234 <p> x - a double matrix containing the independent ( explanatory ) variables . The number of rows in x must equal the length of y and the number of columns must be equal to the number of variables set in the constructor . <p> y - a double array containing the dependent ( response ) variables . <h> update <p> public void update ( double x , double y , double w ) <p> Updates the regression object with a new set of observations and weights . 50234 @qwx670234 <p> x - a double matrix containing the independent ( explanatory ) variables . The number of rows in x must equal the length of y and the number of columns must be equal to the number @ @ @ @ @ @ @ @ @ @ a double array containing the dependent ( response ) variables . <p> w - a double array representing the weights <h> update <p> public void update ( double x , double y ) <p> Updates the regression object with a new observation . 50234 @qwx670234 <p> x - a double array containing the independent ( explanatory ) variables . Its length must be equal to the number of variables set in the constructor . <p> y - a double representing the dependent ( response ) variable <h> update <p> public void update ( double x , double y , double w ) <p> Updates the regression object with a new observation and weight . 50234 @qwx670234 <p> x - a double array containing the independent ( explanatory ) variables . Its length must be equal to the number of variables set in the constructor . 
@@75678171 @4378171/ <h> 2.2 The Servlet Container and Web Applications <p> At Agent startup , the servlet container loads , initializes , and deploys the servlets so they are ready and waiting for requests . When a request arrives , it enters the Agent through the connectors , which pass it to the default http handler chain , then to the servlet handler , and finally to the servlet container . The container translates the request into C++ objects and passes it to the proper servlet . The servlet processes the request and returns a response to the handler chain , which passes it back up to the Agent 's connectors and back to the requestor . <p> The servlet container is designed to perform well while serving large numbers of requests . A container can hold any number of active servlets , filters , listeners , or named objects . Both the container and the objects in it are multithreaded . The servlet container creates and manages threads as necessary to handle incoming requests . The container handles multiple requests concurrently , and more than one thread may enter an @ @ @ @ @ @ @ @ @ @ a servlet container must be threadsafe . <p> Figure 1 presents a diagram of a running container . In the diagram , the servlet container has a single network connector . The container manages two contexts , each of which contains a number of objects . <p> Servlet requests are received through the connectors in the HydraExpress message transport layer . A servlet need not interact with the network itself . The Agent connectors handle the details of the network connection . The servlet container handles the necessary translation of the incoming message data format to the C++ objects needed by the servlet . <p> The servlet container can manage any number of distinct applications . A C++ application consists of any number of servlets , filters , listeners , and static Web pages . A set of components working together is a web application . The servlet container uses a context to group related components . The container loads the objects within a context as a group , and objects within the same context can easily share data . Therefore , each context usually corresponds to a distinct Web @ @ @ @ @ @ @ @ @ @ context directories must be deployed to the servlet deployment directory , **30;14501;TOOLONG . Each directory within the servlets directory defines a context . The name of the context directory is the name of the context and determines the path to the servlets within the context . Each context directory contains a WEB-INF directory , and may also contain files related to the application . Each WEB-INF directory contains a web.xml file . The web.xml file describes the configuration of the context and the servlets , filters , and listeners that occupy the context . <p> For example , the directory structure below describes two contexts , one named orders and one named catalog . The catalog context contains a static HTML page , intro.html . <p> If the HydraExpress Agent is at http : //example.com , an HTML page at LONG ... appears at the URL LONG ... Likewise , servlets defined in the LONG ... file appear at URLs underneath http : //example.com/orders . <p> The Rogue Wave name and logo are registered trademarks of Rogue Wave Software , and HydraExpress is a trademark of Rogue Wave Software . @ @ @ @ @ @ @ @ @ @ Rogue Wave about documentation or support issues . 
@@75678174 @4378174/ <h> CGXGridCore : : ResizeColWidthsToFit <p> Specifies the range of cells through which ResizeColWidthsToFit will loop to find the optimal width for the affected columns . <p> bResizeCoveredCells <p> TRUE if covered cells which span several columns shall be resized , FALSE if covered cells shall be ignored . <p> nFlags <p> Specifies the update technique : <p> GXUPDATENOW specifies to update the window after each column-width change . <p> GXINVALIDATE simply invalidates the window area to the right of the first column that is resized . <p> GXNOSHRINKSIZE specifies that the column-width should not become smaller . Columns shall only be enlarged . <h> Return Value <p> TRUE if command succeeded ; FALSE if command failed or user aborted the operation . <p> If you do a series of commands , you should check the return value and abort your operation ( or rollback the transaction ) if the return value is FALSE . <h> Remarks <p> Call this command to automatically resize the column-widths for a given range of cells . <p> ResizeColWidthsToFit will loop through each cell in the range and call the associated controls CalcSize @ @ @ @ @ @ @ @ @ @ For each column , ResizeColWidthsToFit calculates the maximal width from the individual cells . <p> If there is a covered cell and the specified range includes all columns spanned by the covered cell , and bResizeCoveredCells is TRUE , ResizeColWidthsToFit will resize the last column of the covered cell . <p> The user can abort the operation . <p> All SetColWidth commands are packed in a transaction ( BeginTrans , CommitTrans block ) . Therefore , the user can undo all changes with one undo-command . <p> Control-Factory Specific -&gt; <p> This method has been implemented using the abstraction mechanism as discussed in the chapter " Reducing the size of your application " in the user 's guide . A call to the ImplementResizeToFit method from within the control factory class ' InitializeGridComponents method will make the concrete implementation of this method available to your application . <p> If no concrete implementation is available this method returns FALSE . A warning will be displayed in the debug window . 
@@75678176 @4378176/ <p> Quality improvement charts have a variety of uses . In this library the charts are organized into three broad groups : Shewhart control charts , other control charts and process improvement charts . The Shewhart control charts were originally described by the statistician Dr. Walter A. Shewhart ( 1931 ) . Since this early work , other charts have been developed for engineering and management analysis of processes . In the 1980s customized charts were developed for other retrospective analysis of quality management data . <p> Shewhart Charts <p> While working for Western Electric in the 1920s , Dr. Shewhart developed a general , practical approach to statistical monitoring of manufacturing processes . He advised managers on implementing these within Western Electric and later published his work in Shewhart ( Montgomery , 1931 ) . All Shewhart control charts share several characteristics in common . First , the horizontal axis represents time or lot sequence , but they all have different vertical axes , depending upon the chart time . <p> Next , all Shewhart control charts have a center line that is drawn parallel to the time @ @ @ @ @ @ @ @ @ @ but the value of the process mean can vary depending upon which data are first used to design the chart . In some cases it will be the mean of the data plotted , in others it could be the mean calculated from a much larger number of measurements on the historical operation of the process . <p> Lastly , all Shewhart control charts have lines drawn to represent either the upper or lower control limits . In most cases both control lines are present , in others where the data have a natural bound , such as zero , only one of these control limits might be drawn . <p> Shewhart control charts are also broadly classified into two groups : variable and attribute data . Variables control charts are used when the quality of interest is a continuous variable , such as the diameter of a valve . If w is a continuous measure of a quality of interest , with mean and within-sample standard deviation , then the center line is at and the upper and lower controls limits are at Typically k=3 and the charts are @ @ @ @ @ @ @ @ @ @ used when qualities , not quantities are measured . For example , items may be characterized as conforming or nonconforming to a specification . Items may also be characterized as defective or nondefective . Examples of attributes include the number of failures in a manufacturing run or the number of defects on a computer chip wafer . <p> P-charts and np-charts are used for plotting the percentage or number of defective items in a sample , respectively . Inspectors , for example , might inspect 100 items in a subgroup and record the number of items with one or more defects . These can be plotted using either the number of defects or the percentage of defects found in each subgroup . In JMSL , class PChart produces p-charts for plotting the percentage of nonconforming items , and class NpChart produces an np-chart for the number of nonconforming items . In general , when the subgroup sample sizes are unequal a p-chart is used to adjust for unequal samples ; otherwise an np-chart is used to display the number of defective items . <p> In some cases , instead of @ @ @ @ @ @ @ @ @ @ of defects of all types might be recorded . For example , the packaging for a semiconductor might be inspected for solder defects such as bridging , insufficient solder , bent leads , etc . The total number of all such defects might be recorded for a sample . Theoretically there is no upper bound on the total number of defects found in a sample . These are typically plotted using a c-chart or u-chart , depending upon whether the sample size or area is constant from one subgroup to another . In JMSL , c-charts are implemented in class CChart and u-charts are implemented in class UChart . <p> If a single item can have multiple defects then a CChart or UChart is used , depending upon whether the area inspected for defect is consistent or varying . An example of multiple defects per item would be the count of the number of scratches on mirrors . If all samples have an equal opportunity for defects use CChart , otherwise use UChart . So to monitor the number of scratches on mirrors use CChart when all mirrors being made @ @ @ @ @ @ @ @ @ @ made that are sized differently . <p> In JMSL the ShewhartControlChart class is the base of a number of classes ; it is not usually used by itself . Most of the charts in this chapter extend ShewhartControlChart . <p> The following diagram can be used to determine the appropriate control chart to be used in a given situation . <p> Variables Control Charts : <p> XbarR estimates and using the ranges of the samples . It is best used when the sample size of a continuous variable is between 2 and 10 . <p> RChart plots the sample ranges . It is typically used in conjunction with XbarR . <p> XbarS estimates and using the means and standard deviations of the samples . It is best used when the sample size of a continuous variable is at least 10 . <p> SChart plots the sample standard deviations . It is typically used in conjunction with XbarS . <p> XmR is a moving range chart . It is used when the sample size of a continuous variable is one . <p> EWMA ( Exponentially Weighted Moving-Average ) plots weighted moving @ @ @ @ @ @ @ @ @ @ of a continuous variable is one . <p> Attribute Control Charts : <p> NpChart plots the number of defects . It is used when defects are not rare . <p> PChart plots the rate of defects . It is used when defects are not rare . <p> TheCuSum and CuSumStatus charts are more efficient than Shewhart charts at detecting small shifts in the process mean because the plot represents the moving average of the cumulative differences between the process and its target ( centerline ) . <p> Cumulative Probability <p> Cumulative probability charts are used if the defect rate is so small that there will be long runs when the number of defects is zero . 
@@75678177 @4378177/ <h> class CGXComboBox : public CGXEditControl <p> The CGXComboBox class implements a text input control that can be used to display and edit text in cells . The user can modify this text in place or select an item from a drop-down list box . <p> As with any other control , the user can change any style attributes with the CGXStyleSheet dialog . <p> By default , the list of choices which are displayed in the drop-down list is determined through the SetChoiceList attribute of the style object , but is also possible to fill the list box at runtime by subclassing CGXComboBox and overriding the virtual method OnFillDroppedList . <p> See the attached example showing how to override GetStyleRowCol and determine the choice list at runtime . This is very useful if the choice list depends on other cells values . Before you start subclassing CGXComboBox and override the OnFillDroppedList member to fill the drop-down list at runtime , consider whether overriding GetStyleRowCol might be an easier solution . There will be no difference in performance . <p> See the description of CGXEditControl for other style attributes @ @ @ @ @ @ @ @ @ @ following control ids are predefined in Objective Grid : <p> GXIDSCTRLTEXTFIT limit user input to entries in the choice list <p> GXIDSCTRLCOMBOBOX allow user to input any text <p> GXIDSCTRLONEBASED use an integer as cell value and display the integer value in the cell <p> GXIDSCTRLZEROBASED use a zero-based integer as cell value and display the integer value in the cell <p> GXIDSCTRLONEBASEDEX use an integer as cell value but display the associated entry from the choice list in the cell <p> GXIDSCTRLZEROBASEDEX use a zero-based integer as cell value but display the associated entry from the choice list in the cell <p> The cell will display " Item 1 " in both cases , but in the first sample , the text is stored as value in the style object , and in the second sample , the index is stored in the style object , so you can later simply call <p> nIndex = atoi ( GetValueRowCol ( nRow , nCol ) ) ; <p> to determine the index of the entry selected by the user . <p> Note : Objective Grid also provides an alternative combo-box control @ @ @ @ @ @ @ @ @ @ is derived from the Windows standard combo-box control CcomboBox , whereas CGXComboBox is a CGXEditControl with a small button at the right side of the input area . CGXComboBox has the advantage of fitting better into cells ( needs less row-height ) , whereas CGXComboBoxWnd offers full CComboBox functionality . <p> Note : When you are using the CGXComboBox with a grid that is a control in a dialog , you should override the dialogs OnNcActivate method to prevent the dialog title bar from flickering . The following code should be added to your dialog class : 
@@75678178 @4378178/ <h> 2.9 Stored Procedures <p> The DB Access Module for Oracle OCI includes support for RWDBStoredProc that is analogous to PL/SQL procedures and functions . ( See the Oracle PL/SQL Language Reference . ) OCI call OCIDescribeAny() is used to get parameter information for procedures and functions . SQL statements are made to create procedures and functions , to get their text , and to execute them . <p> Note that PL/SQL differentiates between stored functions and procedures . PL/SQL functions can not be created with the createProcedure() method of RWDBDatabase that we describe in the next section . Instead , you must use the executeSql() method of RWDBConnection . PL/SQL functions can be executed using class RWDBStoredProc and the return value can be obtained using RWDBStoredProc : : returnValue() . <p> It is currently not possible to use RWDBStoredProc to encapsulate a PL/SQL procedure or function that has parameters of the Oracle datatypes CLOB and BLOB . <p> A stored procedure is created using the CREATE OR REPLACE PROCEDURE ... SQL statement . You can create the procedure by using the RWDBDatabase : : createProcedure() call . In @ @ @ @ @ @ @ @ @ @ stored procedure must be supplied . The body should contain the following : <p> &lt;declarations&gt; BEGIN &lt;statements&gt; END ; <p> The following simple procedure to debit an account provides an example . The procedure takes two input parameters and one output parameter . The input parameters are the amount and the acctid , and the output parameter is the new balance , newbal . <p> After a stored procedure is created , it can be executed by instantiating an RWDBStoredProc and calling the execute() method . See the SourcePro C++ API Reference Guide for more information . It is the responsibility of the programmer to make sure that his or her stored procedure can be compiled by the PL/SQL compiler . <p> Input and output parameters can be passed to stored procedures . The DB Interface Module uses RWDBColumn to describe a parameter to a stored procedure . <p> The RWDBStoredProc : : fetchReturnParams() must be used to load the output parameters . <p> There is no limit on the number of input and output parameters that can be exchanged between an RWDBStoredProc and a PL/SQL procedure . <p> The @ @ @ @ @ @ @ @ @ @ cursor variables . A cursor variable is a reference to a cursor that is defined and opened on an Oracle server . In the following sample stored procedure , written in PL/SQL , myCursor is a cursor variable . <p> create package myProcPkg as type cursvar is ref cursor return employees%ROWTYPE ; end myProcPkg ; create procedure myProc ( myDept in number , myCursor in out myProcPkg.cursvar , mySalary in number ) as begin open myCursor for select * from employees where DEPTNO = myDept and SALARY &lt;= mySalary ; end myProc ; <p> The DB Interface Module enables your application to receive an RWDBResult containing the result sets returned by the reference cursors from the execution of a stored procedure . Notice in the following code fragment that the user does not explicitly shift a cursor parameter into the procedure : <p> increase the performance of stored procedures by eliminating the usual parameter fetch required for instantiations . The schema can come from previously cached procedure schema , through RWDBStoredProc : : params() , or from user-created schema . The user-created schema must include the name and the type @ @ @ @ @ @ @ @ @ @ type is unknown , the native type should be used . The native type , if set , is used first to avoid type mapping . The column should be supplied for any return value and must include a name and the datatype. 50235 