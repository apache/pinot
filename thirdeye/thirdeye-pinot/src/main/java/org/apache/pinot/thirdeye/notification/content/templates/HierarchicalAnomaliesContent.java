/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.pinot.thirdeye.notification.content.templates;

import com.google.common.base.Joiner;
import java.util.Arrays;
import org.apache.commons.lang3.StringUtils;
import org.apache.pinot.pql.parsers.utils.Pair;
import org.apache.pinot.thirdeye.datalayer.dto.DetectionAlertConfigDTO;
import org.apache.pinot.thirdeye.anomaly.ThirdEyeAnomalyConfiguration;
import org.apache.pinot.thirdeye.anomaly.detection.AnomalyDetectionInputContextBuilder;
import org.apache.pinot.thirdeye.anomalydetection.context.AnomalyFeedback;
import org.apache.pinot.thirdeye.anomalydetection.context.AnomalyResult;
import org.apache.pinot.thirdeye.common.metric.MetricTimeSeries;
import org.apache.pinot.thirdeye.datalayer.dto.AnomalyFunctionDTO;
import org.apache.pinot.thirdeye.datalayer.dto.DatasetConfigDTO;
import org.apache.pinot.thirdeye.datalayer.dto.EventDTO;
import org.apache.pinot.thirdeye.datalayer.dto.MergedAnomalyResultDTO;
import org.apache.pinot.thirdeye.datalayer.pojo.AlertConfigBean.COMPARE_MODE;
import org.apache.pinot.thirdeye.datalayer.util.ThirdEyeStringUtils;
import org.apache.pinot.thirdeye.datasource.DAORegistry;
import org.apache.pinot.thirdeye.detector.function.AnomalyFunctionFactory;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import org.apache.pinot.thirdeye.notification.content.BaseNotificationContent;
import org.apache.pinot.thirdeye.rootcause.impl.MetricEntity;
import org.apache.pinot.thirdeye.util.ThirdEyeUtils;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.Period;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * This email content formatter provides a hierarchical view of anomalies. It categorizes the anomalies by its dimensions.
 * The top-level anomalies are defined as anomalies generated by anomaly function without dimension drill-down; otherwise,
 * it is in the lower-level anomalies. The content formatter takes hierarchical-anomalies-email-template.ftl in default.
 */
public class HierarchicalAnomaliesContent extends BaseNotificationContent {
  private static final Logger LOG = LoggerFactory.getLogger(HierarchicalAnomaliesContent.class);

  private static final String PRESENT_SEASONAL_VALUES = "presentSeasonalValues";
  private static final String DEFAULT_PRESENT_SEASONAL_VALUES = "false";

  private boolean presentSeasonalValues;
  private Set<EventDTO> relatedEvents;

  public HierarchicalAnomaliesContent() {}

  @Override
  public void init(Properties properties, ThirdEyeAnomalyConfiguration config) {
    super.init(properties, config);
    relatedEvents = new HashSet<>();
    presentSeasonalValues = Boolean.valueOf(properties.getProperty(PRESENT_SEASONAL_VALUES, DEFAULT_PRESENT_SEASONAL_VALUES));
  }

  @Override
  public String getTemplate() {
    return HierarchicalAnomaliesContent.class.getSimpleName();
  }

  @Override
  public Map<String, Object> format(Collection<AnomalyResult> anomalies, DetectionAlertConfigDTO subsConfig) {
    Map<String, Object> templateData = super.getTemplateData(subsConfig, anomalies);
    enrichMetricInfo(templateData, anomalies);
    List<AnomalyReportEntity> rootAnomalyDetails = new ArrayList<>();
    SortedMap<String, List<AnomalyReportEntity>> leafAnomalyDetails = new TreeMap<>();
    List<String> anomalyIds = new ArrayList<>();
    List<AnomalyResult> anomalyList = new ArrayList<>(anomalies);
    Collections.sort(anomalyList, new Comparator<AnomalyResult>() {
      @Override
      public int compare(AnomalyResult o1, AnomalyResult o2) {
        return Double.compare(o1.getWeight(), o2.getWeight());
      }
    });

    for (AnomalyResult anomalyResult : anomalyList) {
      if (!(anomalyResult instanceof MergedAnomalyResultDTO)) {
        LOG.warn("Anomaly result {} isn't an instance of MergedAnomalyResultDTO. Skip from alert.", anomalyResult);
        continue;
      }
      MergedAnomalyResultDTO anomaly = (MergedAnomalyResultDTO) anomalyResult;

      // include notified alerts only in the email
      if (includeSentAnomaliesOnly) {
        if (anomaly.isNotified()) {
          putAnomaliesIntoRootOrLeaf(anomaly, rootAnomalyDetails, leafAnomalyDetails);
          anomalyIds.add(Long.toString(anomaly.getId()));
        }
      } else {
        putAnomaliesIntoRootOrLeaf(anomaly, rootAnomalyDetails, leafAnomalyDetails);
        anomalyIds.add(Long.toString(anomaly.getId()));
      }
    }
    List<EventDTO> sortedEvents = new ArrayList<>(relatedEvents);
    Collections.sort(sortedEvents, new Comparator<EventDTO>() {
      @Override
      public int compare(EventDTO o1, EventDTO o2) {
        return Long.compare(o1.getStartTime(), o2.getStartTime());
      }
    });
    templateData.put("containsSeasonal", presentSeasonalValues);
    templateData.put("rootAnomalyDetails", rootAnomalyDetails);
    templateData.put("leafAnomalyDetails", leafAnomalyDetails);
    templateData.put("holidays", sortedEvents);
    templateData.put("anomalyIds", Joiner.on(",").join(anomalyIds));

    return templateData;
  }

  /**
   * Generate the AnomalyReportEntity
   * @param anomaly
   * @param dashboardHost
   * @return
   */
  private AnomalyReportEntity generateAnomalyReportEntity(MergedAnomalyResultDTO anomaly, String dashboardHost) {
    AnomalyFeedback feedback = anomaly.getFeedback();

    String feedbackVal = getFeedbackValue(feedback);

    Properties props = new Properties();
    props.putAll(anomaly.getProperties());
    double lift = BaseNotificationContent.getLift(anomaly.getAvgCurrentVal(), anomaly.getAvgBaselineVal());
    AnomalyReportEntity
        anomalyReport = new AnomalyReportEntity(String.valueOf(anomaly.getId()),
        getAnomalyURL(anomaly, dashboardHost),
        getPredictedValue(anomaly),
        getCurrentValue(anomaly),
        getFormattedLiftValue(anomaly, lift),
        getLiftDirection(lift),
        anomaly.getImpactToGlobal(),
        getDimensionsList(anomaly.getDimensionMap()),
        getTimeDiffInHours(anomaly.getStartTime(), anomaly.getEndTime()), // duration
        feedbackVal,
        anomaly.getFunction().getFunctionName(),
        "",
        anomaly.getMetric(),
        getDateString(anomaly.getStartTime(), dateTimeZone),
        getDateString(anomaly.getEndTime(), dateTimeZone),
        getTimezoneString(dateTimeZone),
        getIssueType(anomaly),
        anomaly.getType().getLabel(),
        ThirdEyeStringUtils.encodeCompactedProperties(props),
        anomaly.getMetricUrn()
    );

    List<String> affectedCountries = getMatchedFilterValues(anomaly, "country");
    if (affectedCountries.size() > 0) { // if the anomaly is on country level
      Map<String, List<String>> targetDimensions = new HashMap<>();
      targetDimensions.put(EVENT_FILTER_COUNTRY, affectedCountries);
      relatedEvents.addAll(getHolidayEvents(
          new DateTime(anomaly.getStartTime(), dateTimeZone),
          new DateTime(anomaly.getEndTime(), dateTimeZone),
          targetDimensions));
    }

    return anomalyReport;
  }

  /**
   * Generate the AnomalyReportEntity and determine if the given anomaly is root or leaf level
   * @param anomaly
   * @param rootAnomalyDetail
   * @param leafAnomalyDetail
   * @return
   */
  private AnomalyReportEntity putAnomaliesIntoRootOrLeaf(MergedAnomalyResultDTO anomaly,
      List<AnomalyReportEntity> rootAnomalyDetail, SortedMap<String, List<AnomalyReportEntity>> leafAnomalyDetail){
    AnomalyReportEntity anomalyReport = generateAnomalyReportEntity(anomaly, thirdEyeAnomalyConfig.getDashboardHost());
    AnomalyFunctionDTO anomalyFunction = anomaly.getFunction();
    String exploredDimensions = anomalyFunction.getExploreDimensions();
    // Add WoW number
    if (presentSeasonalValues) {
      for (COMPARE_MODE compareMode : COMPARE_MODE.values()) {
        double avgValues = Double.NaN;
        try {
          avgValues = getAvgComparisonBaseline(anomaly, compareMode, anomaly.getStartTime(), anomaly.getEndTime());
        } catch (Exception e) {
          LOG.warn("Unable to fetch wow information for {}.", anomalyFunction);
        }
        anomalyReport.setSeasonalValues(compareMode, avgValues, anomaly.getAvgCurrentVal());
      }
    }
    if (StringUtils.isBlank(exploredDimensions)) {
      rootAnomalyDetail.add(anomalyReport);
    } else {
      if (!leafAnomalyDetail.containsKey(exploredDimensions)) {
        leafAnomalyDetail.put(exploredDimensions, new ArrayList<AnomalyReportEntity>());
      }
      leafAnomalyDetail.get(exploredDimensions).add(anomalyReport);
    }
    return anomalyReport;
  }

  /**
   * Retrieve the average wow baseline values
   * @param anomaly an instance of MergedAnomalyResultDTO
   * @param compareMode the way to compare, WoW, Wo2W, Wo3W, and Wo4W
   * @param start the start time of the monitoring window in millis
   * @param end the end time of the monitoring window in millis
   * @return baseline values based on compareMode
   * @throws Exception
   */
  private Double getAvgComparisonBaseline(MergedAnomalyResultDTO anomaly, COMPARE_MODE compareMode,
      long start, long end) throws Exception{
    AnomalyFunctionFactory anomalyFunctionFactory = new AnomalyFunctionFactory(thirdEyeAnomalyConfig.getFunctionConfigPath());
    AnomalyFunctionDTO anomalyFunction = anomaly.getFunction();
    DatasetConfigDTO datasetConfigDTO = DAORegistry.getInstance().getDatasetConfigDAO()
        .findByDataset(anomalyFunction.getCollection());
    AnomalyDetectionInputContextBuilder contextBuilder = new AnomalyDetectionInputContextBuilder(anomalyFunctionFactory);
    contextBuilder.setFunction(anomalyFunction);

    DateTimeZone timeZone = DateTimeZone.forID(datasetConfigDTO.getTimezone());
    DateTime startTime = new DateTime(start, timeZone);
    DateTime endTime = new DateTime(end, timeZone);

    Period baselinePeriod = getBaselinePeriod(compareMode);
    DateTime baselineStartTime = startTime.minus(baselinePeriod);
    DateTime baselineEndTime = endTime.minus(baselinePeriod);

    Pair<Long, Long> timeRange = new Pair<>(baselineStartTime.getMillis(), baselineEndTime.getMillis());
    MetricTimeSeries
        baselineTimeSeries = contextBuilder.fetchTimeSeriesDataByDimension(Arrays.asList(timeRange), anomaly.getDimensions(), false)
        .build().getDimensionMapMetricTimeSeriesMap().get(anomaly.getDimensions());

    return baselineTimeSeries.getMetricAvgs(0d)[0];
  }
}
