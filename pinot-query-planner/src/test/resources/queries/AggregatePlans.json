{
  "aggregates_planning_tests": {
    "queries": [
      {
        "description": "Select AVG aggregation for a BIG_DECIMAL column",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col4) as avg FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[CAST(AVG_REDUCE(CAST($0):DECIMAL(1000, 0) NOT NULL, $1)):DECIMAL(1000, 0)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n          LogicalProject(col2=[$1], col3=[$2], col4=[$3])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'pink floyd'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select many aggregations for a BIG_DECIMAL column",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col4) as avg, SUM(a.col4) as sum, MAX(a.col4) as max FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[CAST(AVG_REDUCE(CAST($0):DECIMAL(1000, 0) NOT NULL, $1)):DECIMAL(1000, 0)], sum=[$0], max=[$2])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)], agg#2=[MAX($2)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)], agg#2=[MAX($2)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($2)], agg#1=[COUNT()], agg#2=[MAX($2)])",
          "\n          LogicalProject(col2=[$1], col3=[$2], col4=[$3])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'pink floyd'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) as avg, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[CAST(AVG_REDUCE($0, $1)):DOUBLE], count=[$1])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n          LogicalProject(col2=[$1], col3=[$2])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'pink floyd'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT KURTOSIS(a.col3) as kurtosis, DISTINCTCOUNT(a.col1) as dcount, MIN(a.col6), BOOL_AND(a.col5) FROM a WHERE a.col3 >= 0 AND a.col2 = 'iron maiden'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[KURTOSIS($0)], agg#1=[DISTINCTCOUNT($1)], agg#2=[MIN($2)], agg#3=[BOOLAND($3)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[DISTINCTCOUNT($1)], agg#2=[MIN($2)], agg#3=[BOOLAND($3)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($2)], agg#1=[DISTINCTCOUNT($0)], agg#2=[MIN($4)], agg#3=[BOOLAND($3)])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2], col5=[$4], col6=[$5])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'iron maiden'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), COUNT(a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates for COUNT variations",
        "sql": "EXPLAIN PLAN FOR SELECT DISTINCTCOUNT(a.col3), COUNT(DISTINCT a.col3), COUNT(a.col3), COUNT(*), DISTINCTCOUNT(a.col5) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[$1], EXPR$2=[$2], EXPR$3=[$2], EXPR$4=[$3])",
          "\n  LogicalAggregate(group=[{}], agg#0=[DISTINCTCOUNT($0)], agg#1=[DISTINCTCOUNT(DISTINCT $1)], agg#2=[COUNT($2)], agg#3=[DISTINCTCOUNT($3)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[DISTINCTCOUNT($0)], agg#1=[DISTINCTCOUNT(DISTINCT $1)], agg#2=[COUNT($2)], agg#3=[DISTINCTCOUNT($3)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[DISTINCTCOUNT($2)], agg#1=[DISTINCTCOUNT(DISTINCT $2)], agg#2=[COUNT()], agg#3=[DISTINCTCOUNT($4)])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), COUNT(*) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select transform inside aggregate with filters",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(ADD(a.col3, a.col6)), AVG(MOD(a.col6, a.col3)), MIN(ABS(a.col6)) FROM a WHERE a.col3 >= 0 AND a.col2 = 'hooloovoo'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[CAST(AVG_REDUCE($1, $2)):DOUBLE], EXPR$2=[$3])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[MIN($3)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[MIN($3)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT()], agg#3=[MIN($2)])",
          "\n          LogicalProject($f0=[ADD($2, $5)], $f1=[MOD($5, $2)], $f2=[ABS($5)])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'hooloovoo'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select ORDER BY on aggregate with filters",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col6), AVG(a.col3), KURTOSIS(ABS(a.col6)) FROM a WHERE a.col3 >= 0 AND a.col2 = 'zaphoid beeblebrox' ORDER BY SUM(a.col6), AVG(a.col3) DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0, 1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], sort1=[$1], dir0=[ASC], dir1=[DESC])",
          "\n      LogicalProject(EXPR$0=[$0], EXPR$1=[CAST(AVG_REDUCE($1, $2)):DOUBLE], EXPR$2=[$3])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[KURTOSIS($3)])",
          "\n          LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[FOURTHMOMENT($3)])",
          "\n            PinotLogicalExchange(distribution=[hash])",
          "\n              LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[$SUM0($1)], agg#2=[COUNT()], agg#3=[FOURTHMOMENT($2)])",
          "\n                LogicalProject(col6=[$5], col3=[$2], $f2=[ABS($5)])",
          "\n                  LogicalFilter(condition=[AND(>=($2, 0), =($1, 'zaphoid beeblebrox'))])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select transform inside aggregate with transform inside filters",
        "sql": "EXPLAIN PLAN FOR SELECT SKEWNESS(ADD(a.col3, a.col6)), DISTINCTCOUNT(ABS(a.col6)) FROM a WHERE a.col3 >= 0 AND REVERSE(a.col2) = 'oovoolooh'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[SKEWNESS($0)], agg#1=[DISTINCTCOUNT($1)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[DISTINCTCOUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[DISTINCTCOUNT($1)])",
          "\n        LogicalProject($f0=[ADD($2, $5)], $f1=[ABS($5)])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =(REVERSE($1), 'oovoolooh'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select more aggregates with filters",
        "sql": "EXPLAIN PLAN FOR SELECT SKEWNESS(a.col3), AVG(a.col3), BOOL_OR(a.col5), SUM(a.col3), AVG(a.col6), MAX(a.col6) FROM a WHERE a.col3 >= 0 AND a.col2 = 'rolling stones'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[CAST(AVG_REDUCE($1, $2)):DOUBLE], EXPR$2=[$3], EXPR$3=[$1], EXPR$4=[CAST(AVG_REDUCE($4, $2)):DOUBLE], EXPR$5=[$5])",
          "\n  LogicalAggregate(group=[{}], agg#0=[SKEWNESS($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[BOOLOR($3)], agg#4=[$SUM0($4)], agg#5=[MAX($5)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[$SUM0($1)], agg#2=[COUNT($2)], agg#3=[BOOLOR($3)], agg#4=[$SUM0($4)], agg#5=[MAX($5)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($1)], agg#1=[$SUM0($1)], agg#2=[COUNT()], agg#3=[BOOLOR($2)], agg#4=[$SUM0($3)], agg#5=[MAX($3)])",
          "\n          LogicalProject(col2=[$1], col3=[$2], col5=[$4], col6=[$5])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'rolling stones'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select kurtosis and skewness with limit",
        "sql": "EXPLAIN PLAN FOR SELECT SKEWNESS(a.col3), KURTOSIS(a.col3) FROM a LIMIT 100",
        "output": [
          "Execution Plan",
          "\nLogicalSort(fetch=[100])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalAggregate(group=[{}], agg#0=[SKEWNESS($0)], agg#1=[KURTOSIS($1)])",
          "\n      LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[FOURTHMOMENT($1)])",
          "\n        PinotLogicalExchange(distribution=[hash])",
          "\n          LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($2)], agg#1=[FOURTHMOMENT($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) as sum, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'pink floyd'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias. The group by aggregate hint should be a no-op.",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ AVG(a.col3) as avg, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[CAST(AVG_REDUCE($0, $1)):DOUBLE], count=[$1])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalAggregate(group=[{}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n          LogicalProject(col2=[$1], col3=[$2])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'pink floyd'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias. The group by aggregate hint should be a no-op.",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ SUM(a.col3) as sum, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'queen'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'queen'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias. The group by aggregate hint should be a no-op.",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ KURTOSIS(a.col3) as kurtosis, SKEWNESS(a.col6) as skewness, COUNT(DISTINCT a.col6), COUNT(DISTINCT a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'metallica'",
        "output": [
          "Execution Plan",
          "\nLogicalAggregate(group=[{}], agg#0=[KURTOSIS($0)], agg#1=[SKEWNESS($1)], agg#2=[DISTINCTCOUNT(DISTINCT $2)], agg#3=[DISTINCTCOUNT(DISTINCT $3)])",
          "\n  LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($0)], agg#1=[FOURTHMOMENT($1)], agg#2=[DISTINCTCOUNT(DISTINCT $2)], agg#3=[DISTINCTCOUNT(DISTINCT $3)])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{}], agg#0=[FOURTHMOMENT($1)], agg#1=[FOURTHMOMENT($2)], agg#2=[DISTINCTCOUNT(DISTINCT $2)], agg#3=[DISTINCTCOUNT(DISTINCT $1)])",
          "\n        LogicalProject(col2=[$1], col3=[$2], col6=[$5])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'metallica'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      }
    ]
  }
}