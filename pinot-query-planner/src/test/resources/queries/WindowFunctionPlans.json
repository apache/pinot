{
  "window_function_planning_tests": {
    "queries": [
      {
        "description": "single empty OVER() only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, SUM(a.col3) OVER() AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$1], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a ORDER BY a.col2 LIMIT 20",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[20])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[20])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER() FROM a WHERE a.col3 > 10",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[>($2, 10)])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), MIN(a.col3) OVER() FROM a where a.col1 IN ('foo', 'bar')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(=($3, 'bar'), =($3, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER() FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}], EXPR$0=[$SUM0($1)])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], EXPR$0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER() FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n                LogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, SUM(a.col3) OVER() AS sum, COUNT(a.col2) OVER() AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with default frame on one but not the other",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), MIN(a.col3) OVER() FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a LIMIT 100",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[100])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[100])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), SUM(a.col3) OVER(), MAX(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(), COUNT(a.col1) OVER() FROM a WHERE a.col3 > 100",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[>($2, 100)])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT LENGTH(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(), MAX(a.col3) OVER() FROM a where a.col1 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[LENGTH(CONCAT($3, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($3, 'bar'), <>($3, 'baz'), <>($3, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(), COUNT(a.col1) OVER() FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(), MAX(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}], EXPR$0=[$SUM0($1)])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], EXPR$0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3]])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$2], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n                LogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) only with alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$2], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} aggs [MIN($1)])])",
          "\n          LogicalExchange(distribution=[hash[2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} aggs [MIN($1)])])",
          "\n          LogicalExchange(distribution=[hash[2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($3, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($3, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($3, 'bar'), <>($3, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], EXPR$0=[$SUM0($1)])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], EXPR$0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0)])])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n                LogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1), COUNT(a.col2) OVER(PARTITION BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$1], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), MIN(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [COUNT($1), MIN($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (non-avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), MAX($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n          LogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (non-avg agg) with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), MAX($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key but in reverse order and select col with global order by (non-avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col1, a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), MAX($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key but in reverse order and select col with global order by (avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col1, a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($4):DOUBLE NOT NULL, $5)])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on non-select column",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3]])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[REVERSE($2)], EXPR$1=[$3], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), MAX($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), COUNT(a.col1) OVER(PARTITION BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($3, 'chewbacca':VARCHAR(9)), =($3, 'vader':VARCHAR(9)), =($3, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [MIN($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col3), COUNT(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY) with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(PARTITION BY a.col1), AVG(a.col3) OVER(PARTITION BY a.col1) FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[$2], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [MIN($0), SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(PARTITION BY a.col3), SUM(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0), SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], EXPR$0=[$SUM0($1)])",
          "\n        LogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], EXPR$0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3]])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0), MAX($0)])])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[$SUM0($2)])",
          "\n                LogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(ORDER BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$2], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [MAX($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(ORDER BY a.col1 DESC) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [2 DESC] aggs [MIN($1)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[2 DESC]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(ORDER BY a.col1 DESC) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [2 DESC] aggs [MIN($1)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[2 DESC]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($3, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($3, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($3, 'bar'), <>($3, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1), COUNT(a.col2) OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [2] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1) AS max, COUNT(a.col2) OVER(ORDER BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [2] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), MIN(a.col3) OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(ORDER BY a.col1) AS avg, MIN(a.col3) OVER(ORDER BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$1], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [COUNT($1), MIN($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(ORDER BY a.col2, a.col1 DESC), AVG(a.col3) OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[DESC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0 DESC]])",
          "\n    LogicalSort(sort0=[$0], dir0=[DESC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [0, 2 DESC] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[0, 2 DESC]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), MIN(a.col3) OVER(ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n            LogicalProject(col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(ORDER BY a.col2, a.col1 DESC), AVG(a.col3) OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[DESC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[0 DESC]])",
          "\n    LogicalSort(sort0=[$0], dir0=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [0, 2 DESC] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash], collation=[[0, 2 DESC]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(ORDER BY a.col2), MAX(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[REVERSE($2)], EXPR$1=[$3], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), MAX($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), COUNT(a.col1) OVER(ORDER BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($3, 'chewbacca':VARCHAR(9)), =($3, 'vader':VARCHAR(9)), =($3, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(ORDER BY a.col1), MAX(a.col3) OVER(ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [MIN($0), MAX($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(order by [2] aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) only with alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$2], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} order by [2] aggs [MIN($1)])])",
          "\n          LogicalExchange(distribution=[hash[2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} order by [2] aggs [MIN($1)])])",
          "\n          LogicalExchange(distribution=[hash[2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3 ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($3, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($3, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($3, 'bar'), <>($3, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by has different direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 DESC] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by has different null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 NULLS FIRST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 ASC-nulls-first] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by different direction and null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 DESC NULLS LAST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 DESC-nulls-last] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [2] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [2] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$1], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [COUNT($1), MIN($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3, 0]])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} order by [0, 2] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n          LogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3, 0]])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} order by [0, 2] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalExchange(distribution=[hash[0, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[REVERSE($2)], EXPR$1=[$3], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), MAX($1)])])",
          "\n    LogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), COUNT(a.col1) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($3, 'chewbacca':VARCHAR(9)), =($3, 'vader':VARCHAR(9)), =($3, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [MIN($0), MAX($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [2] aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[REVERSE(CONCAT($3, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 DESC] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 NULLS FIRST), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 NULLS FIRST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 ASC-nulls-first] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different direction and null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC NULLS LAST), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC NULLS LAST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 DESC-nulls-last] aggs [SUM($0), COUNT($0), MIN($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) only",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$2], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [MAX($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} order by [0] aggs [MIN($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[2]])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$0], EXPR$1=[$3], col1=[$2])",
          "\n        LogicalWindow(window#0=[window(partition {2} order by [0] aggs [MIN($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [2] aggs [COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash[1]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3], $3=[SUBSTR($3, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$3], EXPR$1=[/(CAST($4):DOUBLE NOT NULL, $5)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3], $3=[CONCAT($3, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($3, 'bar'), <>($3, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY REVERSE(a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[1]])",
          "\n      LogicalProject(col3=[$2], $1=[REVERSE($1)], $2=[CONCAT($3, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key only (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3), COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [1] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key only (single window group) with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col3) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [1] aggs [MAX($1), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col (single window group) with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$2], avg=[/(CAST($3):DOUBLE NOT NULL, $4)], min=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with default frame for one and not the other (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [COUNT($1), MIN($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} order by [1, 2] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[0, 2]], collation=[[1, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with LIMIT (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[]])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n        LogicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by with LIMIT (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0], fetch=[10])",
          "\n  LogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$2], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0, 2} order by [1, 2] aggs [SUM($1), COUNT($1)])])",
          "\n          LogicalSortExchange(distribution=[hash[0, 2]], collation=[[1, 2]])",
          "\n            LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and transform col (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4], $2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [SUM($1), MAX($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[0]], collation=[[2]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3], $3=[REVERSE($3)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key select col and filter (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), COUNT(a.col1) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($1), COUNT($1), COUNT($2)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($3, 'chewbacca':VARCHAR(9)), =($3, 'vader':VARCHAR(9)), =($3, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with select transform and filter (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4], $2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [MIN($1), MAX($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[2]], collation=[[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col1=[$3], $3=[REVERSE(CONCAT($3, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2) with transform on partition key (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($4):DOUBLE NOT NULL, $5)], EXPR$1=[$6])",
          "\n  LogicalWindow(window#0=[window(partition {3} order by [2] aggs [SUM($0), COUNT($0), COUNT($1)])])",
          "\n    LogicalSortExchange(distribution=[hash[3]], collation=[[2]])",
          "\n      LogicalProject(col3=[$2], col1=[$3], $2=[CONCAT($3, '-', $1)], $3=[REVERSE(CONCAT($3, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function with JOIN example",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, b.col1, SUM(a.col3) OVER (PARTITION BY a.col1) FROM a JOIN b ON a.col1 = b.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], col10=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0)])])",
          "\n    LogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$0], col1=[$1], col10=[$3])",
          "\n        LogicalJoin(condition=[=($1, $2)], joinType=[inner])",
          "\n          LogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col3=[$2], col1=[$3])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n          LogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col2=[$1], col1=[$3])",
          "\n              LogicalTableScan(table=[[b]])",
          "\n"
        ]
      },
      {
        "description": "Window function with GROUP BY example with aggregation used within ORDER BY clause in OVER",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), AVG(a.col3) OVER(ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[$2], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [2 DESC, 1] aggs [SUM($0), COUNT($0)])])",
          "\n    LogicalSortExchange(distribution=[hash], collation=[[2 DESC, 1]])",
          "\n      LogicalAggregate(group=[{0, 1}], EXPR$1=[$SUM0($2)])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}], EXPR$1=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function with GROUP BY example with aggregation used within ORDER BY clause in OVER with PARTITION BY",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$1], EXPR$1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [2 DESC, 1] aggs [MAX($0)])])",
          "\n    LogicalSortExchange(distribution=[hash[1]], collation=[[2 DESC, 1]])",
          "\n      LogicalAggregate(group=[{0, 1}], EXPR$1=[$SUM0($2)])",
          "\n        LogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{2, 3}], EXPR$1=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      }
    ]
  },
  "exception_throwing_window_function_planning_tests": {
    "queries": [
      {
        "description": "unsupported window functions such as row_number()",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3 ROWS BETWEEN 5 PRECEDING AND 10 FOLLOWING) FROM a WHERE a.col3 >= 0",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(ORDER BY a.col3 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(), MAX(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Using aggregation inside ORDER BY within OVER",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY MAX(a.col3)) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Using aggregation inside PARTITION BY within OVER",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col1) OVER(PARTITION BY AVG(a.col3)) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Select an aggregate along with OVER()",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), COUNT(a.col1) OVER() FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "External group by clause",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2) FROM a GROUP BY a.col2",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Global order by aggregate",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY SUM(a.col3)",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Wrong table",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(b.col3) OVER(PARTITION BY b.col1 ORDER BY b.col2) FROM a ORDER BY SUM(b.col3)",
        "expectedException": "Error explain query plan for.*"
      }
    ]
  }
}