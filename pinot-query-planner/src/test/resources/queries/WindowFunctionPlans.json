{
  "window_function_planning_tests": {
    "queries": [
      {
        "description": "single empty OVER() only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() count(*) only",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(*) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [COUNT()])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(winLiteral=[0])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() literal, count(*) only",
        "sql": "EXPLAIN PLAN FOR SELECT 42, COUNT(*) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[42], EXPR$1=[$0])",
          "\n  LogicalProject($0=[$1])",
          "\n    LogicalWindow(window#0=[window(aggs [COUNT()])])",
          "\n      PinotLogicalExchange(distribution=[hash])",
          "\n        LogicalProject(winLiteral=[0])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() only row_number",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(winLiteral=[0])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() row_number and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n  PinotLogicalExchange(distribution=[hash])",
          "\n    LogicalProject(col1=[$0])",
          "\n      LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, SUM(a.col3) OVER() AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() row_number and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER() FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], col2=[$1])",
          "\n        LogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER() FROM a ORDER BY a.col2 LIMIT 20",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[20])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[20])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), SUM(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER() FROM a WHERE a.col3 > 10",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalFilter(condition=[>($2, 10)])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() row_number select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER() FROM a WHERE a.col3 > 10",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n  PinotLogicalExchange(distribution=[hash])",
          "\n    LogicalProject(col1=[$0])",
          "\n      LogicalFilter(condition=[>($2, 10)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), MIN(a.col3) OVER() FROM a where a.col1 IN ('foo', 'bar')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(=($0, 'bar'), =($0, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER() FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER() FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n                PinotLogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() row_number with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), ROW_NUMBER() OVER() FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[$2], col3=[$0])",
          "\n        LogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n                PinotLogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, SUM(a.col3) OVER() AS sum, COUNT(a.col2) OVER() AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with default frame on one but not the other",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), MIN(a.col3) OVER() FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($2), COUNT($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a LIMIT 100",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[100])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[100])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($2), COUNT($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(), COUNT(a.col2) OVER() FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($2), COUNT($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), SUM(a.col3) OVER(), MAX(a.col3) OVER() FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), MAX($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(), COUNT(a.col1) OVER() FROM a WHERE a.col3 > 100",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalFilter(condition=[>($2, 100)])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT LENGTH(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(), MAX(a.col3) OVER() FROM a where a.col1 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), MAX($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$2], $1=[LENGTH(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($0, 'bar'), <>($0, 'baz'), <>($0, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s row_number with select transform and filter",
        "notes": "ROW_NUMBER requires ROWS as the default frame, and the default frame cannot be overridden, thus it cannot be combined with other functions yet",
        "sql": "EXPLAIN PLAN FOR SELECT LENGTH(CONCAT(a.col1, ' ', a.col2)), ROW_NUMBER() OVER(), ROW_NUMBER() OVER() FROM a where a.col1 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[$1], EXPR$2=[$1])",
          "\n  LogicalWindow(window#0=[window( rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject($0=[LENGTH(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($0, 'bar'), <>($0, 'baz'), <>($0, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), SUM($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(), COUNT(a.col1) OVER() FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(), MAX(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(aggs [MIN($0), MAX($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple empty OVER()s with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$2])",
          "\n  LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single empty OVER() with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(), SUM(a.col3) OVER() FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$2], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(aggs [SUM($0), COUNT($0)])])",
          "\n          PinotLogicalExchange(distribution=[hash])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n                PinotLogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number only",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) only with alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, ROW_NUMBER() OVER(PARTITION BY a.col2) AS row_num FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [MIN($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {1} aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [MIN($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, ROW_NUMBER() OVER(PARTITION BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), ROW_NUMBER() OVER(PARTITION BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col3=[$2], $1=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {1} aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject($0=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(PARTITION BY a.col1) FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) row_number with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col1) FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(partition {0} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n  PinotLogicalExchange(distribution=[hash[0]])",
          "\n    LogicalProject(col1=[$0])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY) with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n                PinotLogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1), COUNT(a.col2) OVER(PARTITION BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), MIN(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "notes": "Calcite validation fails if RANGE is used but later Calcite overrides ROWS with RANGE",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (non-avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), MAX($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (non-avg agg) with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), MAX($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key but in reverse order and select col with global order by (non-avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), MAX(a.col3) OVER(PARTITION BY a.col1, a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), MAX($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on select column (avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s row_number on the same key but in reverse order and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col2, a.col1), ROW_NUMBER() OVER(PARTITION BY a.col1, a.col2) FROM a ORDER BY a.col1",
        "notes": "ROW_NUMBER requires ROWS as the default frame, and the default frame cannot be overridden, thus it cannot be combined with other functions yet",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$2], $2=[$3])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER(), ROW_NUMBER()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key but in reverse order and select col with global order by (avg agg)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col1, a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($4):DOUBLE NOT NULL, $5)])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and select col with global order by on non-select column",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1) FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1), COUNT(a.col1) OVER(PARTITION BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($1), MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with group by",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col3), COUNT(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY) with select col and group by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, MIN(a.col3) OVER(PARTITION BY a.col1), AVG(a.col3) OVER(PARTITION BY a.col1) FROM a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($1), SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0, 1}])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate and group by",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), MIN(a.col3) OVER(PARTITION BY a.col3), SUM(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [MIN($0), SUM($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate avg and group by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0), MAX($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY)s with aggregate avg and group by and order by",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3), AVG(a.col3) OVER(PARTITION BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col3) FROM a GROUP BY a.col3 ORDER BY a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], dir0=[ASC])",
          "\n      LogicalProject(EXPR$0=[$1], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4], col3=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} aggs [SUM($0), COUNT($0), MAX($0)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col3=[$0], EXPR$0=[/(CAST($1):DOUBLE NOT NULL, $2)])",
          "\n              LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)])",
          "\n                PinotLogicalExchange(distribution=[hash[0]])",
          "\n                  LogicalAggregate(group=[{2}], agg#0=[$SUM0($2)], agg#1=[COUNT()])",
          "\n                    LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) only rank",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col dense_rank",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(ORDER BY a.col2 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [1 DESC] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col with global order by on different column as inside over",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) rank and select col with global order by on different column as inside over",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col with global order by on same column as inside over",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(ORDER BY a.col2) FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) dense_rank and select col with global order by on same column as inside over",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(ORDER BY a.col2) FROM a ORDER BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [DENSE_RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col with order by on row number",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(ORDER BY a.col2) as row_number FROM a ORDER BY row_number DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$1], dir0=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$1], dir0=[DESC])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) RANK and select col with order by on row number",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(ORDER BY a.col2) as rank FROM a ORDER BY rank DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$1], dir0=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$1], dir0=[DESC])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) dense_rank and select col with order by on row number",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(ORDER BY a.col2) as dense_rank FROM a ORDER BY dense_rank DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$1], dir0=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$1], dir0=[DESC])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [DENSE_RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(ORDER BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, ROW_NUMBER() OVER(ORDER BY a.col2) AS row_number FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) rank and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, RANK() OVER(ORDER BY a.col2) AS rank FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [MAX($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(ORDER BY a.col1 DESC) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(order by [0 DESC] aggs [MIN($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) rank and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], $1=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [1] aggs [RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(ORDER BY a.col1 DESC) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(order by [0 DESC] aggs [MIN($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) dense_rank and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, DENSE_RANK() OVER(ORDER BY a.col1 DESC) FROM a ORDER BY a.col3 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col3=[$2])",
          "\n        LogicalWindow(window#0=[window(order by [0 DESC] aggs [DENSE_RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) rank and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), RANK() OVER(ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col3=[$2], $1=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) dense_rank select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, DENSE_RANK() OVER(ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(order by [0] aggs [DENSE_RANK()])])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalProject(col2=[$1])",
          "\n      LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), ROW_NUMBER() OVER(ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) rank with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), RANK() OVER(ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) with transform on order by key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) row_number with transform on order by key",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject($0=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(ORDER BY) dense_rank with transform on order by key",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject($0=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1), COUNT(a.col2) OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key only - rank functions",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(ORDER BY a.col1), DENSE_RANK() OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [RANK(), DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(ORDER BY a.col1) AS max, COUNT(a.col2) OVER(ORDER BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), MIN(a.col3) OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col3, DENSE_RANK() OVER(ORDER BY a.col1), RANK() OVER(ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col3=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [DENSE_RANK(), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(ORDER BY a.col1) AS avg, MIN(a.col3) OVER(ORDER BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with select alias, one ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, DENSE_RANK() OVER(ORDER BY a.col1) AS dense_rank, MIN(a.col3) OVER(ORDER BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [DENSE_RANK(), MIN($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [COUNT($1), MIN($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with default frame for one and not the other - one ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), RANK() OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [COUNT($1), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(ORDER BY a.col2, a.col1 DESC), AVG(a.col3) OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[DESC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [1, 0 DESC] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(ORDER BY a.col2, a.col1 DESC), AVG(a.col3) OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[DESC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($4):DOUBLE NOT NULL, $5)])",
          "\n        LogicalWindow(window#0=[window(order by [1, 0 DESC] aggs [RANK(), SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), MIN(a.col3) OVER(ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(ORDER BY a.col2, a.col1 DESC), AVG(a.col3) OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$0], dir0=[DESC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$0], dir0=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(order by [1, 0 DESC] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and select col with global order by with LIMIT - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(ORDER BY a.col2, a.col1 DESC), RANK() OVER(ORDER BY a.col2, a.col1 DESC) FROM a ORDER BY a.col2, a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[$3], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(order by [1, 0 DESC] aggs [DENSE_RANK(), RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash], collation=[[1, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(ORDER BY a.col2), MAX(a.col3) OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), MAX($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s row_number on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), ROW_NUMBER() OVER(ORDER BY a.col2), ROW_NUMBER() OVER(ORDER BY a.col2) FROM a",
        "notes": "ROW_NUMBER requires ROWS as the default frame, and the default frame cannot be overridden, thus it cannot be combined with other functions yet",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[$2], EXPR$2=[$2])",
          "\n  LogicalWindow(window#0=[window(order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], $1=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s ranking functinos on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), DENSE_RANK() OVER(ORDER BY a.col2), RANK() OVER(ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [DENSE_RANK(), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col2=[$1], $1=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(ORDER BY a.col1), COUNT(a.col1) OVER(ORDER BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(ORDER BY a.col1), MAX(a.col3) OVER(ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [MIN($1), MAX($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY)s on the same key with select transform and filter - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), RANK() OVER(ORDER BY a.col1), DENSE_RANK() OVER(ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [0] aggs [RANK(), DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], $1=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY) with transform on order by key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(order by [2] aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(ORDER BY) with transform on order by key - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(order by [1] aggs [DENSE_RANK(), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], $1=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) only",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) only",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) only with alias",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) AS sum FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) row_number only with alias",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col2) AS row_number FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) row_number and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) dense_rank and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with select alias - ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) AS rank FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MIN($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) dense_rank and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [DENSE_RANK()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MIN($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) row_number and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) rank and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3 ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) row_number select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(partition {0} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n  PinotLogicalExchange(distribution=[hash[0]])",
          "\n    LogicalProject(col2=[$1])",
          "\n      LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) dense_rank select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(partition {0} order by [0] aggs [DENSE_RANK()])])",
          "\n  PinotLogicalExchange(distribution=[hash[0]])",
          "\n    LogicalProject(col2=[$1])",
          "\n      LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$2], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) rank with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($2):DOUBLE NOT NULL, $3)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject($0=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by has different direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 DESC] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) row_number but order by has different direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col2 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 DESC] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by has different null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 NULLS FIRST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 ASC-nulls-first] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k1) but order by different direction and null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 DESC NULLS LAST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [1 DESC-nulls-last] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalExchange(distribution=[hash[1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key only",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key only - ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1), COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [DENSE_RANK(), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col - ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK(), DENSE_RANK()])])",
          "\n  PinotLogicalExchange(distribution=[hash[0]])",
          "\n    LogicalProject(col1=[$0])",
          "\n      LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($2):DOUBLE NOT NULL, $3)], min=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with default frame for one and not the other",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with default frame for one and not the other ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [COUNT($1), DENSE_RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [1, 0] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[$3], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [1, 0] aggs [DENSE_RANK(), RANK()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [1, 0] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1), DENSE_RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col2, a.col1) FROM a ORDER BY a.col2, a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[ASC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[$3], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [1, 0] aggs [RANK(), DENSE_RANK()])])",
          "\n          PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], $2=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), COUNT(a.col1) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key select col and filter ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK(), DENSE_RANK()])])",
          "\n  PinotLogicalExchange(distribution=[hash[0]])",
          "\n    LogicalProject(col1=[$0])",
          "\n      LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [MIN($1), MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key with select transform and filter ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [DENSE_RANK(), MAX($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1) with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [2] aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalExchange(distribution=[hash[2]])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1) row_number with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), ROW_NUMBER() OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "notes": "ROW_NUMBER requires ROWS as the default frame, and the default frame cannot be overridden, thus it cannot be combined with other functions yet",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$1], EXPR$1=[$1])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject($0=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1) ranking functions with transform on partition key",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))), DENSE_RANK() OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY REVERSE(CONCAT(a.col1, '-', a.col2))) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0] aggs [RANK(), DENSE_RANK()])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject($0=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 DESC] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 NULLS FIRST), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 NULLS FIRST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 ASC-nulls-first] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k1)s on the same key but order by has different direction and null direction and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC NULLS LAST), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col1 DESC NULLS LAST) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($2):DOUBLE NOT NULL, $3)], EXPR$2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [0 DESC-nulls-last] aggs [SUM($1), COUNT($1), MIN($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) only",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) ranking function only",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) row_number only with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col1) AS row_number FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) row_number and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) dense_rank and select col",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) AS avg FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with default frame",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [MAX($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] aggs [MIN($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) row_number and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) rank and select col with global order by",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] aggs [RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n        LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$3], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] aggs [MIN($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) dense_rank and select col with global order by with LIMIT",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY a.col1 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$2], dir0=[ASC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$2], dir0=[ASC], fetch=[10])",
          "\n      LogicalProject(col2=[$1], EXPR$1=[$2], col1=[$0])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] aggs [DENSE_RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) and transform col",
        "sql": "EXPLAIN PLAN FOR SELECT SUBSTR(a.col1, 0, 2), COUNT(a.col2) OVER(PARTITION BY a.col3 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [0] aggs [COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[2]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2], $3=[SUBSTR($0, 0, 2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$1], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) rank select col and filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 10 AND a.col3 <= 500",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$1], $1=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalFilter(condition=[AND(>($2, 10), <=($2, 500))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), AVG(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$3], EXPR$1=[/(CAST($4):DOUBLE NOT NULL, $5)])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), COUNT($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2], $3=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) row_number with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) rank with select transform and filter",
        "sql": "EXPLAIN PLAN FOR SELECT CONCAT(a.col1, '-', a.col2), RANK() OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a where a.col1 NOT IN ('foo', 'bar') OR a.col3 >= 42",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalFilter(condition=[OR(AND(<>($0, 'bar'), <>($0, 'foo')), >=($2, 42))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) with transform on partition key and order key",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY REVERSE(a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [1] aggs [SUM($0), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[2]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col3=[$2], $1=[REVERSE($1)], $2=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) row_number with transform on partition key and order key",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY REVERSE(a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject($0=[REVERSE($1)], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "single OVER(PARTITION BY k1 ORDER BY k2) dense_rank with transform on partition key and order key",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(PARTITION BY CONCAT(a.col1, '-', a.col2) ORDER BY REVERSE(a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject($0=[REVERSE($1)], $1=[CONCAT($0, '-', $1)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key only (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3), COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key only (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [MAX($1), DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key only (single window group) with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3) AS max, COUNT(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col3) AS count FROM a",
        "notes": "TODO: Look into why aliases are getting ignored in the final plan",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2] aggs [MAX($2), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [SUM($2), COUNT($2), MIN($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2), RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [DENSE_RANK(), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col (single window group) with select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 AS value1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) AS avg, MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) AS min FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], avg=[/(CAST($3):DOUBLE NOT NULL, $4)], min=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [SUM($2), COUNT($2), MIN($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with default frame for one and not the other (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [COUNT($2), MIN($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with default frame for one and not the other (single window group) - ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [COUNT($2), DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [2, 0] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0, 1]], collation=[[2, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), DENSE_RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[$4], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [2, 0] aggs [RANK(), DENSE_RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0, 1]], collation=[[2, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with LIMIT (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n        LogicalWindow(window#0=[window(partition {0} order by [1] aggs [SUM($2), COUNT($2), MIN($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by with LIMIT (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), AVG(a.col3) OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [2, 0] aggs [SUM($2), COUNT($2)])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0, 1]], collation=[[2, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and select col with global order by with LIMIT (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, DENSE_RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1), RANK() OVER(PARTITION BY a.col2, a.col1 ORDER BY a.col3, a.col1) FROM a ORDER BY a.col2, a.col1 DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nLogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], offset=[0], fetch=[10])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[3, 0 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalSort(sort0=[$3], sort1=[$0], dir0=[ASC], dir1=[DESC], fetch=[10])",
          "\n      LogicalProject(col1=[$0], EXPR$1=[$3], EXPR$2=[$4], col2=[$1])",
          "\n        LogicalWindow(window#0=[window(partition {0, 1} order by [2, 0] aggs [DENSE_RANK(), RANK()])])",
          "\n          PinotLogicalSortExchange(distribution=[hash[0, 1]], collation=[[2, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n            LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key and transform col (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1), MAX(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col1) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4], $2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {1} order by [0] aggs [SUM($2), MAX($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[1]], collation=[[0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2], $3=[REVERSE($0)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key select col and filter (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), COUNT(a.col1) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [SUM($2), COUNT($2), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s row_number on the same key select col and filter (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col2), ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[$2])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key select col and filter (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a WHERE a.col3 > 42 AND a.col1 IN ('vader', 'chewbacca', 'yoda')",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [RANK(), DENSE_RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1])",
          "\n        LogicalFilter(condition=[AND(>($2, 42), OR(=($0, 'chewbacca':VARCHAR(9)), =($0, 'vader':VARCHAR(9)), =($0, 'yoda':VARCHAR(9))))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with select transform and filter (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), MIN(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$3], $1=[$4], $2=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [MIN($2), MAX($2)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2], $3=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2)s on the same key with select transform and filter (single window group) - ranking function",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(CONCAT(a.col1, ' ', a.col2)), DENSE_RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2), RANK() OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a where a.col2 NOT IN ('foo', 'bar', 'baz')",
        "output": [
          "Execution Plan",
          "\nLogicalProject($0=[$2], $1=[$3], $2=[$4])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [1] aggs [DENSE_RANK(), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col2=[$1], $2=[REVERSE(CONCAT($0, ' ', $1))])",
          "\n        LogicalFilter(condition=[AND(<>($1, 'bar'), <>($1, 'baz'), <>($1, 'foo'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2) with transform on partition key (single window group)",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)), COUNT(a.col1) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($4):DOUBLE NOT NULL, $5)], EXPR$1=[$6])",
          "\n  LogicalWindow(window#0=[window(partition {3} order by [2] aggs [SUM($1), COUNT($1), COUNT($0)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[3]], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col1=[$0], col3=[$2], $2=[CONCAT($0, '-', $1)], $3=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "multiple OVER(PARTITION BY k1 ORDER BY k2) with transform on partition key (single window group) - ranking functions",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)), RANK() OVER(PARTITION BY REVERSE(CONCAT(a.col1, '-', a.col2)) ORDER BY CONCAT(a.col1, '-', a.col2)) FROM a",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[/(CAST($3):DOUBLE NOT NULL, $4)], EXPR$1=[$5])",
          "\n  LogicalWindow(window#0=[window(partition {2} order by [1] aggs [SUM($0), COUNT($0), RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[2]], collation=[[1]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalProject(col3=[$2], $1=[CONCAT($0, '-', $1)], $2=[REVERSE(CONCAT($0, '-', $1))])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function with JOIN example",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, b.col1, SUM(a.col3) OVER (PARTITION BY a.col1) FROM a JOIN b ON a.col1 = b.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], col10=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} aggs [SUM($1)])])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$1], col10=[$2])",
          "\n        LogicalJoin(condition=[=($0, $3)], joinType=[inner])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalProject(col1=[$0], col3=[$2])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n          PinotLogicalExchange(distribution=[hash[1]])",
          "\n            LogicalProject(col1=[$0], col2=[$1])",
          "\n              LogicalTableScan(table=[[b]])",
          "\n"
        ]
      },
      {
        "description": "Window function with GROUP BY example with aggregation used within ORDER BY clause in OVER",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), AVG(a.col3) OVER(ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[$2], EXPR$2=[/(CAST($3):DOUBLE NOT NULL, $4)])",
          "\n  LogicalWindow(window#0=[window(order by [2 DESC, 0] aggs [SUM($1), COUNT($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[2 DESC, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[COUNT($2)])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}], agg#0=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function using row_number with GROUP BY example with aggregation used within ORDER BY clause in OVER",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), ROW_NUMBER() OVER(ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(order by [1 DESC, 0] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalProject(col1=[$0], EXPR$1=[$2])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[COUNT($2)])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}], agg#0=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function using ranking function with GROUP BY example with aggregation used within ORDER BY clause in OVER",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), DENSE_RANK() OVER(ORDER BY COUNT(*) desc, a.col1 asc), RANK() OVER(ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalWindow(window#0=[window(order by [1 DESC, 0] aggs [DENSE_RANK(), RANK()])])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n    LogicalProject(col1=[$0], EXPR$1=[$2])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[COUNT($2)])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}], agg#0=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function with GROUP BY example with aggregation used within ORDER BY clause in OVER with PARTITION BY",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY COUNT(*) desc, a.col1 asc) from a GROUP BY a.col1, a.col3",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[$2], $2=[$3])",
          "\n  LogicalWindow(window#0=[window(partition {0} order by [2 DESC, 0] aggs [MAX($1)])])",
          "\n    PinotLogicalSortExchange(distribution=[hash[0]], collation=[[2 DESC, 0]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[COUNT($2)])",
          "\n        PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n          LogicalAggregate(group=[{0, 2}], agg#0=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function CTE: row_number WITH statement having OVER with PARTITION BY ORDER BY",
        "sql": "EXPLAIN PLAN FOR WITH windowfunc AS (SELECT a.col1, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col3) as rownum from a) SELECT a.col1, a.rownum FROM windowfunc AS a where a.rownum < 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$3])",
          "\n  LogicalFilter(condition=[<($3, 5)])",
          "\n    LogicalWindow(window#0=[window(partition {1} order by [2] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n      PinotLogicalSortExchange(distribution=[hash[1]], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function CTE: rank/dense_rank WITH statement having OVER with PARTITION BY ORDER BY",
        "sql": "EXPLAIN PLAN FOR WITH windowfunc AS (SELECT a.col1, RANK() OVER(PARTITION BY a.col2 ORDER BY a.col3) as rank, DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col3) as dense_rank from a) SELECT a.col1, a.rank, a.dense_rank FROM windowfunc AS a where a.dense_rank < 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], $1=[$3], $2=[$4])",
          "\n  LogicalFilter(condition=[<($4, 5)])",
          "\n    LogicalWindow(window#0=[window(partition {1} order by [2] aggs [RANK(), DENSE_RANK()])])",
          "\n      PinotLogicalSortExchange(distribution=[hash[1]], collation=[[2]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function subquery: row_number having OVER with PARTITION BY ORDER BY",
        "sql": "EXPLAIN PLAN FOR SELECT row_number, col2, col3 FROM (SELECT ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col3 DESC) as row_number, a.col2, a.col3 FROM a) WHERE row_number <= 10",
        "output": [
          "Execution Plan",
          "\nLogicalProject(row_number=[$2], col2=[$0], col3=[$1])",
          "\n  LogicalFilter(condition=[<=($2, 10)])",
          "\n    LogicalWindow(window#0=[window(partition {0} order by [1 DESC] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n      PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function subquery: rank having OVER with PARTITION BY ORDER BY and a GROUP BY",
        "sql": "EXPLAIN PLAN FOR SELECT col1, total, rank FROM (SELECT a.col1 as col1, count(*) as total, RANK() OVER(ORDER BY count(*) DESC) AS rank FROM a GROUP BY a.col1) WHERE rank = 1",
        "output": [
          "Execution Plan",
          "\nLogicalFilter(condition=[=($2, 1)])",
          "\n  LogicalWindow(window#0=[window(order by [1 DESC] aggs [RANK()])])",
          "\n    PinotLogicalSortExchange(distribution=[hash], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[COUNT($1)])",
          "\n        PinotLogicalExchange(distribution=[hash[0]])",
          "\n          LogicalAggregate(group=[{0}], agg#0=[COUNT()])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Window function subquery with join using row_number",
        "sql": "EXPLAIN PLAN FOR SELECT row_number, col2, col3 FROM (SELECT a.col2 as col2, a.col3 as col3, ROW_NUMBER() OVER(PARTITION BY a.col2 ORDER BY a.col3 DESC) as row_number FROM a INNER JOIN b ON a.col1 = b.col2 WHERE a.col3 > 100 AND b.col1 IN ('douglas adams', 'brandon sanderson')) where row_number = 1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(row_number=[$2], col2=[$0], col3=[$1])",
          "\n  LogicalFilter(condition=[=($2, 1)])",
          "\n    LogicalWindow(window#0=[window(partition {0} order by [1 DESC] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n      PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalJoin(condition=[=($0, $3)], joinType=[inner])",
          "\n            PinotLogicalExchange(distribution=[hash[0]])",
          "\n              LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                LogicalFilter(condition=[>($2, 100)])",
          "\n                  LogicalTableScan(table=[[a]])",
          "\n            PinotLogicalExchange(distribution=[hash[0]])",
          "\n              LogicalProject(col2=[$1])",
          "\n                LogicalFilter(condition=[OR(=($0, 'brandon sanderson':VARCHAR(17)), =($0, 'douglas adams':VARCHAR(17)))])",
          "\n                  LogicalTableScan(table=[[b]])",
          "\n"
        ]
      },
      {
        "description": "Window function subquery with join using dense_rank",
        "sql": "EXPLAIN PLAN FOR SELECT dense_rank, col2, col3 FROM (SELECT a.col2 as col2, a.col3 as col3, DENSE_RANK() OVER(PARTITION BY a.col2 ORDER BY a.col3 DESC) as dense_rank FROM a INNER JOIN b ON a.col1 = b.col2 WHERE a.col3 > 100 AND b.col1 IN ('douglas adams', 'brandon sanderson')) where dense_rank > 15",
        "output": [
          "Execution Plan",
          "\nLogicalProject(dense_rank=[$2], col2=[$0], col3=[$1])",
          "\n  LogicalFilter(condition=[>($2, 15)])",
          "\n    LogicalWindow(window#0=[window(partition {0} order by [1 DESC] aggs [DENSE_RANK()])])",
          "\n      PinotLogicalSortExchange(distribution=[hash[0]], collation=[[1 DESC]], isSortOnSender=[false], isSortOnReceiver=[true])",
          "\n        LogicalProject(col2=[$1], col3=[$2])",
          "\n          LogicalJoin(condition=[=($0, $3)], joinType=[inner])",
          "\n            PinotLogicalExchange(distribution=[hash[0]])",
          "\n              LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                LogicalFilter(condition=[>($2, 100)])",
          "\n                  LogicalTableScan(table=[[a]])",
          "\n            PinotLogicalExchange(distribution=[hash[0]])",
          "\n              LogicalProject(col2=[$1])",
          "\n                LogicalFilter(condition=[OR(=($0, 'brandon sanderson':VARCHAR(17)), =($0, 'douglas adams':VARCHAR(17)))])",
          "\n                  LogicalTableScan(table=[[b]])",
          "\n"
        ]
      }
    ]
  },
  "exception_throwing_window_function_planning_tests": {
    "queries": [
      {
        "description": "unsupported window functions such as NTILE()",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT NTILE(5) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported window functions such as LAG()",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT LAG(a.col2) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3 ROWS BETWEEN 5 PRECEDING AND 10 FOLLOWING) FROM a WHERE a.col3 >= 0",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(ORDER BY a.col3 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames - ORDER BY with two columns and RANGE",
        "notes": "Apache Calcite throws error: RANGE clause cannot be used with compound ORDER BY clause, even though not specifying the frame results in RANGE itself",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(ORDER BY a.col3, a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames - PARTITION BY and ORDER BY with two columns and RANGE",
        "notes": "Apache Calcite throws error: RANGE clause cannot be used with compound ORDER BY clause, even though not specifying the frame results in RANGE itself",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3, a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "unsupported custom frames - ORDER BY with two columns and ROWS",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(ORDER BY a.col3, a.col1 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col3) OVER(PARTITION BY a.col2), SUM(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT AVG(a.col3) OVER(), MAX(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Multiple window groups",
        "notes": "not yet supported",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2, a.col1), MIN(a.col3) OVER(ORDER BY a.col1, a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Using aggregation inside ORDER BY within OVER",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY MAX(a.col3)) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Using aggregation inside PARTITION BY within OVER",
        "sql": "EXPLAIN PLAN FOR SELECT COUNT(a.col1) OVER(PARTITION BY AVG(a.col3)) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Select an aggregate along with OVER()",
        "sql": "EXPLAIN PLAN FOR SELECT SUM(a.col3), COUNT(a.col1) OVER() FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "External group by clause",
        "sql": "EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2) FROM a GROUP BY a.col2",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Global order by aggregate",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a ORDER BY SUM(a.col3)",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Wrong table",
        "sql": "EXPLAIN PLAN FOR SELECT MAX(b.col3) OVER(PARTITION BY b.col1 ORDER BY b.col2) FROM a ORDER BY SUM(b.col3)",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with ROW_NUMBER() window functions - even default frame cannot be specified",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col2 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with ROW_NUMBER() window functions - default frame for ROW_NUMBER is different from aggregation window functions, resulting in multiple window groups",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col2), SUM(a.col1) OVER(PARTITION BY a.col1 ORDER BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with ROW_NUMBER() window functions - custom frames not allowed",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with ROW_NUMBER() window functions - custom frames not allowed",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER() OVER(PARTITION BY a.col1 ROWS 2 PRECEDING) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with ROW_NUMBER() window functions - passing argument to ROW_NUMBER() should fail",
        "sql": "EXPLAIN PLAN FOR SELECT ROW_NUMBER(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with RANK() window functions - needs ORDER BY",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with RANK() window functions - needs ORDER BY",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER() FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with DENSE_RANK() window functions - needs ORDER BY",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(PARTITION BY a.col2) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with DENSE_RANK() window functions - needs ORDER BY",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER() FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with DENSE_RANK() window functions - passing argument to RANK() should fail",
        "sql": "EXPLAIN PLAN FOR SELECT RANK(a.col3) OVER(ORDER BY a.col1) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with DENSE_RANK() window functions - passing argument to DENSE_RANK() should fail",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK(a.col3) OVER(ORDER BY a.col1) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with RANK() window functions - cannot take default frame specification, even though same as actual frame if no frame specified",
        "sql": "EXPLAIN PLAN FOR SELECT RANK() OVER(ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "expectedException": "Error explain query plan for.*"
      },
      {
        "description": "Apache Calcite failures with DENSE_RANK() window functions - cannot take default frame specification, even though same as actual frame if no frame specified",
        "sql": "EXPLAIN PLAN FOR SELECT DENSE_RANK() OVER(ORDER BY a.col1 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM a",
        "expectedException": "Error explain query plan for.*"
      }
    ]
  }
}