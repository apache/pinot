{
  "physical_opt_constant_queries": {
    "queries": [
      {
        "description": "Select 1",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT 1",
        "output": [
          "Execution Plan",
          "\nPhysicalValues(tuples=[[{ 1 }]])",
          "\n"
        ]
      },
      {
        "description": "Constant only join query",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR WITH tmp1(id, name) AS (VALUES(1, 'foo')), tmp2(user_id, nm2) AS (VALUES(1, 'bar')) SELECT * FROM tmp1 JOIN tmp2 ON 1=1",
        "output": [
          "Execution Plan",
          "\nPhysicalJoin(condition=[true], joinType=[inner])",
          "\n  PhysicalValues(tuples=[[{ 1, _UTF-8'foo' }]])",
          "\n  PhysicalValues(tuples=[[{ 1, _UTF-8'bar' }]])",
          "\n"
        ]
      },
      {
        "description": "Query that gets optimized to a Values node",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT * FROM a WHERE col1 IS NULL LIMIT 1",
        "output": [
          "Execution Plan",
          "\nPhysicalSort(fetch=[1])",
          "\n  PhysicalValues(tuples=[[]])",
          "\n"
        ]
      },
      {
        "description": "Constant only join query",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT COUNT(*) FROM a WHERE col1 IN (WITH tmp1(id, name) AS (VALUES(1, 'foo')), tmp2(user_id, nm) AS (VALUES(2, 'bar')) SELECT A.name FROM tmp1 AS A JOIN tmp2 AS B ON A.id = B.user_id)",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{}], agg#0=[COUNT($0)], aggType=[FINAL])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalAggregate(group=[{}], agg#0=[COUNT()], aggType=[LEAF])",
          "\n        PhysicalJoin(condition=[=($0, $1)], joinType=[semi])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col1=[$0])",
          "\n              PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(name=[$1])",
          "\n              PhysicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n                PhysicalValues(tuples=[[]])",
          "\n                PhysicalProject(EXPR$0=[$0])",
          "\n                  PhysicalValues(tuples=[[]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_chained_subqueries": {
    "queries": [
      {
        "description": "Sub-query with group-by with no agg calls and a limit",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT DISTINCT col1, col2, ts FROM a LIMIT 100) SELECT col1, col2, RANK() OVER (PARTITION BY col2 ORDER BY ts DESC) AS rnk FROM tmp ORDER BY col2, rnk DESC",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[DESC])",
          "\n    PhysicalProject(col1=[$0], col2=[$1], $2=[$3])",
          "\n      PhysicalWindow(window#0=[window(partition {1} order by [2 DESC] aggs [RANK()])])",
          "\n        PhysicalSort(sort0=[$2], dir0=[DESC])",
          "\n          PhysicalSort(fetch=[100])",
          "\n            PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n              PhysicalSort(fetch=[100])",
          "\n                PhysicalAggregate(group=[{0, 1, 2}], aggType=[FINAL], limit=[100])",
          "\n                  PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0, 1, 2]])",
          "\n                    PhysicalAggregate(group=[{0, 1, 7}], aggType=[LEAF], limit=[100])",
          "\n                      PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_group_by_hint_options": {
    "queries": [
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_leaf_return_final_result='true') */ col1, COUNT(DISTINCT col2) AS cnt FROM a WHERE col3 >= 0 GROUP BY col1 ORDER BY cnt DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$1], dir0=[DESC], fetch=[10])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$1], dir0=[DESC], fetch=[10])",
          "\n        PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[FINAL], leafReturnFinalResult=[true])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[LEAF], leafReturnFinalResult=[true])",
          "\n              PhysicalFilter(condition=[>=($2, 0)])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col1, MAX(ts) FROM a GROUP BY col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[MAX($7)], aggType=[DIRECT])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias. The group by aggregate hint should be a no-op.",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ AVG(a.col3) as avg, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(avg=[/(CAST(CASE(=($1, 0), null:BIGINT, $0)):DOUBLE, $1)], count=[$1])",
          "\n    PhysicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)], aggType=[FINAL])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n        PhysicalAggregate(group=[{}], agg#0=[$SUM0($2)], agg#1=[COUNT()], aggType=[LEAF])",
          "\n          PhysicalFilter(condition=[AND(>=($2, 0), =($1, _UTF-8'pink floyd'))])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Select aggregates with filters and select alias. The group by aggregate hint should be a no-op.",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ SUM(a.col3) as sum, COUNT(*) as count FROM a WHERE a.col3 >= 0 AND a.col2 = 'pink floyd'",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(sum=[CASE(=($1, 0), null:BIGINT, $0)], count=[$1])",
          "\n    PhysicalAggregate(group=[{}], agg#0=[$SUM0($0)], agg#1=[COUNT($1)], aggType=[FINAL])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n        PhysicalAggregate(group=[{}], agg#0=[$SUM0($2)], agg#1=[COUNT()], aggType=[LEAF])",
          "\n          PhysicalFilter(condition=[AND(>=($2, 0), =($1, _UTF-8'pink floyd'))])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Example of query that avoids exchanges for aggregates",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR with teamOne as (select col2, percentile(col3, 50) as sum_of_runs from a group by col2), teamTwo as (select col2, percentile(col3, 50) as sum_of_runs from a group by col2), all as (select col2, sum_of_runs from teamOne union all select col2, sum_of_runs from teamTwo) select col2, percentile(sum_of_runs, 50) from all group by col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n    PhysicalUnion(all=[true])",
          "\n      PhysicalProject(col2=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n          PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n            PhysicalProject(col2=[$1], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalProject(col2=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n          PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n            PhysicalProject(col2=[$1], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Same query as above but with agg hints. Here the leaf stage group-by is ignored because the default optimizations in v2 optimizer already eliminate aggregation splits.",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR with teamOne as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col2, percentile(col3, 50) as sum_of_runs from a group by col2), teamTwo as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col2, percentile(col3, 50) as sum_of_runs from a group by col2), all as (select col2, sum_of_runs from teamOne union all select col2, sum_of_runs from teamTwo) select /*+ aggOption(is_skip_leaf_stage_group_by='true') */ col2, percentile(sum_of_runs, 50) from all group by col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n    PhysicalUnion(all=[true])",
          "\n      PhysicalProject(col2=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n          PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n            PhysicalProject(col2=[$1], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalProject(col2=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n          PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n            PhysicalProject(col2=[$1], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Same query as above, but group-by is on the non-partitioning column col1. In this case, the hint is honored but we have to use partitioning exchange.",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR with teamOne as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col1, percentile(col3, 50) as sum_of_runs from a group by col1), teamTwo as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col1, percentile(col3, 50) as sum_of_runs from a group by col1), all as (select col1, sum_of_runs from teamOne union all select col1, sum_of_runs from teamTwo) select /*+ aggOption(is_skip_leaf_stage_group_by='true') */ col1, percentile(sum_of_runs, 50) from all group by col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n    PhysicalUnion(all=[true])",
          "\n      PhysicalProject(col1=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col1=[$0], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalProject(col1=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n        PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col1=[$0], col3=[$2], $f2=[50])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Same query as above, but union does not have all. Union gets decomposed into a union-all and a group-by",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR with teamOne as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col1, percentile(col3, 50) as sum_of_runs from a group by col1), teamTwo as (select /*+ aggOptions(is_skip_leaf_stage_group_by='true') */ col1, percentile(col3, 50) as sum_of_runs from a group by col1), all as (select col1, sum_of_runs from teamOne union select col1, sum_of_runs from teamTwo) select /*+ aggOption(is_skip_leaf_stage_group_by='true') */ col1, percentile(sum_of_runs, 50) from all group by col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[FINAL])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[LEAF])",
          "\n        PhysicalProject(col1=[$0], sum_of_runs=[$1], $f2=[50])",
          "\n          PhysicalAggregate(group=[{0, 1}], aggType=[FINAL])",
          "\n            PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0, 1]])",
          "\n              PhysicalAggregate(group=[{0, 1}], aggType=[LEAF])",
          "\n                PhysicalUnion(all=[true])",
          "\n                  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n                    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n                      PhysicalProject(col1=[$0], col3=[$2], $f2=[50])",
          "\n                        PhysicalTableScan(table=[[default, a]])",
          "\n                  PhysicalAggregate(group=[{0}], agg#0=[PERCENTILE($1, 50)], aggType=[DIRECT])",
          "\n                    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n                      PhysicalProject(col1=[$0], col3=[$2], $f2=[50])",
          "\n                        PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_join_planning_tests": {
    "queries": [
      {
        "description": "Inner join with order by",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT a.col1, a.ts, b.col3 FROM a JOIN b ON a.col1 = b.col2 ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalProject(col1=[$0], ts=[$1], col3=[$3])",
          "\n        PhysicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col1=[$0], ts=[$7])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col2=[$1], col3=[$2])",
          "\n              PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "Inner join with order by and select column with alias",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT a.col1 AS value1, a.ts AS ts1, b.col3 FROM a JOIN b ON a.col1 = b.col2 ORDER BY a.col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalProject(value1=[$0], ts1=[$1], col3=[$3])",
          "\n        PhysicalJoin(condition=[=($0, $2)], joinType=[inner])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col1=[$0], ts=[$7])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col2=[$1], col3=[$2])",
          "\n              PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "SELECT * inner join",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT * FROM a JOIN b ON a.col1 = b.col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[=($0, $10)], joinType=[inner])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[1]])",
          "\n      PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "SELECT * inner join with filter on one table",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT * FROM a JOIN b ON a.col1 = b.col2 WHERE a.col3 >= 0",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[=($0, $10)], joinType=[inner])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalFilter(condition=[>=($2, 0)])",
          "\n        PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[1]])",
          "\n      PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "SELECT * inner join with filter",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT * FROM a JOIN b ON a.col1 = b.col2 WHERE a.col3 >= 0 AND a.col3 > b.col3",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[AND(=($0, $10), >($2, $11))], joinType=[inner])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalFilter(condition=[>=($2, 0)])",
          "\n        PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[1]])",
          "\n      PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "SELECT * inner join on 2 columns equality",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT * FROM a JOIN b on a.col1 = b.col1 AND a.col2 = b.col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[AND(=($0, $9), =($1, $10))], joinType=[inner])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0, 1]])",
          "\n      PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0, 1]])",
          "\n      PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_semi_join_planning_tests": {
    "queries": [
      {
        "description": "Single semi-join",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col3 IN (SELECT col3 FROM b)",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(col1=[$0], col2=[$1])",
          "\n    PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[2]])",
          "\n        PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n        PhysicalProject(col3=[$2])",
          "\n          PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "self semi-join on single server table",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM b WHERE col3 IN (SELECT col3 FROM b)",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(col1=[$0], col2=[$1])",
          "\n    PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n        PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          PhysicalTableScan(table=[[default, b]])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n        PhysicalProject(col3=[$2])",
          "\n          PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "Multiple semi-join",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col3 IN (SELECT col3 FROM b WHERE col2='foo') AND col3 IN (SELECT col3 FROM b WHERE col2='bar') AND col3 IN (SELECT col3 FROM b WHERE col2='lorem')",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(col1=[$0], col2=[$1])",
          "\n    PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n      PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n        PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[2]])",
          "\n            PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalProject(col3=[$2])",
          "\n              PhysicalFilter(condition=[=($1, _UTF-8'foo')])",
          "\n                PhysicalTableScan(table=[[default, b]])",
          "\n        PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n          PhysicalProject(col3=[$2])",
          "\n            PhysicalFilter(condition=[=($1, _UTF-8'bar')])",
          "\n              PhysicalTableScan(table=[[default, b]])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n        PhysicalProject(col3=[$2])",
          "\n          PhysicalFilter(condition=[=($1, _UTF-8'lorem')])",
          "\n            PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "semi-join, followed by anti semi-join with single-server table, followed by another semi-join",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col3 IN (SELECT col3 FROM b WHERE col2='foo') AND col3 NOT IN (SELECT col3 FROM b WHERE col2='bar') AND col3 IN (SELECT col3 FROM b WHERE col2='lorem')",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(col1=[$0], col2=[$1])",
          "\n    PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n      PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        PhysicalFilter(condition=[IS NOT TRUE($5)])",
          "\n          PhysicalJoin(condition=[=($3, $4)], joinType=[left])",
          "\n            PhysicalProject(col1=[$0], col2=[$1], col3=[$2], col31=[$2])",
          "\n              PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n                PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[2]])",
          "\n                  PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                    PhysicalTableScan(table=[[default, a]])",
          "\n                PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n                  PhysicalProject(col3=[$2])",
          "\n                    PhysicalFilter(condition=[=($1, _UTF-8'foo')])",
          "\n                      PhysicalTableScan(table=[[default, b]])",
          "\n            PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n              PhysicalAggregate(group=[{0}], agg#0=[MIN($1)], aggType=[DIRECT])",
          "\n                PhysicalProject(col3=[$2], $f1=[true])",
          "\n                  PhysicalFilter(condition=[=($1, _UTF-8'bar')])",
          "\n                    PhysicalTableScan(table=[[default, b]])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n        PhysicalProject(col3=[$2])",
          "\n          PhysicalFilter(condition=[=($1, _UTF-8'lorem')])",
          "\n            PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "semi-join, followed by anti semi-join on same fact table, followed by another semi-join",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col3 IN (SELECT col3 FROM b WHERE col2='foo') AND col3 NOT IN (SELECT col3 FROM a WHERE col2='bar') AND col3 IN (SELECT col3 FROM b WHERE col2='lorem')",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(col1=[$0], col2=[$1])",
          "\n    PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n      PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        PhysicalFilter(condition=[IS NOT TRUE($5)])",
          "\n          PhysicalJoin(condition=[=($3, $4)], joinType=[left])",
          "\n            PhysicalProject(col1=[$0], col2=[$1], col3=[$2], col31=[$2])",
          "\n              PhysicalJoin(condition=[=($2, $3)], joinType=[semi])",
          "\n                PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[2]])",
          "\n                  PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                    PhysicalTableScan(table=[[default, a]])",
          "\n                PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n                  PhysicalProject(col3=[$2])",
          "\n                    PhysicalFilter(condition=[=($1, _UTF-8'foo')])",
          "\n                      PhysicalTableScan(table=[[default, b]])",
          "\n            PhysicalAggregate(group=[{0}], agg#0=[MIN($1)], aggType=[FINAL])",
          "\n              PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n                PhysicalAggregate(group=[{0}], agg#0=[MIN($1)], aggType=[LEAF])",
          "\n                  PhysicalProject(col3=[$2], $f1=[true])",
          "\n                    PhysicalFilter(condition=[=($1, _UTF-8'bar')])",
          "\n                      PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n        PhysicalProject(col3=[$2])",
          "\n          PhysicalFilter(condition=[=($1, _UTF-8'lorem')])",
          "\n            PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_auto_identity_tests": {
    "queries": [
      {
        "description": "Self semi-joins",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col2 IN (SELECT col2 FROM a WHERE col3 = '1') AND col2 IN (SELECT col2 FROM a WHERE col3 = '2')",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n    PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n        PhysicalProject(col1=[$0], col2=[$1])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n        PhysicalProject(col2=[$1])",
          "\n          PhysicalFilter(condition=[=($2, 1)])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n      PhysicalProject(col2=[$1])",
          "\n        PhysicalFilter(condition=[=($2, 2)])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Self semi and anti semi-joins",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, col2 FROM a WHERE col2 IN (SELECT col2 FROM a WHERE col3 = '1') AND col2 NOT IN (SELECT col2 FROM a WHERE col3 = '2') AND col2 IN (SELECT col2 FROM a WHERE col3 = '3')",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n    PhysicalProject(col1=[$0], col2=[$1])",
          "\n      PhysicalFilter(condition=[IS NOT TRUE($4)])",
          "\n        PhysicalJoin(condition=[=($2, $3)], joinType=[left])",
          "\n          PhysicalProject(col1=[$0], col2=[$1], col21=[$1])",
          "\n            PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n              PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                PhysicalProject(col1=[$0], col2=[$1])",
          "\n                  PhysicalTableScan(table=[[default, a]])",
          "\n              PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                PhysicalProject(col2=[$1])",
          "\n                  PhysicalFilter(condition=[=($2, 1)])",
          "\n                    PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n            PhysicalAggregate(group=[{0}], agg#0=[MIN($1)], aggType=[DIRECT])",
          "\n              PhysicalProject(col2=[$1], $f1=[true])",
          "\n                PhysicalFilter(condition=[=($2, 2)])",
          "\n                  PhysicalTableScan(table=[[default, a]])",
          "\n    PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n      PhysicalProject(col2=[$1])",
          "\n        PhysicalFilter(condition=[=($2, 3)])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Self semi and anti semi-joins with aggregation in the end",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col1, COUNT(*) FROM a WHERE col2 IN (SELECT col2 FROM a WHERE col3 = '1') AND col2 NOT IN (SELECT col2 FROM a WHERE col3 = '2') AND col2 IN (SELECT col2 FROM a WHERE col3 = '3') GROUP BY col1",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[COUNT($1)], aggType=[FINAL])",
          "\n    PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n      PhysicalAggregate(group=[{0}], agg#0=[COUNT()], aggType=[LEAF])",
          "\n        PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n          PhysicalProject(col1=[$0], col2=[$1])",
          "\n            PhysicalFilter(condition=[IS NOT TRUE($4)])",
          "\n              PhysicalJoin(condition=[=($2, $3)], joinType=[left])",
          "\n                PhysicalProject(col1=[$0], col2=[$1], col21=[$1])",
          "\n                  PhysicalJoin(condition=[=($1, $2)], joinType=[semi])",
          "\n                    PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                      PhysicalProject(col1=[$0], col2=[$1])",
          "\n                        PhysicalTableScan(table=[[default, a]])",
          "\n                    PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                      PhysicalProject(col2=[$1])",
          "\n                        PhysicalFilter(condition=[=($2, 1)])",
          "\n                          PhysicalTableScan(table=[[default, a]])",
          "\n                PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                  PhysicalAggregate(group=[{0}], agg#0=[MIN($1)], aggType=[DIRECT])",
          "\n                    PhysicalProject(col2=[$1], $f1=[true])",
          "\n                      PhysicalFilter(condition=[=($2, 2)])",
          "\n                        PhysicalTableScan(table=[[default, a]])",
          "\n          PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n            PhysicalProject(col2=[$1])",
          "\n              PhysicalFilter(condition=[=($2, 3)])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_group_trim_enabled": {
    "queries": [
      {
        "description": "SQL hint based group by optimization with partitioned aggregated values and group trim enabled",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_leaf_return_final_result='true', is_enable_group_trim='true') */ col1, COUNT(DISTINCT col2) AS cnt FROM a WHERE col3 >= 0 GROUP BY col1 ORDER BY cnt DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$1], dir0=[DESC], fetch=[10])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$1], dir0=[DESC], fetch=[10])",
          "\n        PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[FINAL], leafReturnFinalResult=[true], limit=[10])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n            PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[LEAF], leafReturnFinalResult=[true], collations=[[1 DESC]], limit=[10])",
          "\n              PhysicalFilter(condition=[>=($2, 0)])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with group trim enabled without returning group key",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_enable_group_trim='true') */ COUNT(DISTINCT col2) AS cnt FROM a WHERE a.col3 >= 0 GROUP BY col1 ORDER BY cnt DESC LIMIT 10",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[DESC], fetch=[10])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$0], dir0=[DESC], fetch=[10])",
          "\n        PhysicalProject(cnt=[$1])",
          "\n          PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[FINAL], limit=[10])",
          "\n            PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n              PhysicalAggregate(group=[{0}], agg#0=[DISTINCTCOUNT($1)], aggType=[LEAF], collations=[[1 DESC]], limit=[10])",
          "\n                PhysicalFilter(condition=[>=($2, 0)])",
          "\n                  PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based distinct optimization with group trim enabled",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT /*+ aggOptions(is_enable_group_trim='true') */ DISTINCT col1, col2 FROM a WHERE col3 >= 0 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(fetch=[10])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(fetch=[10])",
          "\n        PhysicalAggregate(group=[{0, 1}], aggType=[FINAL], limit=[10])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0, 1]])",
          "\n            PhysicalAggregate(group=[{0, 1}], aggType=[LEAF], limit=[10])",
          "\n              PhysicalFilter(condition=[>=($2, 0)])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_misc_auto_identity": {
    "queries": [
      {
        "description": "Union, distinct, etc. but still maximally identity exchange",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT col2 FROM a WHERE col1 = 'foo' UNION ALL SELECT col2 FROM a WHERE col3 = '1'), tmp2 AS (SELECT DISTINCT col2 FROM tmp) SELECT COUNT(*), col3 FROM a WHERE col2 IN (SELECT col2 FROM tmp2) GROUP BY col3",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(EXPR$0=[$1], col3=[$0])",
          "\n    PhysicalAggregate(group=[{0}], agg#0=[COUNT($1)], aggType=[FINAL])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]])",
          "\n        PhysicalAggregate(group=[{1}], agg#0=[COUNT()], aggType=[LEAF])",
          "\n          PhysicalJoin(condition=[=($0, $2)], joinType=[semi])",
          "\n            PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n              PhysicalProject(col2=[$1], col3=[$2])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n            PhysicalAggregate(group=[{0}], aggType=[DIRECT])",
          "\n              PhysicalUnion(all=[true])",
          "\n                PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                  PhysicalProject(col2=[$1])",
          "\n                    PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n                      PhysicalTableScan(table=[[default, a]])",
          "\n                PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n                  PhysicalProject(col2=[$1])",
          "\n                    PhysicalFilter(condition=[=($2, 1)])",
          "\n                      PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_simple_sort_queries": {
    "queries": [
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' ORDER BY col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalProject(col2=[$1], col3=[$2])",
          "\n        PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' ORDER BY col2 LIMIT 10",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$0], dir0=[ASC], fetch=[10])",
          "\n        PhysicalProject(col2=[$1], col3=[$2])",
          "\n          PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' ORDER BY col2 LIMIT 10, 11",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC], offset=[10], fetch=[11])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$0], dir0=[ASC], fetch=[21])",
          "\n        PhysicalProject(col2=[$1], col3=[$2])",
          "\n          PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' LIMIT 10, 11",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(offset=[10], fetch=[11])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(fetch=[21])",
          "\n        PhysicalProject(col2=[$1], col3=[$2])",
          "\n          PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, COUNT(*) as cnt FROM a GROUP BY col2 ORDER BY cnt LIMIT 100",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$1], dir0=[ASC], fetch=[100])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$1], dir0=[ASC], fetch=[100])",
          "\n        PhysicalAggregate(group=[{1}], agg#0=[COUNT()], aggType=[DIRECT])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT col2, COUNT(*) as cnt FROM b GROUP BY col2 ORDER BY cnt LIMIT 100",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$1], dir0=[ASC], fetch=[100])",
          "\n    PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE])",
          "\n      PhysicalSort(sort0=[$1], dir0=[ASC], fetch=[100])",
          "\n        PhysicalAggregate(group=[{1}], agg#0=[COUNT()], aggType=[DIRECT])",
          "\n          PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_lite_mode_single_rel_queries": {
    "queries": [
      {
        "description": "Simple SELECT with WHERE query.",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo'",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(fetch=[100000])",
          "\n    PhysicalProject(col2=[$1], col3=[$2])",
          "\n      PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n        PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Auto elimination of partial aggregate when group-by on partitioning column. There's no sort because the limit is added to Agg.",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR SELECT col2, COUNT(*) FROM a WHERE col1 = 'foo' GROUP BY col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalAggregate(group=[{1}], agg#0=[COUNT()], aggType=[DIRECT], limit=[100000])",
          "\n    PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n      PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Sub-queries with chained transformations",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT col1, col2, col3, COUNT(*) FROM a WHERE col1 = 'foo' GROUP BY col1, col2, col3) SELECT * FROM (SELECT ROW_NUMBER() OVER (PARTITION BY col2 ORDER BY col3) as rnk, col1 FROM tmp) WHERE rnk = 1",
        "output": [
          "Execution Plan",
          "\nPhysicalProject(rnk=[$3], col1=[$0])",
          "\n  PhysicalFilter(condition=[=($3, 1)])",
          "\n    PhysicalWindow(window#0=[window(partition {1} order by [2] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n      PhysicalSort(sort0=[$2], dir0=[ASC])",
          "\n        PhysicalAggregate(group=[{0, 1, 2}], aggType=[FINAL])",
          "\n          PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n            PhysicalAggregate(group=[{0, 1, 2}], aggType=[LEAF], limit=[100000])",
          "\n              PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Pagination on group-by results",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT col1, col2, col3, COUNT(*) FROM a WHERE col1 = 'foo' GROUP BY col1, col2, col3 ORDER BY col2) SELECT * FROM tmp LIMIT 100,400",
        "output": [
          "Execution Plan",
          "\nPhysicalSort(offset=[100], fetch=[400])",
          "\n  PhysicalAggregate(group=[{0, 1, 2}], agg#0=[COUNT($3)], aggType=[FINAL])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalAggregate(group=[{0, 1, 2}], agg#0=[COUNT()], aggType=[LEAF], limit=[100000])",
          "\n        PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Sub-query with group-by with no agg calls and a limit",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT DISTINCT col1, col2, ts FROM a LIMIT 100) SELECT col1, col2, RANK() OVER (PARTITION BY col2 ORDER BY ts DESC) AS rnk FROM tmp ORDER BY col2, rnk DESC",
        "output": [
          "Execution Plan",
          "\nPhysicalSort(sort0=[$1], sort1=[$2], dir0=[ASC], dir1=[DESC])",
          "\n  PhysicalProject(col1=[$0], col2=[$1], $2=[$3])",
          "\n    PhysicalWindow(window#0=[window(partition {1} order by [2 DESC] aggs [RANK()])])",
          "\n      PhysicalSort(sort0=[$2], dir0=[DESC])",
          "\n        PhysicalSort(fetch=[100])",
          "\n          PhysicalAggregate(group=[{0, 1, 2}], aggType=[FINAL], limit=[100])",
          "\n            PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n              PhysicalAggregate(group=[{0, 1, 7}], aggType=[LEAF], limit=[100])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Tests collation push down for Lite Mode. Collation from the exchange above should get pushed down to the sort below.",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR WITH tmp AS (SELECT col1, ROW_NUMBER() OVER (ORDER BY ts DESC) as row_num FROM a) SELECT COUNT(*) FROM tmp WHERE row_num <= 100",
        "output": [
          "Execution Plan",
          "\nPhysicalAggregate(group=[{}], agg#0=[COUNT()], aggType=[DIRECT])",
          "\n  PhysicalFilter(condition=[<=($1, 100)])",
          "\n    PhysicalWindow(window#0=[window(order by [0 DESC] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE], collation=[[0 DESC]])",
          "\n        PhysicalSort(sort0=[$0], dir0=[DESC], fetch=[100000])",
          "\n          PhysicalProject(ts=[$7])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_lite_mode_bi_rel_queries": {
    "queries": [
      {
        "description": "Query with single semi join",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' AND col2 IN (SELECT col1 FROM b)",
        "output": [
          "Execution Plan",
          "\nPhysicalJoin(condition=[=($0, $2)], joinType=[semi])",
          "\n  PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n    PhysicalSort(fetch=[100000])",
          "\n      PhysicalProject(col2=[$1], col3=[$2])",
          "\n        PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n  PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n    PhysicalSort(fetch=[100000])",
          "\n      PhysicalProject(col1=[$0])",
          "\n        PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      },
      {
        "description": "Query with single semi join and aggregation",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; EXPLAIN PLAN FOR SELECT COUNT(*), col2 FROM a WHERE col1 = 'foo' AND col2 IN (SELECT col1 FROM b) GROUP BY col2",
        "output": [
          "Execution Plan",
          "\nPhysicalProject(EXPR$0=[$1], col2=[$0])",
          "\n  PhysicalAggregate(group=[{0}], agg#0=[COUNT()], aggType=[DIRECT])",
          "\n    PhysicalJoin(condition=[=($0, $1)], joinType=[semi])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n        PhysicalSort(fetch=[100000])",
          "\n          PhysicalProject(col2=[$1])",
          "\n            PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n        PhysicalSort(fetch=[100000])",
          "\n          PhysicalProject(col1=[$0])",
          "\n            PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_run_in_random_server": {
    "queries": [
      {
        "description": "(run-in-random-server) Pagination on group-by results",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; SET runInBroker=false; EXPLAIN PLAN FOR WITH tmp AS (SELECT col1, col2, col3, COUNT(*) FROM a WHERE col1 = 'foo' GROUP BY col1, col2, col3 ORDER BY col2) SELECT * FROM tmp LIMIT 100,400",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(offset=[100], fetch=[400])",
          "\n    PhysicalAggregate(group=[{0, 1, 2}], agg#0=[COUNT($3)], aggType=[FINAL])",
          "\n      PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n        PhysicalAggregate(group=[{0, 1, 2}], agg#0=[COUNT()], aggType=[LEAF], limit=[100000])",
          "\n          PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "(run-in-random-server) Query with single semi join and aggregation",
        "sql": "SET usePhysicalOptimizer=true; SET useLiteMode=true; SET runInBroker=false; EXPLAIN PLAN FOR SELECT COUNT(*), col2 FROM a WHERE col1 = 'foo' AND col2 IN (SELECT col1 FROM b) GROUP BY col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject(EXPR$0=[$1], col2=[$0])",
          "\n    PhysicalAggregate(group=[{0}], agg#0=[COUNT()], aggType=[DIRECT])",
          "\n      PhysicalJoin(condition=[=($0, $1)], joinType=[semi])",
          "\n        PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n          PhysicalSort(fetch=[100000])",
          "\n            PhysicalProject(col2=[$1])",
          "\n              PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n                PhysicalTableScan(table=[[default, a]])",
          "\n        PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n          PhysicalSort(fetch=[100000])",
          "\n            PhysicalProject(col1=[$0])",
          "\n              PhysicalTableScan(table=[[default, b]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_broker_pruning": {
    "queries": [
      {
        "description": "Broker pruning example (smoke test)",
        "sql": "SET usePhysicalOptimizer=true; SET useBrokerPruning=true; EXPLAIN PLAN FOR SELECT col2, col3 FROM a WHERE col1 = 'foo' ORDER BY col2",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalSort(sort0=[$0], dir0=[ASC])",
          "\n    PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n      PhysicalProject(col2=[$1], col3=[$2])",
          "\n        PhysicalFilter(condition=[=($0, _UTF-8'foo')])",
          "\n          PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  },
  "physical_opt_window_functions": {
    "queries": [
      {
        "description": "Multiple window groups",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3), MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3), ROW_NUMBER() OVER(PARTITION BY a.col1 ORDER BY a.col3), RANK() OVER(PARTITION BY a.col1 ORDER BY a.col3), LAG(a.col3, 1, '0') OVER(PARTITION BY a.col1 ORDER BY a.col3) FROM a",
        "notes": "the table is partitioned by col2, thus we don't need to shuffle the data for the first windown function",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject($0=[$3], $1=[$4], $2=[$7], $3=[$5], $4=[$6])",
          "\n    PhysicalWindow(window#0=[window(partition {0} order by [2] rows between UNBOUNDED PRECEDING and CURRENT ROW aggs [ROW_NUMBER()])], constants=[[1, _UTF-8'0']])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE], collation=[[2]])",
          "\n        PhysicalWindow(window#0=[window(partition {0} order by [2] aggs [MAX($2), RANK(), LAG($2, 1, _UTF-8'0')])], constants=[[1, _UTF-8'0']])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]], collation=[[2]])",
          "\n            PhysicalWindow(window#0=[window(partition {1} order by [2] aggs [MIN($2)])], constants=[[1, _UTF-8'0']])",
          "\n              PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE], collation=[[2]])",
          "\n                PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                  PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Multiple window groups",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT MAX(a.col3) OVER(PARTITION BY a.col1 ORDER BY a.col3), MIN(a.col3) OVER(PARTITION BY a.col2 ORDER BY a.col3), SUM(a.col3) OVER(PARTITION BY a.col3 ORDER BY a.col1) FROM a",
        "notes": "physical optimizer currently doesn't support reorder window nodes according to the data distribution; the first window function will be processed first, i.e. the lowest window node in the plan tree",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject($0=[$3], $1=[$4], $2=[$5])",
          "\n    PhysicalWindow(window#0=[window(partition {2} order by [0] aggs [SUM($2)])])",
          "\n      PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[2]], collation=[[0]])",
          "\n        PhysicalWindow(window#0=[window(partition {1} order by [2] aggs [MIN($2)])])",
          "\n          PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[1]], collation=[[2]])",
          "\n            PhysicalWindow(window#0=[window(partition {0} order by [2] aggs [MAX($2)])])",
          "\n              PhysicalExchange(exchangeStrategy=[PARTITIONING_EXCHANGE], distKeys=[[0]], collation=[[2]])",
          "\n                PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n                  PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Multiple window groups",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2), MIN(a.col3) OVER(PARTITION BY a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject($0=[$2], $1=[$3])",
          "\n    PhysicalWindow(window#0=[window(partition {0} aggs [MIN($1)])])",
          "\n      PhysicalWindow(window#0=[window(order by [0] aggs [SUM($1)])])",
          "\n        PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE], collation=[[0]])",
          "\n          PhysicalProject(col2=[$1], col3=[$2])",
          "\n            PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      },
      {
        "description": "Multiple window groups",
        "sql": "SET usePhysicalOptimizer=true; EXPLAIN PLAN FOR SELECT SUM(a.col3) OVER(ORDER BY a.col2, a.col1), MIN(a.col3) OVER(ORDER BY a.col1, a.col2) FROM a",
        "output": [
          "Execution Plan",
          "\nPhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE])",
          "\n  PhysicalProject($0=[$3], $1=[$4])",
          "\n    PhysicalWindow(window#0=[window(order by [0, 1] aggs [MIN($2)])])",
          "\n      PhysicalExchange(exchangeStrategy=[IDENTITY_EXCHANGE], collation=[[0, 1]])",
          "\n        PhysicalWindow(window#0=[window(order by [1, 0] aggs [SUM($2)])])",
          "\n          PhysicalExchange(exchangeStrategy=[SINGLETON_EXCHANGE], collation=[[1, 0]])",
          "\n            PhysicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n              PhysicalTableScan(table=[[default, a]])",
          "\n"
        ]
      }
    ]
  }
}
