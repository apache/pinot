{
  "group_by_planning_tests": {
    "queries": [
      {
        "description": "Group by with select and aggregate column",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) FROM a GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with select and aggregates with filters and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, KURTOSIS(a.col3) as kurtosis, DISTINCTCOUNT(a.col1) as dcount, MIN(a.col6), BOOL_AND(a.col5) FROM a WHERE a.col3 >= 0 AND a.col2 = 'linkin park' GROUP BY a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$0], kurtosis=[KURTOSIS_REDUCE($1)], dcount=[CAST(COUNT_DISTINCT_REDUCE($2)):BIGINT NOT NULL], EXPR$3=[MIN_REDUCE($3)], EXPR$4=[<>(BOOL_AND_REDUCE($4), 0)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[DISTINCTCOUNT($2)], agg#2=[MIN($3)], agg#3=[BOOL_AND($4)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{1}], agg#0=[FOURTHMOMENT($2)], agg#1=[DISTINCTCOUNT($0)], agg#2=[MIN($4)], agg#3=[BOOL_AND($3)])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2], col5=[$4], col6=[$5])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'linkin park'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with elect and aggregates for COUNT variations",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, a.col2, DISTINCTCOUNT(a.col3), COUNT(DISTINCT a.col3), COUNT(a.col3), COUNT(*), DISTINCTCOUNT(a.col5) FROM a GROUP BY a.col1, a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], col2=[$1], EXPR$2=[CAST(COUNT_DISTINCT_REDUCE($2)):BIGINT NOT NULL], EXPR$3=[CAST(COUNT_DISTINCT_REDUCE($3)):BIGINT NOT NULL], EXPR$4=[COUNT_REDUCE($4)], EXPR$5=[COUNT_REDUCE($4)], EXPR$6=[CAST(COUNT_DISTINCT_REDUCE($5)):BIGINT NOT NULL])",
          "\n  LogicalAggregate(group=[{0, 1}], agg#0=[DISTINCTCOUNT($2)], agg#1=[DISTINCTCOUNT(DISTINCT $3)], agg#2=[COUNT($4)], agg#3=[DISTINCTCOUNT($5)])",
          "\n    PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[DISTINCTCOUNT($2)], agg#1=[DISTINCTCOUNT(DISTINCT $2)], agg#2=[COUNT()], agg#3=[DISTINCTCOUNT($4)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with select and aggregates with filters",
        "sql": "EXPLAIN PLAN FOR SELECT a.col5, SKEWNESS(a.col3), AVG(a.col3), BOOL_OR(a.col5), SUM(a.col3), AVG(a.col6), MAX(a.col6) FROM a WHERE a.col3 >= 0 AND a.col2 = 'rolling stones' GROUP BY a.col5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col5=[$0], EXPR$1=[SKEWNESS_REDUCE($1)], EXPR$2=[AVG_REDUCE(SUM_REDUCE($2), COUNT_REDUCE($3))], EXPR$3=[<>(BOOL_OR_REDUCE($4), 0)], EXPR$4=[SUM_REDUCE($2)], EXPR$5=[AVG_REDUCE(SUM_REDUCE($5), COUNT_REDUCE($3))], EXPR$6=[MAX_REDUCE($6)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[$SUM0($2)], agg#2=[COUNT($3)], agg#3=[BOOL_OR($4)], agg#4=[$SUM0($5)], agg#5=[MAX($6)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{2}], agg#0=[FOURTHMOMENT($1)], agg#1=[$SUM0($1)], agg#2=[COUNT()], agg#3=[BOOL_OR($2)], agg#4=[$SUM0($3)], agg#5=[MAX($3)])",
          "\n        LogicalProject(col2=[$1], col3=[$2], col5=[$4], col6=[$5])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'rolling stones'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with select and multiple aggregations one 1 column",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3), AVG(a.col3), MAX(a.col3), MIN(a.col3) FROM a GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)], EXPR$2=[AVG_REDUCE(SUM_REDUCE($1), COUNT_REDUCE($2))], EXPR$3=[MAX_REDUCE($3)], EXPR$4=[MIN_REDUCE($4)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT($2)], agg#2=[MAX($3)], agg#3=[MIN($4)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)], agg#1=[COUNT()], agg#2=[MAX($2)], agg#3=[MIN($2)])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by count(*) with filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1",
        "notes": "TODO: Needs follow up. Project should only keep a.col1 since the other columns are pushed to the filter, but it currently keeps them all",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[COUNT_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[COUNT($1)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[COUNT()])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by on 2 columns with filter",
        "sql": "EXPLAIN PLAN FOR SELECT a.col2, a.col1, SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col1 = 'a'  GROUP BY a.col1, a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$1], col1=[$0], EXPR$2=[SUM_REDUCE($2)])",
          "\n  LogicalAggregate(group=[{0, 1}], agg#0=[$SUM0($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n      LogicalAggregate(group=[{0, 1}], agg#0=[$SUM0($2)])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($0, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with having clause",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, COUNT(*), SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING COUNT(*) > 10 AND MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SUM(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[COUNT_REDUCE($1)], EXPR$2=[SUM_REDUCE($2)])",
          "\n  LogicalFilter(condition=[AND(>(COUNT_REDUCE($1), 10), >=(MAX_REDUCE($3), 0), <(MIN_REDUCE($4), 20), <=(SUM_REDUCE($2), 10), =(AVG_REDUCE(SUM_REDUCE($2), COUNT_REDUCE($1)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[COUNT($1)], agg#1=[$SUM0($2)], agg#2=[MAX($3)], agg#3=[MIN($4)])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[COUNT()], agg#1=[$SUM0($2)], agg#2=[MAX($2)], agg#3=[MIN($2)])",
          "\n          LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with having clause and different aggregation functions",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1, KURTOSIS(a.col3), BOOL_OR(a.col5) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING COUNT(*) > 10 AND MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SKEWNESS(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[KURTOSIS_REDUCE($1)], EXPR$2=[<>(BOOL_OR_REDUCE($2), 0)])",
          "\n  LogicalFilter(condition=[AND(>(COUNT_REDUCE($3), 10), >=(MAX_REDUCE($4), 0), <(MIN_REDUCE($5), 20), <=(SKEWNESS_REDUCE($1), 10), =(AVG_REDUCE(SUM_REDUCE($6), COUNT_REDUCE($3)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[BOOL_OR($2)], agg#2=[COUNT($3)], agg#3=[MAX($4)], agg#4=[MIN($5)], agg#5=[$SUM0($6)])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($2)], agg#1=[BOOL_OR($3)], agg#2=[COUNT()], agg#3=[MAX($2)], agg#4=[MIN($2)], agg#5=[$SUM0($2)])",
          "\n          LogicalProject(col1=[$0], col2=[$1], col3=[$2], col5=[$4])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by with having clause and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT a.col1 as value1, COUNT(*) AS count, SUM(a.col3) as SUM FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING COUNT(*) > 10 AND MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SUM(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], count=[COUNT_REDUCE($1)], SUM=[SUM_REDUCE($2)])",
          "\n  LogicalFilter(condition=[AND(>(COUNT_REDUCE($1), 10), >=(MAX_REDUCE($3), 0), <(MIN_REDUCE($4), 20), <=(SUM_REDUCE($2), 10), =(AVG_REDUCE(SUM_REDUCE($2), COUNT_REDUCE($1)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[COUNT($1)], agg#1=[$SUM0($2)], agg#2=[MAX($3)], agg#3=[MIN($4)])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[COUNT()], agg#1=[$SUM0($2)], agg#2=[MAX($2)], agg#3=[MIN($2)])",
          "\n          LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n            LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by aggregation kurtosis and skewness with limit",
        "sql": "EXPLAIN PLAN FOR SELECT a.col6, SKEWNESS(a.col3), KURTOSIS(a.col3) FROM a GROUP BY a.col6 LIMIT 100",
        "output": [
          "Execution Plan",
          "\nLogicalSort(offset=[0], fetch=[100])",
          "\n  PinotLogicalSortExchange(distribution=[hash], collation=[[]], isSortOnSender=[false], isSortOnReceiver=[false])",
          "\n    LogicalSort(fetch=[100])",
          "\n      LogicalProject(col6=[$0], EXPR$1=[SKEWNESS_REDUCE($1)], EXPR$2=[KURTOSIS_REDUCE($1)])",
          "\n        LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)])",
          "\n          PinotLogicalExchange(distribution=[hash[0]])",
          "\n            LogicalAggregate(group=[{5}], agg#0=[FOURTHMOMENT($2)])",
          "\n              LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by transform inside aggregation and transform in group by",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SKEWNESS(ADD(a.col3, a.col6)), DISTINCTCOUNT(CONCAT(a.col1, '-', 'a.col2')) FROM a GROUP BY REVERSE(a.col1)",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[SKEWNESS_REDUCE($1)], EXPR$2=[CAST(COUNT_DISTINCT_REDUCE($2)):BIGINT NOT NULL])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[DISTINCTCOUNT($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[DISTINCTCOUNT($2)])",
          "\n        LogicalProject(EXPR$0=[REVERSE($0)], $f1=[ADD($2, $5)], $f2=[CONCAT($0, '-', 'a.col2')])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "Group by transform inside aggregation and transform in group by with filter with transform",
        "sql": "EXPLAIN PLAN FOR SELECT REVERSE(a.col1), SKEWNESS(ADD(a.col3, a.col6)), DISTINCTCOUNT(CONCAT(a.col1, '-', 'a.col2')) FROM a WHERE a.col3 >= 42 AND SUBSTR(a.col2, 0, 4) != 'prod' GROUP BY REVERSE(a.col1)",
        "output": [
          "Execution Plan",
          "\nLogicalProject(EXPR$0=[$0], EXPR$1=[SKEWNESS_REDUCE($1)], EXPR$2=[CAST(COUNT_DISTINCT_REDUCE($2)):BIGINT NOT NULL])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[DISTINCTCOUNT($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalAggregate(group=[{0}], agg#0=[FOURTHMOMENT($1)], agg#1=[DISTINCTCOUNT($2)])",
          "\n        LogicalProject(EXPR$0=[REVERSE($0)], $f1=[ADD($2, $5)], $f2=[CONCAT($0, '-', 'a.col2')])",
          "\n          LogicalFilter(condition=[AND(>=($2, 42), <>(SUBSTR($1, 0, 4), 'prod'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with select and aggregate column",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, SUM(a.col3) FROM a GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with select and AVG aggregation",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, AVG(a.col3) FROM a GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[AVG_REDUCE(SUM_REDUCE($1), COUNT_REDUCE($2))])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT()])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with select and multiple aggregations one 1 column",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, SUM(a.col3), AVG(a.col3), MAX(a.col3), MIN(a.col3) FROM a GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)], EXPR$2=[AVG_REDUCE(SUM_REDUCE($1), COUNT_REDUCE($2))], EXPR$3=[MAX_REDUCE($3)], EXPR$4=[MIN_REDUCE($4)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($1)], agg#1=[COUNT()], agg#2=[MAX($1)], agg#3=[MIN($1)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col3=[$2])",
          "\n        LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with filter",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with filter",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, SUM(a.col3), MAX(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)], EXPR$2=[MAX_REDUCE($2)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)], agg#1=[MAX($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization count(*) with filter",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, COUNT(*) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1",
        "notes": "TODO: Needs follow up. Project should only keep a.col1 since the other columns are pushed to the filter, but it currently keeps them all",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[COUNT_REDUCE($1)])",
          "\n  LogicalAggregate(group=[{0}], agg#0=[COUNT()])",
          "\n    PinotLogicalExchange(distribution=[hash[0]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization on 2 columns with filter",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col2, a.col1, SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col1 = 'a'  GROUP BY a.col1, a.col2",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col2=[$1], col1=[$0], EXPR$2=[SUM_REDUCE($2)])",
          "\n  LogicalAggregate(group=[{0, 1}], agg#0=[$SUM0($2)])",
          "\n    PinotLogicalExchange(distribution=[hash[0, 1]])",
          "\n      LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n        LogicalFilter(condition=[AND(>=($2, 0), =($0, 'a'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with having clause",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, COUNT(*), SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING COUNT(*) > 10 AND MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SUM(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[COUNT_REDUCE($1)], EXPR$2=[SUM_REDUCE($2)])",
          "\n  LogicalFilter(condition=[AND(>(COUNT_REDUCE($1), 10), >=(MAX_REDUCE($3), 0), <(MIN_REDUCE($4), 20), <=(SUM_REDUCE($2), 10), =(AVG_REDUCE(SUM_REDUCE($2), COUNT_REDUCE($1)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[COUNT()], agg#1=[$SUM0($2)], agg#2=[MAX($2)], agg#3=[MIN($2)])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with having clause but no count",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1, SUM(a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SUM(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(col1=[$0], EXPR$1=[SUM_REDUCE($1)])",
          "\n  LogicalFilter(condition=[AND(>=(MAX_REDUCE($2), 0), <(MIN_REDUCE($3), 20), <=(SUM_REDUCE($1), 10), =(AVG_REDUCE(SUM_REDUCE($1), COUNT_REDUCE($4)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[$SUM0($2)], agg#1=[MAX($2)], agg#2=[MIN($2)], agg#3=[COUNT()])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with having clause and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ a.col1 as value1, COUNT(*) AS count, SUM(a.col3) as SUM FROM a WHERE a.col3 >= 0 AND a.col2 = 'a' GROUP BY a.col1 HAVING COUNT(*) > 10 AND MAX(a.col3) >= 0 AND MIN(a.col3) < 20 AND SUM(a.col3) <= 10 AND AVG(a.col3) = 5",
        "output": [
          "Execution Plan",
          "\nLogicalProject(value1=[$0], count=[COUNT_REDUCE($1)], SUM=[SUM_REDUCE($2)])",
          "\n  LogicalFilter(condition=[AND(>(COUNT_REDUCE($1), 10), >=(MAX_REDUCE($3), 0), <(MIN_REDUCE($4), 20), <=(SUM_REDUCE($2), 10), =(AVG_REDUCE(SUM_REDUCE($2), COUNT_REDUCE($1)), 5))])",
          "\n    LogicalAggregate(group=[{0}], agg#0=[COUNT()], agg#1=[$SUM0($2)], agg#2=[MAX($2)], agg#3=[MIN($2)])",
          "\n      PinotLogicalExchange(distribution=[hash[0]])",
          "\n        LogicalProject(col1=[$0], col2=[$1], col3=[$2])",
          "\n          LogicalFilter(condition=[AND(>=($2, 0), =($1, 'a'))])",
          "\n            LogicalTableScan(table=[[a]])",
          "\n"
        ]
      },
      {
        "description": "SQL hint based group by optimization with select and aggregates with filters and select alias",
        "sql": "EXPLAIN PLAN FOR SELECT /*+ skipLeafStageGroupByAggregation */ ts, KURTOSIS(a.col3) as kurtosis, SKEWNESS(a.col6) as skewness, COUNT(DISTINCT a.col6), COUNT(DISTINCT a.col3) FROM a WHERE a.col3 >= 0 AND a.col2 = 'metallica' GROUP BY ts",
        "output": [
          "Execution Plan",
          "\nLogicalProject(ts=[$0], kurtosis=[KURTOSIS_REDUCE($1)], skewness=[SKEWNESS_REDUCE($2)], EXPR$3=[CAST(COUNT_DISTINCT_REDUCE($3)):BIGINT NOT NULL], EXPR$4=[CAST(COUNT_DISTINCT_REDUCE($4)):BIGINT NOT NULL])",
          "\n  LogicalAggregate(group=[{3}], agg#0=[FOURTHMOMENT($1)], agg#1=[FOURTHMOMENT($2)], agg#2=[DISTINCTCOUNT(DISTINCT $2)], agg#3=[DISTINCTCOUNT(DISTINCT $1)])",
          "\n    PinotLogicalExchange(distribution=[hash[3]])",
          "\n      LogicalProject(col2=[$1], col3=[$2], col6=[$5], ts=[$6])",
          "\n        LogicalFilter(condition=[AND(>=($2, 0), =($1, 'metallica'))])",
          "\n          LogicalTableScan(table=[[a]])",
          "\n"
        ]
      }
    ]
  }
}